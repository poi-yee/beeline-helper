// ==UserScript==
// @name         芯位助手-Beeline Helper
// @namespace    https://github.com/poi-yee/51xinweiauto
// @version      0.8.3
// @author       PoiYee,Code-dogcreatior
// @description  芯位蜜线/教育 自动播放，自动刷作业
// @icon         data:image/png;base64,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
// @match        *://*.beeline-ai.com/*
// @require      https://cdn.jsdelivr.net/npm/systemjs@6.15.1/dist/system.min.js
// @require      https://cdn.jsdelivr.net/npm/systemjs@6.15.1/dist/extras/named-register.min.js
// @require      data:application/javascript,%3B(typeof%20System!%3D'undefined')%26%26(System%3Dnew%20System.constructor())%3B
// @grant        GM_addStyle
// @grant        GM_deleteValue
// @grant        GM_getValue
// @grant        GM_setValue
// ==/UserScript==

(e=>{if(typeof GM_addStyle=="function"){GM_addStyle(e);return}const a=document.createElement("style");a.textContent=e,document.head.append(a)})(' .floating-window[data-v-1f178cdb]{position:fixed;bottom:20px;right:20px;width:320px;height:360px;background:#fff;border-radius:12px;box-shadow:0 4px 16px #00000026;overflow:hidden;display:flex;flex-direction:column;z-index:1000;transition:opacity .3s ease,transform .3s ease,width .3s ease,height .3s ease}.floating-window.auto-answer-mode[data-v-1f178cdb]{height:800px;width:400px}.floating-window.window-hidden[data-v-1f178cdb]{opacity:0;transform:scale(.8);pointer-events:none}.window-header[data-v-1f178cdb]{display:flex;justify-content:space-between;align-items:center;padding:16px;background:linear-gradient(135deg,#667eea,#764ba2);color:#fff;border-radius:12px 12px 0 0;cursor:move;user-select:none}.back-btn[data-v-1f178cdb]{background:none;border:none;color:#fff;font-size:18px;cursor:pointer;width:24px;height:24px;display:flex;align-items:center;justify-content:center;border-radius:50%;transition:background-color .2s}.back-btn[data-v-1f178cdb]:hover{background:#fff3}.window-header h3[data-v-1f178cdb]{margin:0;font-size:16px;font-weight:600}.close-btn[data-v-1f178cdb]{background:none;border:none;color:#fff;font-size:20px;cursor:pointer;width:24px;height:24px;display:flex;align-items:center;justify-content:center;border-radius:50%;transition:background-color .2s}.close-btn[data-v-1f178cdb]:hover{background:#fff3}.window-content[data-v-1f178cdb]{flex:1;padding:20px;overflow:hidden;display:flex;flex-direction:column}.status-window[data-v-99aa1d36]{position:fixed;left:20px;bottom:80px;width:280px;max-height:270px;background:#fff;border-radius:8px;box-shadow:0 4px 15px #0003;border:1px solid #e0e0e0;z-index:9998;pointer-events:auto;overflow:hidden}.status-header[data-v-99aa1d36]{padding:9px 16px;background:linear-gradient(135deg,#667eea,#764ba2);color:#fff;font-size:14px;font-weight:600}.status-content[data-v-99aa1d36]{padding:12px 16px;max-height:240px;overflow-y:auto}.current-status[data-v-99aa1d36]{margin-bottom:12px;padding-bottom:12px;border-bottom:1px solid #f0f0f0}.status-label[data-v-99aa1d36]{font-size:12px;color:#666;margin-right:8px}.status-value[data-v-99aa1d36]{font-size:12px;font-weight:600}.status-detecting[data-v-99aa1d36]{color:#ff9800}.status-waiting[data-v-99aa1d36]{color:#2196f3}.status-success[data-v-99aa1d36]{color:#4caf50}.status-no-button[data-v-99aa1d36]{color:#f44336}.status-stopped[data-v-99aa1d36]{color:#9e9e9e}.operation-history[data-v-99aa1d36]{margin-top:8px}.history-title[data-v-99aa1d36]{font-size:12px;color:#666;margin-bottom:8px;font-weight:600}.history-list[data-v-99aa1d36]{max-height:150px;overflow-y:auto}.history-item[data-v-99aa1d36]{display:flex;justify-content:space-between;align-items:flex-start;margin-bottom:6px;padding:4px 0;font-size:11px;line-height:1.3}.history-time[data-v-99aa1d36]{color:#999;min-width:45px;margin-right:8px}.history-message[data-v-99aa1d36]{color:#333;flex:1}.no-history[data-v-99aa1d36]{font-size:11px;color:#999;text-align:center;padding:8px 0}.control-button[data-v-29767e33]{position:fixed;left:20px;bottom:20px;width:50px;height:50px;background:linear-gradient(135deg,#667eea,#764ba2);border-radius:50%;display:flex;align-items:center;justify-content:center;cursor:pointer;box-shadow:0 4px 15px #667eea66;transition:all .3s ease;z-index:9999;pointer-events:auto}.control-button[data-v-29767e33]:hover{transform:scale(1.1);box-shadow:0 6px 20px #667eea99}.control-button.button-hidden[data-v-29767e33]{opacity:.7;transform:scale(.9)}.button-icon[data-v-29767e33]{font-size:20px;color:#fff}.features[data-v-fb2a58e0]{display:flex;flex-direction:column;gap:8px;margin-top:16px}.feature-btn[data-v-fb2a58e0]{padding:10px 16px;background:#f5f5f5;border:1px solid #ddd;border-radius:6px;cursor:pointer;transition:all .2s;font-size:14px}.feature-btn[data-v-fb2a58e0]:hover{background:#e9e9e9;border-color:#ccc}.toggle-features[data-v-3bb0b416]{display:flex;flex-direction:column;gap:16px;margin-top:16px}.toggle-item[data-v-3bb0b416]{display:flex;justify-content:space-between;align-items:center;padding:12px 0;border-bottom:1px solid #f0f0f0}.toggle-label[data-v-3bb0b416]{font-size:14px;color:#333;font-weight:500}.toggle-label.FxxK-xin-wei[data-v-3bb0b416]{color:red;font-weight:700}.feature-description[data-v-3bb0b416]{font-size:12px;color:#666;margin-top:4px;font-weight:400}.toggle-switch[data-v-3bb0b416]{position:relative;display:inline-block;width:44px;height:24px}.toggle-switch input[data-v-3bb0b416]{opacity:0;width:0;height:0}.toggle-slider[data-v-3bb0b416]{position:absolute;cursor:pointer;inset:0;background-color:#ccc;transition:.4s;border-radius:24px}.toggle-slider[data-v-3bb0b416]:before{position:absolute;content:"";height:18px;width:18px;left:3px;bottom:3px;background-color:#fff;transition:.4s;border-radius:50%}.toggle-switch input:checked+.toggle-slider[data-v-3bb0b416]{background-color:#667eea}.toggle-switch input:disabled+.toggle-slider[data-v-3bb0b416]{background-color:#ccc;cursor:not-allowed}.toggle-switch input:disabled+.toggle-slider[data-v-3bb0b416]:before{background-color:#f5f5f5}.toggle-switch input:checked+.toggle-slider[data-v-3bb0b416]:before{transform:translate(20px)}.answer-settings-page[data-v-bbdf02b5]{height:100%;display:flex;flex-direction:column;overflow-y:auto;padding-right:4px}.answer-settings-page[data-v-bbdf02b5]::-webkit-scrollbar{width:6px}.answer-settings-page[data-v-bbdf02b5]::-webkit-scrollbar-track{background:#f1f1f1;border-radius:3px}.answer-settings-page[data-v-bbdf02b5]::-webkit-scrollbar-thumb{background:#c1c1c1;border-radius:3px}.answer-settings-page[data-v-bbdf02b5]::-webkit-scrollbar-thumb:hover{background:#a8a8a8}.settings-section[data-v-bbdf02b5]{flex:1;display:flex;flex-direction:column;gap:20px}.settings-section h3[data-v-bbdf02b5]{margin-bottom:12px;font-size:16px;color:#333;font-weight:600}.token-section[data-v-bbdf02b5]{background:#f9fafc;border:1px solid #e3e7eb;padding:16px;border-radius:12px;transition:box-shadow .2s}.token-section[data-v-bbdf02b5]:hover{box-shadow:0 2px 8px #0000000f}.token-link[data-v-bbdf02b5]{display:inline-block;margin-bottom:12px;color:#007bff;text-decoration:none;font-weight:500;font-size:14px}.token-link[data-v-bbdf02b5]:hover{text-decoration:underline}.token-input-box[data-v-bbdf02b5]{display:flex;flex-direction:column;gap:6px;margin-bottom:12px}.token-input-box[data-v-bbdf02b5]:last-child{margin-bottom:0}.token-input-box label[data-v-bbdf02b5]{font-size:13px;color:#495057;font-weight:500}.token-input[data-v-bbdf02b5]{padding:10px;border:1px solid #ccc;border-radius:8px;font-size:14px;outline:none;transition:border-color .2s,box-shadow .2s}.token-input[data-v-bbdf02b5]:focus{border-color:#007bff;box-shadow:0 0 0 2px #007bff26}.ai-settings-section[data-v-bbdf02b5]{background:#f0f8ff;border:1px solid #b8daff;padding:16px;border-radius:12px;margin-top:16px}.ai-settings-section h4[data-v-bbdf02b5]{margin-bottom:12px;font-size:14px;color:#004085;font-weight:600}.toggle-item[data-v-bbdf02b5]{margin-bottom:8px}.toggle-label[data-v-bbdf02b5]{display:flex;align-items:center;gap:8px;cursor:pointer;font-size:14px;color:#495057}.toggle-label input[type=checkbox][data-v-bbdf02b5]{display:none}.toggle-slider[data-v-bbdf02b5]{position:relative;width:40px;height:20px;background:#ced4da;border-radius:20px;transition:all .3s}.toggle-slider[data-v-bbdf02b5]:before{content:"";position:absolute;width:16px;height:16px;background:#fff;border-radius:50%;top:2px;left:2px;transition:all .3s}.toggle-label input[type=checkbox]:checked+.toggle-slider[data-v-bbdf02b5]{background:#007bff}.toggle-label input[type=checkbox]:checked+.toggle-slider[data-v-bbdf02b5]:before{transform:translate(20px)}.advanced-section[data-v-bbdf02b5]{background:#fff3cd;border:1px solid #ffeaa7;padding:16px;border-radius:12px;margin-top:16px}.advanced-section h4[data-v-bbdf02b5]{margin-bottom:8px;font-size:14px;color:#856404;font-weight:600}.warning-text[data-v-bbdf02b5]{font-size:12px;color:#856404;margin-bottom:12px;font-style:italic}.textarea-input[data-v-bbdf02b5]{resize:vertical;min-height:60px}.settings-info[data-v-bbdf02b5]{background:#e8f4fd;border:1px solid #b8daff;padding:16px;border-radius:8px}.info-text[data-v-bbdf02b5]{font-size:14px;color:#004085;margin-bottom:8px}.info-list[data-v-bbdf02b5]{margin:0;padding-left:20px;font-size:13px;color:#004085;line-height:1.5}.info-list li[data-v-bbdf02b5]{margin-bottom:4px}.status-section[data-v-bbdf02b5]{text-align:center}.status-message[data-v-bbdf02b5]{padding:8px 16px;border-radius:4px;font-size:14px}.status-message.success[data-v-bbdf02b5]{background:#d4edda;color:#155724;border:1px solid #c3e6cb}.status-message.error[data-v-bbdf02b5]{background:#f8d7da;color:#721c24;border:1px solid #f5c6cb}.auto-answer-page[data-v-c8c99884]{height:100%;display:flex;flex-direction:column;overflow:auto;position:relative}.overlay-blocker[data-v-c8c99884]{position:absolute;inset:0;background:#282828d9;backdrop-filter:blur(2px);-webkit-backdrop-filter:blur(8px);border-radius:8px;display:flex;align-items:center;justify-content:center;z-index:9999;overflow:hidden}.overlay-blocker[data-v-c8c99884]:before{content:"";position:absolute;inset:0;background:radial-gradient(circle at center,#000c,#0009 50%,#0003 80%,#0000);pointer-events:none}.overlay-content[data-v-c8c99884]{text-align:center;background:linear-gradient(135deg,#fff,#f8f9fa);padding:28px 24px;border-radius:16px;max-width:280px;border:1px solid rgba(255,255,255,.8);backdrop-filter:blur(10px);-webkit-backdrop-filter:blur(10px);animation:fadeInScale-c8c99884 .4s ease-out}@keyframes fadeInScale-c8c99884{0%{opacity:0;transform:scale(.9)}to{opacity:1;transform:scale(1)}}.warning-icon[data-v-c8c99884]{font-size:56px;margin-bottom:20px;filter:drop-shadow(0 2px 4px rgba(0,0,0,.1))}.icon-text[data-v-c8c99884]{display:block}.warning-text[data-v-c8c99884]{font-size:16px;font-weight:600;color:#d93025;line-height:1.4;text-shadow:0 1px 2px rgba(0,0,0,.1)}.navigation-section[data-v-c8c99884]{display:flex;gap:8px;margin-bottom:16px}.nav-btn[data-v-c8c99884]{flex:1;padding:8px 12px;border:1px solid #ced4da;border-radius:6px;background:#fff;color:#495057;font-size:12px;cursor:pointer;transition:all .2s}.nav-btn[data-v-c8c99884]:hover{background:#f8f9fa}.nav-btn.active[data-v-c8c99884]{background:#007bff;color:#fff;border-color:#007bff}.subpage-content[data-v-c8c99884]{flex:1;display:flex;flex-direction:column;overflow:auto}.config-section[data-v-c8c99884],.actions-section[data-v-c8c99884],.progress-section[data-v-c8c99884],.status-section[data-v-c8c99884]{margin-bottom:20px}.results-section[data-v-c8c99884]{flex:1;display:flex;flex-direction:column;overflow:hidden;margin-bottom:20px}.config-section h3[data-v-c8c99884],.actions-section h3[data-v-c8c99884],.progress-section h3[data-v-c8c99884],.results-section h3[data-v-c8c99884]{margin-bottom:12px;font-size:16px;color:#333}.config-item[data-v-c8c99884]{display:flex;flex-direction:column;gap:8px}.config-item label[data-v-c8c99884]{font-size:14px;color:#495057}.toggle-with-actions[data-v-c8c99884]{display:flex;align-items:center;gap:16px}.toggle-label[data-v-c8c99884]{display:flex;align-items:center;gap:8px;cursor:pointer;font-size:14px;color:#495057;white-space:nowrap}.toggle-label input[type=checkbox][data-v-c8c99884]{display:none}.toggle-slider[data-v-c8c99884]{position:relative;width:40px;height:20px;background:#ced4da;border-radius:20px;transition:all .3s}.toggle-slider[data-v-c8c99884]:before{content:"";position:absolute;width:16px;height:16px;background:#fff;border-radius:50%;top:2px;left:2px;transition:all .3s}.toggle-label input[type=checkbox]:checked+.toggle-slider[data-v-c8c99884]{background:#007bff}.toggle-label input[type=checkbox]:checked+.toggle-slider[data-v-c8c99884]:before{transform:translate(20px)}.token-input[data-v-c8c99884]{padding:8px 12px;border:1px solid #ced4da;border-radius:4px;font-size:14px}.token-input[data-v-c8c99884]:focus{outline:none;border-color:#007bff;box-shadow:0 0 0 2px #007bff40}.action-buttons[data-v-c8c99884]{display:flex;flex-direction:row;gap:8px;width:100%}.action-btn[data-v-c8c99884]{padding:8px 12px;border:none;border-radius:6px;font-size:12px;cursor:pointer;transition:all .2s;white-space:nowrap}.action-btn[data-v-c8c99884]:disabled{opacity:.6;cursor:not-allowed}.action-btn.primary[data-v-c8c99884]{background:#007bff;color:#fff}.action-btn.primary[data-v-c8c99884]:hover:not(:disabled){background:#0056b3}.action-btn.secondary[data-v-c8c99884]{background:#6c757d;color:#fff}.action-btn.secondary[data-v-c8c99884]:hover:not(:disabled){background:#545b62}.action-btn.danger[data-v-c8c99884]{background:#dc3545;color:#fff}.action-btn.danger[data-v-c8c99884]:hover:not(:disabled){background:#c82333}.single-result[data-v-c8c99884]{margin-bottom:16px}.batch-results[data-v-c8c99884]{margin-top:16px}.filter-buttons[data-v-c8c99884]{display:flex;gap:8px;margin-bottom:12px}.filter-btn[data-v-c8c99884]{padding:6px 12px;border:1px solid #ced4da;border-radius:4px;background:#fff;color:#495057;font-size:12px;cursor:pointer;transition:all .2s}.filter-btn[data-v-c8c99884]:hover{background:#f8f9fa}.filter-btn.active[data-v-c8c99884]{background:#007bff;color:#fff;border-color:#007bff}.filter-btn.ai-filter.active[data-v-c8c99884]{background:#ffc107;color:#212529;border-color:#ffc107}.results-list[data-v-c8c99884]{flex:1;overflow-y:auto;min-height:0;max-height:300px;padding-right:4px}.results-list[data-v-c8c99884]::-webkit-scrollbar{width:6px}.results-list[data-v-c8c99884]::-webkit-scrollbar-track{background:#f1f1f1;border-radius:3px}.results-list[data-v-c8c99884]::-webkit-scrollbar-thumb{background:#c1c1c1;border-radius:3px}.results-list[data-v-c8c99884]::-webkit-scrollbar-thumb:hover{background:#a8a8a8}.result-item[data-v-c8c99884]{padding:12px;margin-bottom:8px;border-radius:6px;border-left:4px solid #6c757d}.result-item.success[data-v-c8c99884]{background:#d4edda;border-left-color:#28a745}.result-item.error[data-v-c8c99884]{background:#f8d7da;border-left-color:#dc3545}.result-item.ai-assisted[data-v-c8c99884]{background:#fff3cd;border-left-color:#ffc107}.ai-indicator[data-v-c8c99884]{background:#ffc107;color:#212529;padding:2px 6px;border-radius:12px;font-size:10px;margin-left:8px;font-weight:700}.result-header[data-v-c8c99884]{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}.result-type[data-v-c8c99884]{font-size:14px;font-weight:700;color:#495057}.result-status[data-v-c8c99884]{font-size:12px;padding:2px 8px;border-radius:12px;color:#fff}.result-status.success[data-v-c8c99884]{background:#28a745}.result-status.error[data-v-c8c99884]{background:#dc3545}.result-message[data-v-c8c99884]{font-size:14px;color:#495057;margin-bottom:4px}.result-question[data-v-c8c99884],.result-answer[data-v-c8c99884],.result-options[data-v-c8c99884]{font-size:12px;color:#6c757d;margin-bottom:2px}.progress-section[data-v-c8c99884]{background:#e9ecef;padding:12px;border-radius:6px;border-left:4px solid #007bff}.progress-info[data-v-c8c99884]{display:flex;flex-direction:column;gap:4px}.progress-text[data-v-c8c99884]{font-size:14px;font-weight:700;color:#495057}.progress-status[data-v-c8c99884]{font-size:12px;color:#6c757d}.status-section[data-v-c8c99884]{text-align:center}.status-message[data-v-c8c99884]{padding:8px 16px;border-radius:4px;font-size:14px}.status-message.success[data-v-c8c99884]{background:#d4edda;color:#155724;border:1px solid #c3e6cb}.status-message.error[data-v-c8c99884]{background:#f8d7da;color:#721c24;border:1px solid #f5c6cb}.toggle-features[data-v-cd8b7e2c]{display:flex;flex-direction:column;gap:16px;margin-top:16px}.toggle-item[data-v-cd8b7e2c]{display:flex;justify-content:space-between;align-items:center;padding:12px 0;border-bottom:1px solid #f0f0f0}.toggle-label-container[data-v-cd8b7e2c]{display:flex;align-items:center;gap:8px}.toggle-label[data-v-cd8b7e2c]{font-size:14px;color:#333;font-weight:500}.settings-icon[data-v-cd8b7e2c]{background:none;border:none;cursor:pointer;padding:4px;border-radius:4px;color:#666;transition:all .2s}.settings-icon[data-v-cd8b7e2c]:hover{background:#f0f0f0;color:#333}.toggle-switch[data-v-cd8b7e2c]{position:relative;display:inline-block;width:44px;height:24px}.toggle-switch input[data-v-cd8b7e2c]{opacity:0;width:0;height:0}.toggle-slider[data-v-cd8b7e2c]{position:absolute;cursor:pointer;inset:0;background-color:#ccc;transition:.4s;border-radius:24px}.toggle-slider[data-v-cd8b7e2c]:before{position:absolute;content:"";height:18px;width:18px;left:3px;bottom:3px;background-color:#fff;transition:.4s;border-radius:50%}.toggle-switch input:checked+.toggle-slider[data-v-cd8b7e2c]{background-color:#667eea}.toggle-switch input:disabled+.toggle-slider[data-v-cd8b7e2c]{background-color:#ccc;cursor:not-allowed}.toggle-switch input:disabled+.toggle-slider[data-v-cd8b7e2c]:before{background-color:#f5f5f5}.toggle-switch input:checked+.toggle-slider[data-v-cd8b7e2c]:before{transform:translate(20px)}.rainbow-toggle[data-v-cd8b7e2c]{background:linear-gradient(90deg,red,#f90,#ff0,#3c3,#39f,#93c,#f39,red);background-size:200% 100%;animation:rainbow-scroll-cd8b7e2c 1.5s linear infinite}@keyframes rainbow-scroll-cd8b7e2c{0%{background-position:0% 0%}to{background-position:200% 0%}}.modal-overlay[data-v-cd8b7e2c]{position:fixed;inset:0;background:#00000080;display:flex;align-items:center;justify-content:center;z-index:1000}.modal-content[data-v-cd8b7e2c]{background:#fff;border-radius:12px;width:90%;max-width:500px;max-height:80vh;overflow-y:auto;box-shadow:0 10px 30px #0000004d}.modal-header[data-v-cd8b7e2c]{display:flex;justify-content:space-between;align-items:center;padding:20px 24px;border-bottom:1px solid #f0f0f0}.modal-header h4[data-v-cd8b7e2c]{margin:0;font-size:18px;color:#333}.close-btn[data-v-cd8b7e2c]{background:none;border:none;font-size:24px;cursor:pointer;color:#999;padding:0;width:30px;height:30px;display:flex;align-items:center;justify-content:center;border-radius:4px}.close-btn[data-v-cd8b7e2c]:hover{background:#f5f5f5;color:#333}.modal-body[data-v-cd8b7e2c]{padding:24px}.setting-group[data-v-cd8b7e2c]{margin-bottom:24px}.setting-label[data-v-cd8b7e2c]{display:block;margin-bottom:8px;font-size:14px;color:#333;font-weight:500}.image-input-group[data-v-cd8b7e2c]{display:flex;gap:8px}.url-input[data-v-cd8b7e2c]{flex:1;padding:8px 12px;border:1px solid #ddd;border-radius:6px;font-size:14px}.upload-btn[data-v-cd8b7e2c]{padding:8px 16px;background:#f5f5f5;border:1px solid #ddd;border-radius:6px;cursor:pointer;font-size:14px;transition:all .2s}.upload-btn[data-v-cd8b7e2c]:hover{background:#e9e9e9}.slider-group[data-v-cd8b7e2c]{display:flex;align-items:center;gap:12px}.slider[data-v-cd8b7e2c]{flex:1;height:6px;background:#ddd;border-radius:3px;outline:none;-webkit-appearance:none}.slider[data-v-cd8b7e2c]::-webkit-slider-thumb{-webkit-appearance:none;width:18px;height:18px;background:#667eea;border-radius:50%;cursor:pointer}.slider[data-v-cd8b7e2c]::-moz-range-thumb{width:18px;height:18px;background:#667eea;border-radius:50%;cursor:pointer;border:none}.slider-value[data-v-cd8b7e2c]{min-width:40px;font-size:14px;color:#666;text-align:right}.preview-section[data-v-cd8b7e2c]{margin-top:24px;padding-top:16px;border-top:1px solid #f0f0f0}.preview-section h5[data-v-cd8b7e2c]{margin:0 0 12px;font-size:14px;color:#333}.preview-box[data-v-cd8b7e2c]{width:100%;height:120px;border-radius:8px;border:1px solid #ddd;position:relative;overflow:hidden}.preview-overlay[data-v-cd8b7e2c]{position:absolute;top:0;left:0;width:100%;height:100%;background-color:#00000080;transition:opacity .3s ease}.preview-glass[data-v-cd8b7e2c]{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background:#fff3;padding:8px 16px;border-radius:6px;color:#333;font-size:14px;font-weight:500;backdrop-filter:blur(12px);z-index:1}.modal-footer[data-v-cd8b7e2c]{padding:20px 24px;border-top:1px solid #f0f0f0;display:flex;gap:12px;justify-content:flex-end}.save-btn[data-v-cd8b7e2c]{padding:8px 20px;background:#667eea;color:#fff;border:none;border-radius:6px;cursor:pointer;font-size:14px;transition:background .2s}.save-btn[data-v-cd8b7e2c]:hover{background:#5a6fd8}.cancel-btn[data-v-cd8b7e2c]{padding:8px 20px;background:#f5f5f5;border:1px solid #ddd;border-radius:6px;cursor:pointer;font-size:14px;transition:all .2s}.cancel-btn[data-v-cd8b7e2c]:hover{background:#e9e9e9}.back-btn-container[data-v-cd8b7e2c]{margin-top:20px;text-align:center}.back-btn[data-v-cd8b7e2c]{padding:8px 16px;background:#f5f5f5;border:1px solid #ddd;border-radius:6px;cursor:pointer;font-size:14px;transition:all .2s}.back-btn[data-v-cd8b7e2c]:hover{background:#e9e9e9;border-color:#ccc}h3[data-v-cd8b7e2c]{margin:0 0 16px;font-size:16px;color:#333;text-align:center}.about-page[data-v-30e112b7]{height:100%;background:linear-gradient(135deg,#f5f7fa,#e4ebf5);display:flex;flex-wrap:wrap;box-sizing:border-box;overflow-y:auto;opacity:1;transform:scale(1);transition:all .3s ease-in-out}.about-page.closing[data-v-30e112b7]{opacity:0;transform:scale(.9)}.left-panel[data-v-30e112b7],.right-panel[data-v-30e112b7]{flex:1;min-width:320px;padding:40px;box-sizing:border-box}.left-panel[data-v-30e112b7]{background:linear-gradient(135deg,#eef2f3,#dfe9f3);display:flex;flex-direction:column;align-items:center;justify-content:center}.title[data-v-30e112b7]{font-size:22px;font-weight:600;text-align:center;margin-bottom:16px}.gradient-text[data-v-30e112b7]{background:linear-gradient(90deg,#007bff,#00c6ff);-webkit-background-clip:text;background-clip:text;color:transparent}.image-box[data-v-30e112b7]{text-align:center;margin:20px 0;padding:10px;background:#fff;border-radius:12px;box-shadow:0 4px 12px #00000014}.pay-image[data-v-30e112b7]{width:590px;height:auto;border-radius:10px;object-fit:contain}.subtitle[data-v-30e112b7]{color:#555;text-align:center;font-size:15px;margin-top:12px}.right-panel .content[data-v-30e112b7]{line-height:1.6;color:#333;font-size:15px;margin-bottom:15px}.main-title[data-v-30e112b7]{font-size:24px;background:linear-gradient(45deg,#2b3a55,#ce7777);-webkit-background-clip:text;background-clip:text;color:transparent;margin-bottom:24px}.section-title[data-v-30e112b7]{font-size:18px;color:#2b3a55;margin-bottom:12px;font-weight:600}.info-block[data-v-30e112b7]{background:#fff;padding:16px;border-radius:8px;margin-bottom:16px;box-shadow:0 2px 8px #0000000d}.info-block p[data-v-30e112b7]{margin:8px 0;line-height:1.6;font-size:14px;color:#4a4a4a}.highlight[data-v-30e112b7]{color:#ce7777!important;font-size:16px!important}.warning[data-v-30e112b7]{color:#d93025;font-weight:600;background:#d930250d;padding:8px 12px;border-radius:6px;border-left:4px solid #d93025}.guide-link[data-v-30e112b7]{text-align:center;margin:12px 0!important}.guide-link a[data-v-30e112b7]{display:inline-block;padding:10px 20px;background:#f8f9fa;border:1px solid #e9ecef;border-radius:6px;color:#2b3a55;text-decoration:none;font-weight:500;transition:all .2s ease}.guide-link a[data-v-30e112b7]:hover{background:#e9ecef;transform:translateY(-2px);box-shadow:0 2px 4px #0000000d}.guide-link-inline[data-v-30e112b7]{margin-left:16px;text-decoration:none;color:#007bff;font-size:15px;font-weight:500;padding:4px 10px;background:#007bff1a;border-radius:6px;transition:all .2s ease;display:inline-flex;align-items:center;border:1px solid rgba(0,123,255,.2)}.guide-link-inline[data-v-30e112b7]:hover{color:#0056b3;background:#007bff26;transform:translateY(-1px);box-shadow:0 2px 4px #007bff1a}.token-section[data-v-30e112b7]{background:#f9fafc;border:1px solid #e3e7eb;padding:14px;border-radius:12px;margin:20px 0;transition:box-shadow .2s}.token-section[data-v-30e112b7]:hover{box-shadow:0 2px 8px #0000000f}.token-link[data-v-30e112b7]{display:inline-block;margin-bottom:8px;color:#007bff;text-decoration:none;font-weight:500}.token-link[data-v-30e112b7]:hover{text-decoration:underline}.token-info[data-v-30e112b7]{font-size:14px;color:#666;margin-bottom:8px;line-height:1.4}.token-info strong[data-v-30e112b7]{color:#007bff}.token-input[data-v-30e112b7]{padding:10px;border:1px solid #ccc;border-radius:8px;font-size:14px;outline:none;transition:border-color .2s,box-shadow .2s}.token-input[data-v-30e112b7]:focus{border-color:#007bff;box-shadow:0 0 0 2px #007bff26}.feedback[data-v-30e112b7]{font-size:14px;color:#666}.feedback a[data-v-30e112b7]{color:#007bff;text-decoration:none}.feedback a[data-v-30e112b7]:hover{text-decoration:underline}.agree-label[data-v-30e112b7]{font-size:15px;color:#666;display:flex;align-items:center;gap:8px;margin-top:12px;cursor:pointer;user-select:none;font-weight:500}.agree-label input[type=checkbox][data-v-30e112b7]{width:16px;height:16px;cursor:pointer;appearance:none;-webkit-appearance:none;background-color:#fff;border:2px solid #007bff;border-radius:4px;display:inline-block;position:relative;transition:all .2s ease}.agree-label input[type=checkbox][data-v-30e112b7]:checked{background-color:#007bff;border-color:#007bff}.agree-label input[type=checkbox][data-v-30e112b7]:checked:after{content:"";position:absolute;left:4px;top:1px;width:4px;height:8px;border:solid white;border-width:0 2px 2px 0;transform:rotate(45deg)}.agree-label input[type=checkbox][data-v-30e112b7]:disabled{background-color:#e9ecef;border-color:#ced4da;cursor:not-allowed;opacity:.7}.close-btn[data-v-30e112b7]{display:block;width:100%;margin-top:24px;padding:12px;background:linear-gradient(90deg,#007bff,#0af);color:#fff;border:none;border-radius:10px;font-size:16px;font-weight:500;cursor:pointer;transition:all .25s ease}.close-btn[data-v-30e112b7]:hover{background:linear-gradient(90deg,#0056b3,#0080ff);transform:translateY(-2px)}.beeline-helper[data-v-5fcc6ae2]{pointer-events:auto}.page-container[data-v-5fcc6ae2]{position:relative;height:100%;overflow:hidden}.page-wrapper[data-v-5fcc6ae2]{position:absolute;top:0;left:0;width:100%;height:100%;overflow:hidden}.page-fade-enter-active[data-v-5fcc6ae2],.page-fade-leave-active[data-v-5fcc6ae2]{transition:opacity .3s ease}.page-fade-enter-from[data-v-5fcc6ae2],.page-fade-leave-to[data-v-5fcc6ae2]{opacity:0}.page-fade-enter-to[data-v-5fcc6ae2],.page-fade-leave-from[data-v-5fcc6ae2]{opacity:1}.about-overlay[data-v-5fcc6ae2]{position:fixed;inset:0;background:#0000008c;backdrop-filter:blur(4px);z-index:9999;display:flex;align-items:center;justify-content:center}.about-container[data-v-5fcc6ae2]{width:80%;height:80%;max-width:1400px;max-height:770px;background:#fff;border-radius:16px;box-shadow:0 8px 30px #0003;overflow:auto;animation:fadeIn-5fcc6ae2 .3s ease}@keyframes fadeIn-5fcc6ae2{0%{transform:scale(.95);opacity:0}to{transform:scale(1);opacity:1}}.about-fade-scale-enter-active[data-v-5fcc6ae2],.about-fade-scale-leave-active[data-v-5fcc6ae2]{transition:all .3s cubic-bezier(.4,0,.2,1)}.about-fade-scale-enter-from[data-v-5fcc6ae2],.about-fade-scale-leave-to[data-v-5fcc6ae2]{opacity:0;transform:scale(.95)}.about-fade-scale-enter-to[data-v-5fcc6ae2],.about-fade-scale-leave-from[data-v-5fcc6ae2]{opacity:1;transform:scale(1)}.status-fade-slide-enter-active[data-v-5fcc6ae2]{transition:opacity .3s ease-out,transform .3s ease-out}.status-fade-slide-leave-active[data-v-5fcc6ae2]{transition:opacity .3s ease-in,transform .3s ease-in}.status-fade-slide-enter-from[data-v-5fcc6ae2],.status-fade-slide-leave-to[data-v-5fcc6ae2]{opacity:0;transform:translate(-20px)}.status-fade-slide-enter-to[data-v-5fcc6ae2],.status-fade-slide-leave-from[data-v-5fcc6ae2]{opacity:1;transform:translate(0)} ');


System.register("./__entry.js", ['./__monkey.entry-C36_3piD.js'], (function (exports, module) {
	'use strict';
	return {
		setters: [null],
		execute: (function () {



		})
	};
}));

System.register("./__monkey.entry-C36_3piD.js", [], (function (exports, module) {
  'use strict';
  return {
    execute: (function () {

      exports({
        e: extractQuestionContent,
        g: getStorageValue$1,
        p: parseAnswer,
        q: queryAnswer
      });

      /**
      * @vue/shared v3.5.22
      * (c) 2018-present Yuxi (Evan) You and Vue contributors
      * @license MIT
      **/
      // @__NO_SIDE_EFFECTS__
      function makeMap(str) {
        const map = /* @__PURE__ */ Object.create(null);
        for (const key of str.split(",")) map[key] = 1;
        return (val) => val in map;
      }
      const EMPTY_OBJ = {};
      const EMPTY_ARR = [];
      const NOOP = () => {
      };
      const NO = () => false;
      const isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
      (key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
      const isModelListener = (key) => key.startsWith("onUpdate:");
      const extend = Object.assign;
      const remove = (arr, el) => {
        const i = arr.indexOf(el);
        if (i > -1) {
          arr.splice(i, 1);
        }
      };
      const hasOwnProperty$1 = Object.prototype.hasOwnProperty;
      const hasOwn = (val, key) => hasOwnProperty$1.call(val, key);
      const isArray = Array.isArray;
      const isMap = (val) => toTypeString(val) === "[object Map]";
      const isSet = (val) => toTypeString(val) === "[object Set]";
      const isDate = (val) => toTypeString(val) === "[object Date]";
      const isFunction = (val) => typeof val === "function";
      const isString = (val) => typeof val === "string";
      const isSymbol = (val) => typeof val === "symbol";
      const isObject = (val) => val !== null && typeof val === "object";
      const isPromise = (val) => {
        return (isObject(val) || isFunction(val)) && isFunction(val.then) && isFunction(val.catch);
      };
      const objectToString = Object.prototype.toString;
      const toTypeString = (value) => objectToString.call(value);
      const toRawType = (value) => {
        return toTypeString(value).slice(8, -1);
      };
      const isPlainObject = (val) => toTypeString(val) === "[object Object]";
      const isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
      const isReservedProp = /* @__PURE__ */ makeMap(
        // the leading comma is intentional so empty string "" is also included
        ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
      );
      const cacheStringFunction = (fn) => {
        const cache = /* @__PURE__ */ Object.create(null);
        return (str) => {
          const hit = cache[str];
          return hit || (cache[str] = fn(str));
        };
      };
      const camelizeRE = /-\w/g;
      const camelize = cacheStringFunction(
        (str) => {
          return str.replace(camelizeRE, (c) => c.slice(1).toUpperCase());
        }
      );
      const hyphenateRE = /\B([A-Z])/g;
      const hyphenate = cacheStringFunction(
        (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
      );
      const capitalize = cacheStringFunction((str) => {
        return str.charAt(0).toUpperCase() + str.slice(1);
      });
      const toHandlerKey = cacheStringFunction(
        (str) => {
          const s = str ? `on${capitalize(str)}` : ``;
          return s;
        }
      );
      const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
      const invokeArrayFns = (fns, ...arg) => {
        for (let i = 0; i < fns.length; i++) {
          fns[i](...arg);
        }
      };
      const def = (obj, key, value, writable = false) => {
        Object.defineProperty(obj, key, {
          configurable: true,
          enumerable: false,
          writable,
          value
        });
      };
      const looseToNumber = (val) => {
        const n = parseFloat(val);
        return isNaN(n) ? val : n;
      };
      const toNumber = (val) => {
        const n = isString(val) ? Number(val) : NaN;
        return isNaN(n) ? val : n;
      };
      let _globalThis;
      const getGlobalThis = () => {
        return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
      };
      function normalizeStyle(value) {
        if (isArray(value)) {
          const res = {};
          for (let i = 0; i < value.length; i++) {
            const item = value[i];
            const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);
            if (normalized) {
              for (const key in normalized) {
                res[key] = normalized[key];
              }
            }
          }
          return res;
        } else if (isString(value) || isObject(value)) {
          return value;
        }
      }
      const listDelimiterRE = /;(?![^(]*\))/g;
      const propertyDelimiterRE = /:([^]+)/;
      const styleCommentRE = /\/\*[^]*?\*\//g;
      function parseStringStyle(cssText) {
        const ret = {};
        cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
          if (item) {
            const tmp = item.split(propertyDelimiterRE);
            tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
          }
        });
        return ret;
      }
      function normalizeClass(value) {
        let res = "";
        if (isString(value)) {
          res = value;
        } else if (isArray(value)) {
          for (let i = 0; i < value.length; i++) {
            const normalized = normalizeClass(value[i]);
            if (normalized) {
              res += normalized + " ";
            }
          }
        } else if (isObject(value)) {
          for (const name in value) {
            if (value[name]) {
              res += name + " ";
            }
          }
        }
        return res.trim();
      }
      const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
      const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
      function includeBooleanAttr(value) {
        return !!value || value === "";
      }
      function looseCompareArrays(a, b) {
        if (a.length !== b.length) return false;
        let equal = true;
        for (let i = 0; equal && i < a.length; i++) {
          equal = looseEqual(a[i], b[i]);
        }
        return equal;
      }
      function looseEqual(a, b) {
        if (a === b) return true;
        let aValidType = isDate(a);
        let bValidType = isDate(b);
        if (aValidType || bValidType) {
          return aValidType && bValidType ? a.getTime() === b.getTime() : false;
        }
        aValidType = isSymbol(a);
        bValidType = isSymbol(b);
        if (aValidType || bValidType) {
          return a === b;
        }
        aValidType = isArray(a);
        bValidType = isArray(b);
        if (aValidType || bValidType) {
          return aValidType && bValidType ? looseCompareArrays(a, b) : false;
        }
        aValidType = isObject(a);
        bValidType = isObject(b);
        if (aValidType || bValidType) {
          if (!aValidType || !bValidType) {
            return false;
          }
          const aKeysCount = Object.keys(a).length;
          const bKeysCount = Object.keys(b).length;
          if (aKeysCount !== bKeysCount) {
            return false;
          }
          for (const key in a) {
            const aHasKey = a.hasOwnProperty(key);
            const bHasKey = b.hasOwnProperty(key);
            if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {
              return false;
            }
          }
        }
        return String(a) === String(b);
      }
      function looseIndexOf(arr, val) {
        return arr.findIndex((item) => looseEqual(item, val));
      }
      const isRef$1 = (val) => {
        return !!(val && val["__v_isRef"] === true);
      };
      const toDisplayString = (val) => {
        return isString(val) ? val : val == null ? "" : isArray(val) || isObject(val) && (val.toString === objectToString || !isFunction(val.toString)) ? isRef$1(val) ? toDisplayString(val.value) : JSON.stringify(val, replacer, 2) : String(val);
      };
      const replacer = (_key, val) => {
        if (isRef$1(val)) {
          return replacer(_key, val.value);
        } else if (isMap(val)) {
          return {
            [`Map(${val.size})`]: [...val.entries()].reduce(
              (entries, [key, val2], i) => {
                entries[stringifySymbol(key, i) + " =>"] = val2;
                return entries;
              },
              {}
            )
          };
        } else if (isSet(val)) {
          return {
            [`Set(${val.size})`]: [...val.values()].map((v) => stringifySymbol(v))
          };
        } else if (isSymbol(val)) {
          return stringifySymbol(val);
        } else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {
          return String(val);
        }
        return val;
      };
      const stringifySymbol = (v, i = "") => {
        var _a;
        return (
          // Symbol.description in es2019+ so we need to cast here to pass
          // the lib: es2016 check
          isSymbol(v) ? `Symbol(${(_a = v.description) != null ? _a : i})` : v
        );
      };

      /**
      * @vue/reactivity v3.5.22
      * (c) 2018-present Yuxi (Evan) You and Vue contributors
      * @license MIT
      **/
      let activeEffectScope;
      class EffectScope {
        constructor(detached = false) {
          this.detached = detached;
          this._active = true;
          this._on = 0;
          this.effects = [];
          this.cleanups = [];
          this._isPaused = false;
          this.parent = activeEffectScope;
          if (!detached && activeEffectScope) {
            this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
              this
            ) - 1;
          }
        }
        get active() {
          return this._active;
        }
        pause() {
          if (this._active) {
            this._isPaused = true;
            let i, l;
            if (this.scopes) {
              for (i = 0, l = this.scopes.length; i < l; i++) {
                this.scopes[i].pause();
              }
            }
            for (i = 0, l = this.effects.length; i < l; i++) {
              this.effects[i].pause();
            }
          }
        }
        /**
         * Resumes the effect scope, including all child scopes and effects.
         */
        resume() {
          if (this._active) {
            if (this._isPaused) {
              this._isPaused = false;
              let i, l;
              if (this.scopes) {
                for (i = 0, l = this.scopes.length; i < l; i++) {
                  this.scopes[i].resume();
                }
              }
              for (i = 0, l = this.effects.length; i < l; i++) {
                this.effects[i].resume();
              }
            }
          }
        }
        run(fn) {
          if (this._active) {
            const currentEffectScope = activeEffectScope;
            try {
              activeEffectScope = this;
              return fn();
            } finally {
              activeEffectScope = currentEffectScope;
            }
          }
        }
        /**
         * This should only be called on non-detached scopes
         * @internal
         */
        on() {
          if (++this._on === 1) {
            this.prevScope = activeEffectScope;
            activeEffectScope = this;
          }
        }
        /**
         * This should only be called on non-detached scopes
         * @internal
         */
        off() {
          if (this._on > 0 && --this._on === 0) {
            activeEffectScope = this.prevScope;
            this.prevScope = void 0;
          }
        }
        stop(fromParent) {
          if (this._active) {
            this._active = false;
            let i, l;
            for (i = 0, l = this.effects.length; i < l; i++) {
              this.effects[i].stop();
            }
            this.effects.length = 0;
            for (i = 0, l = this.cleanups.length; i < l; i++) {
              this.cleanups[i]();
            }
            this.cleanups.length = 0;
            if (this.scopes) {
              for (i = 0, l = this.scopes.length; i < l; i++) {
                this.scopes[i].stop(true);
              }
              this.scopes.length = 0;
            }
            if (!this.detached && this.parent && !fromParent) {
              const last = this.parent.scopes.pop();
              if (last && last !== this) {
                this.parent.scopes[this.index] = last;
                last.index = this.index;
              }
            }
            this.parent = void 0;
          }
        }
      }
      function getCurrentScope() {
        return activeEffectScope;
      }
      let activeSub;
      const pausedQueueEffects = /* @__PURE__ */ new WeakSet();
      class ReactiveEffect {
        constructor(fn) {
          this.fn = fn;
          this.deps = void 0;
          this.depsTail = void 0;
          this.flags = 1 | 4;
          this.next = void 0;
          this.cleanup = void 0;
          this.scheduler = void 0;
          if (activeEffectScope && activeEffectScope.active) {
            activeEffectScope.effects.push(this);
          }
        }
        pause() {
          this.flags |= 64;
        }
        resume() {
          if (this.flags & 64) {
            this.flags &= -65;
            if (pausedQueueEffects.has(this)) {
              pausedQueueEffects.delete(this);
              this.trigger();
            }
          }
        }
        /**
         * @internal
         */
        notify() {
          if (this.flags & 2 && !(this.flags & 32)) {
            return;
          }
          if (!(this.flags & 8)) {
            batch(this);
          }
        }
        run() {
          if (!(this.flags & 1)) {
            return this.fn();
          }
          this.flags |= 2;
          cleanupEffect(this);
          prepareDeps(this);
          const prevEffect = activeSub;
          const prevShouldTrack = shouldTrack;
          activeSub = this;
          shouldTrack = true;
          try {
            return this.fn();
          } finally {
            cleanupDeps(this);
            activeSub = prevEffect;
            shouldTrack = prevShouldTrack;
            this.flags &= -3;
          }
        }
        stop() {
          if (this.flags & 1) {
            for (let link = this.deps; link; link = link.nextDep) {
              removeSub(link);
            }
            this.deps = this.depsTail = void 0;
            cleanupEffect(this);
            this.onStop && this.onStop();
            this.flags &= -2;
          }
        }
        trigger() {
          if (this.flags & 64) {
            pausedQueueEffects.add(this);
          } else if (this.scheduler) {
            this.scheduler();
          } else {
            this.runIfDirty();
          }
        }
        /**
         * @internal
         */
        runIfDirty() {
          if (isDirty(this)) {
            this.run();
          }
        }
        get dirty() {
          return isDirty(this);
        }
      }
      let batchDepth = 0;
      let batchedSub;
      let batchedComputed;
      function batch(sub, isComputed = false) {
        sub.flags |= 8;
        if (isComputed) {
          sub.next = batchedComputed;
          batchedComputed = sub;
          return;
        }
        sub.next = batchedSub;
        batchedSub = sub;
      }
      function startBatch() {
        batchDepth++;
      }
      function endBatch() {
        if (--batchDepth > 0) {
          return;
        }
        if (batchedComputed) {
          let e = batchedComputed;
          batchedComputed = void 0;
          while (e) {
            const next = e.next;
            e.next = void 0;
            e.flags &= -9;
            e = next;
          }
        }
        let error;
        while (batchedSub) {
          let e = batchedSub;
          batchedSub = void 0;
          while (e) {
            const next = e.next;
            e.next = void 0;
            e.flags &= -9;
            if (e.flags & 1) {
              try {
                ;
                e.trigger();
              } catch (err) {
                if (!error) error = err;
              }
            }
            e = next;
          }
        }
        if (error) throw error;
      }
      function prepareDeps(sub) {
        for (let link = sub.deps; link; link = link.nextDep) {
          link.version = -1;
          link.prevActiveLink = link.dep.activeLink;
          link.dep.activeLink = link;
        }
      }
      function cleanupDeps(sub) {
        let head;
        let tail = sub.depsTail;
        let link = tail;
        while (link) {
          const prev = link.prevDep;
          if (link.version === -1) {
            if (link === tail) tail = prev;
            removeSub(link);
            removeDep(link);
          } else {
            head = link;
          }
          link.dep.activeLink = link.prevActiveLink;
          link.prevActiveLink = void 0;
          link = prev;
        }
        sub.deps = head;
        sub.depsTail = tail;
      }
      function isDirty(sub) {
        for (let link = sub.deps; link; link = link.nextDep) {
          if (link.dep.version !== link.version || link.dep.computed && (refreshComputed(link.dep.computed) || link.dep.version !== link.version)) {
            return true;
          }
        }
        if (sub._dirty) {
          return true;
        }
        return false;
      }
      function refreshComputed(computed2) {
        if (computed2.flags & 4 && !(computed2.flags & 16)) {
          return;
        }
        computed2.flags &= -17;
        if (computed2.globalVersion === globalVersion) {
          return;
        }
        computed2.globalVersion = globalVersion;
        if (!computed2.isSSR && computed2.flags & 128 && (!computed2.deps && !computed2._dirty || !isDirty(computed2))) {
          return;
        }
        computed2.flags |= 2;
        const dep = computed2.dep;
        const prevSub = activeSub;
        const prevShouldTrack = shouldTrack;
        activeSub = computed2;
        shouldTrack = true;
        try {
          prepareDeps(computed2);
          const value = computed2.fn(computed2._value);
          if (dep.version === 0 || hasChanged(value, computed2._value)) {
            computed2.flags |= 128;
            computed2._value = value;
            dep.version++;
          }
        } catch (err) {
          dep.version++;
          throw err;
        } finally {
          activeSub = prevSub;
          shouldTrack = prevShouldTrack;
          cleanupDeps(computed2);
          computed2.flags &= -3;
        }
      }
      function removeSub(link, soft = false) {
        const { dep, prevSub, nextSub } = link;
        if (prevSub) {
          prevSub.nextSub = nextSub;
          link.prevSub = void 0;
        }
        if (nextSub) {
          nextSub.prevSub = prevSub;
          link.nextSub = void 0;
        }
        if (dep.subs === link) {
          dep.subs = prevSub;
          if (!prevSub && dep.computed) {
            dep.computed.flags &= -5;
            for (let l = dep.computed.deps; l; l = l.nextDep) {
              removeSub(l, true);
            }
          }
        }
        if (!soft && !--dep.sc && dep.map) {
          dep.map.delete(dep.key);
        }
      }
      function removeDep(link) {
        const { prevDep, nextDep } = link;
        if (prevDep) {
          prevDep.nextDep = nextDep;
          link.prevDep = void 0;
        }
        if (nextDep) {
          nextDep.prevDep = prevDep;
          link.nextDep = void 0;
        }
      }
      let shouldTrack = true;
      const trackStack = [];
      function pauseTracking() {
        trackStack.push(shouldTrack);
        shouldTrack = false;
      }
      function resetTracking() {
        const last = trackStack.pop();
        shouldTrack = last === void 0 ? true : last;
      }
      function cleanupEffect(e) {
        const { cleanup } = e;
        e.cleanup = void 0;
        if (cleanup) {
          const prevSub = activeSub;
          activeSub = void 0;
          try {
            cleanup();
          } finally {
            activeSub = prevSub;
          }
        }
      }
      let globalVersion = 0;
      class Link {
        constructor(sub, dep) {
          this.sub = sub;
          this.dep = dep;
          this.version = dep.version;
          this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
        }
      }
      class Dep {
        // TODO isolatedDeclarations "__v_skip"
        constructor(computed2) {
          this.computed = computed2;
          this.version = 0;
          this.activeLink = void 0;
          this.subs = void 0;
          this.map = void 0;
          this.key = void 0;
          this.sc = 0;
          this.__v_skip = true;
        }
        track(debugInfo) {
          if (!activeSub || !shouldTrack || activeSub === this.computed) {
            return;
          }
          let link = this.activeLink;
          if (link === void 0 || link.sub !== activeSub) {
            link = this.activeLink = new Link(activeSub, this);
            if (!activeSub.deps) {
              activeSub.deps = activeSub.depsTail = link;
            } else {
              link.prevDep = activeSub.depsTail;
              activeSub.depsTail.nextDep = link;
              activeSub.depsTail = link;
            }
            addSub(link);
          } else if (link.version === -1) {
            link.version = this.version;
            if (link.nextDep) {
              const next = link.nextDep;
              next.prevDep = link.prevDep;
              if (link.prevDep) {
                link.prevDep.nextDep = next;
              }
              link.prevDep = activeSub.depsTail;
              link.nextDep = void 0;
              activeSub.depsTail.nextDep = link;
              activeSub.depsTail = link;
              if (activeSub.deps === link) {
                activeSub.deps = next;
              }
            }
          }
          return link;
        }
        trigger(debugInfo) {
          this.version++;
          globalVersion++;
          this.notify(debugInfo);
        }
        notify(debugInfo) {
          startBatch();
          try {
            if (false) ;
            for (let link = this.subs; link; link = link.prevSub) {
              if (link.sub.notify()) {
                ;
                link.sub.dep.notify();
              }
            }
          } finally {
            endBatch();
          }
        }
      }
      function addSub(link) {
        link.dep.sc++;
        if (link.sub.flags & 4) {
          const computed2 = link.dep.computed;
          if (computed2 && !link.dep.subs) {
            computed2.flags |= 4 | 16;
            for (let l = computed2.deps; l; l = l.nextDep) {
              addSub(l);
            }
          }
          const currentTail = link.dep.subs;
          if (currentTail !== link) {
            link.prevSub = currentTail;
            if (currentTail) currentTail.nextSub = link;
          }
          link.dep.subs = link;
        }
      }
      const targetMap = /* @__PURE__ */ new WeakMap();
      const ITERATE_KEY = Symbol(
        ""
      );
      const MAP_KEY_ITERATE_KEY = Symbol(
        ""
      );
      const ARRAY_ITERATE_KEY = Symbol(
        ""
      );
      function track(target, type, key) {
        if (shouldTrack && activeSub) {
          let depsMap = targetMap.get(target);
          if (!depsMap) {
            targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
          }
          let dep = depsMap.get(key);
          if (!dep) {
            depsMap.set(key, dep = new Dep());
            dep.map = depsMap;
            dep.key = key;
          }
          {
            dep.track();
          }
        }
      }
      function trigger(target, type, key, newValue, oldValue, oldTarget) {
        const depsMap = targetMap.get(target);
        if (!depsMap) {
          globalVersion++;
          return;
        }
        const run = (dep) => {
          if (dep) {
            {
              dep.trigger();
            }
          }
        };
        startBatch();
        if (type === "clear") {
          depsMap.forEach(run);
        } else {
          const targetIsArray = isArray(target);
          const isArrayIndex = targetIsArray && isIntegerKey(key);
          if (targetIsArray && key === "length") {
            const newLength = Number(newValue);
            depsMap.forEach((dep, key2) => {
              if (key2 === "length" || key2 === ARRAY_ITERATE_KEY || !isSymbol(key2) && key2 >= newLength) {
                run(dep);
              }
            });
          } else {
            if (key !== void 0 || depsMap.has(void 0)) {
              run(depsMap.get(key));
            }
            if (isArrayIndex) {
              run(depsMap.get(ARRAY_ITERATE_KEY));
            }
            switch (type) {
              case "add":
                if (!targetIsArray) {
                  run(depsMap.get(ITERATE_KEY));
                  if (isMap(target)) {
                    run(depsMap.get(MAP_KEY_ITERATE_KEY));
                  }
                } else if (isArrayIndex) {
                  run(depsMap.get("length"));
                }
                break;
              case "delete":
                if (!targetIsArray) {
                  run(depsMap.get(ITERATE_KEY));
                  if (isMap(target)) {
                    run(depsMap.get(MAP_KEY_ITERATE_KEY));
                  }
                }
                break;
              case "set":
                if (isMap(target)) {
                  run(depsMap.get(ITERATE_KEY));
                }
                break;
            }
          }
        }
        endBatch();
      }
      function reactiveReadArray(array) {
        const raw = toRaw(array);
        if (raw === array) return raw;
        track(raw, "iterate", ARRAY_ITERATE_KEY);
        return isShallow(array) ? raw : raw.map(toReactive);
      }
      function shallowReadArray(arr) {
        track(arr = toRaw(arr), "iterate", ARRAY_ITERATE_KEY);
        return arr;
      }
      const arrayInstrumentations = {
        __proto__: null,
        [Symbol.iterator]() {
          return iterator(this, Symbol.iterator, toReactive);
        },
        concat(...args) {
          return reactiveReadArray(this).concat(
            ...args.map((x) => isArray(x) ? reactiveReadArray(x) : x)
          );
        },
        entries() {
          return iterator(this, "entries", (value) => {
            value[1] = toReactive(value[1]);
            return value;
          });
        },
        every(fn, thisArg) {
          return apply(this, "every", fn, thisArg, void 0, arguments);
        },
        filter(fn, thisArg) {
          return apply(this, "filter", fn, thisArg, (v) => v.map(toReactive), arguments);
        },
        find(fn, thisArg) {
          return apply(this, "find", fn, thisArg, toReactive, arguments);
        },
        findIndex(fn, thisArg) {
          return apply(this, "findIndex", fn, thisArg, void 0, arguments);
        },
        findLast(fn, thisArg) {
          return apply(this, "findLast", fn, thisArg, toReactive, arguments);
        },
        findLastIndex(fn, thisArg) {
          return apply(this, "findLastIndex", fn, thisArg, void 0, arguments);
        },
        // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
        forEach(fn, thisArg) {
          return apply(this, "forEach", fn, thisArg, void 0, arguments);
        },
        includes(...args) {
          return searchProxy(this, "includes", args);
        },
        indexOf(...args) {
          return searchProxy(this, "indexOf", args);
        },
        join(separator) {
          return reactiveReadArray(this).join(separator);
        },
        // keys() iterator only reads `length`, no optimization required
        lastIndexOf(...args) {
          return searchProxy(this, "lastIndexOf", args);
        },
        map(fn, thisArg) {
          return apply(this, "map", fn, thisArg, void 0, arguments);
        },
        pop() {
          return noTracking(this, "pop");
        },
        push(...args) {
          return noTracking(this, "push", args);
        },
        reduce(fn, ...args) {
          return reduce(this, "reduce", fn, args);
        },
        reduceRight(fn, ...args) {
          return reduce(this, "reduceRight", fn, args);
        },
        shift() {
          return noTracking(this, "shift");
        },
        // slice could use ARRAY_ITERATE but also seems to beg for range tracking
        some(fn, thisArg) {
          return apply(this, "some", fn, thisArg, void 0, arguments);
        },
        splice(...args) {
          return noTracking(this, "splice", args);
        },
        toReversed() {
          return reactiveReadArray(this).toReversed();
        },
        toSorted(comparer) {
          return reactiveReadArray(this).toSorted(comparer);
        },
        toSpliced(...args) {
          return reactiveReadArray(this).toSpliced(...args);
        },
        unshift(...args) {
          return noTracking(this, "unshift", args);
        },
        values() {
          return iterator(this, "values", toReactive);
        }
      };
      function iterator(self, method, wrapValue) {
        const arr = shallowReadArray(self);
        const iter = arr[method]();
        if (arr !== self && !isShallow(self)) {
          iter._next = iter.next;
          iter.next = () => {
            const result = iter._next();
            if (!result.done) {
              result.value = wrapValue(result.value);
            }
            return result;
          };
        }
        return iter;
      }
      const arrayProto = Array.prototype;
      function apply(self, method, fn, thisArg, wrappedRetFn, args) {
        const arr = shallowReadArray(self);
        const needsWrap = arr !== self && !isShallow(self);
        const methodFn = arr[method];
        if (methodFn !== arrayProto[method]) {
          const result2 = methodFn.apply(self, args);
          return needsWrap ? toReactive(result2) : result2;
        }
        let wrappedFn = fn;
        if (arr !== self) {
          if (needsWrap) {
            wrappedFn = function(item, index) {
              return fn.call(this, toReactive(item), index, self);
            };
          } else if (fn.length > 2) {
            wrappedFn = function(item, index) {
              return fn.call(this, item, index, self);
            };
          }
        }
        const result = methodFn.call(arr, wrappedFn, thisArg);
        return needsWrap && wrappedRetFn ? wrappedRetFn(result) : result;
      }
      function reduce(self, method, fn, args) {
        const arr = shallowReadArray(self);
        let wrappedFn = fn;
        if (arr !== self) {
          if (!isShallow(self)) {
            wrappedFn = function(acc, item, index) {
              return fn.call(this, acc, toReactive(item), index, self);
            };
          } else if (fn.length > 3) {
            wrappedFn = function(acc, item, index) {
              return fn.call(this, acc, item, index, self);
            };
          }
        }
        return arr[method](wrappedFn, ...args);
      }
      function searchProxy(self, method, args) {
        const arr = toRaw(self);
        track(arr, "iterate", ARRAY_ITERATE_KEY);
        const res = arr[method](...args);
        if ((res === -1 || res === false) && isProxy(args[0])) {
          args[0] = toRaw(args[0]);
          return arr[method](...args);
        }
        return res;
      }
      function noTracking(self, method, args = []) {
        pauseTracking();
        startBatch();
        const res = toRaw(self)[method].apply(self, args);
        endBatch();
        resetTracking();
        return res;
      }
      const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
      const builtInSymbols = new Set(
        /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol)
      );
      function hasOwnProperty(key) {
        if (!isSymbol(key)) key = String(key);
        const obj = toRaw(this);
        track(obj, "has", key);
        return obj.hasOwnProperty(key);
      }
      class BaseReactiveHandler {
        constructor(_isReadonly = false, _isShallow = false) {
          this._isReadonly = _isReadonly;
          this._isShallow = _isShallow;
        }
        get(target, key, receiver) {
          if (key === "__v_skip") return target["__v_skip"];
          const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;
          if (key === "__v_isReactive") {
            return !isReadonly2;
          } else if (key === "__v_isReadonly") {
            return isReadonly2;
          } else if (key === "__v_isShallow") {
            return isShallow2;
          } else if (key === "__v_raw") {
            if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype
            // this means the receiver is a user proxy of the reactive proxy
            Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
              return target;
            }
            return;
          }
          const targetIsArray = isArray(target);
          if (!isReadonly2) {
            let fn;
            if (targetIsArray && (fn = arrayInstrumentations[key])) {
              return fn;
            }
            if (key === "hasOwnProperty") {
              return hasOwnProperty;
            }
          }
          const res = Reflect.get(
            target,
            key,
            // if this is a proxy wrapping a ref, return methods using the raw ref
            // as receiver so that we don't have to call `toRaw` on the ref in all
            // its class methods
            isRef(target) ? target : receiver
          );
          if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
            return res;
          }
          if (!isReadonly2) {
            track(target, "get", key);
          }
          if (isShallow2) {
            return res;
          }
          if (isRef(res)) {
            const value = targetIsArray && isIntegerKey(key) ? res : res.value;
            return isReadonly2 && isObject(value) ? readonly(value) : value;
          }
          if (isObject(res)) {
            return isReadonly2 ? readonly(res) : reactive(res);
          }
          return res;
        }
      }
      class MutableReactiveHandler extends BaseReactiveHandler {
        constructor(isShallow2 = false) {
          super(false, isShallow2);
        }
        set(target, key, value, receiver) {
          let oldValue = target[key];
          if (!this._isShallow) {
            const isOldValueReadonly = isReadonly(oldValue);
            if (!isShallow(value) && !isReadonly(value)) {
              oldValue = toRaw(oldValue);
              value = toRaw(value);
            }
            if (!isArray(target) && isRef(oldValue) && !isRef(value)) {
              if (isOldValueReadonly) {
                return true;
              } else {
                oldValue.value = value;
                return true;
              }
            }
          }
          const hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
          const result = Reflect.set(
            target,
            key,
            value,
            isRef(target) ? target : receiver
          );
          if (target === toRaw(receiver)) {
            if (!hadKey) {
              trigger(target, "add", key, value);
            } else if (hasChanged(value, oldValue)) {
              trigger(target, "set", key, value);
            }
          }
          return result;
        }
        deleteProperty(target, key) {
          const hadKey = hasOwn(target, key);
          target[key];
          const result = Reflect.deleteProperty(target, key);
          if (result && hadKey) {
            trigger(target, "delete", key, void 0);
          }
          return result;
        }
        has(target, key) {
          const result = Reflect.has(target, key);
          if (!isSymbol(key) || !builtInSymbols.has(key)) {
            track(target, "has", key);
          }
          return result;
        }
        ownKeys(target) {
          track(
            target,
            "iterate",
            isArray(target) ? "length" : ITERATE_KEY
          );
          return Reflect.ownKeys(target);
        }
      }
      class ReadonlyReactiveHandler extends BaseReactiveHandler {
        constructor(isShallow2 = false) {
          super(true, isShallow2);
        }
        set(target, key) {
          return true;
        }
        deleteProperty(target, key) {
          return true;
        }
      }
      const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
      const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
      const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(true);
      const shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);
      const toShallow = (value) => value;
      const getProto = (v) => Reflect.getPrototypeOf(v);
      function createIterableMethod(method, isReadonly2, isShallow2) {
        return function(...args) {
          const target = this["__v_raw"];
          const rawTarget = toRaw(target);
          const targetIsMap = isMap(rawTarget);
          const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
          const isKeyOnly = method === "keys" && targetIsMap;
          const innerIterator = target[method](...args);
          const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
          !isReadonly2 && track(
            rawTarget,
            "iterate",
            isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
          );
          return {
            // iterator protocol
            next() {
              const { value, done } = innerIterator.next();
              return done ? { value, done } : {
                value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
                done
              };
            },
            // iterable protocol
            [Symbol.iterator]() {
              return this;
            }
          };
        };
      }
      function createReadonlyMethod(type) {
        return function(...args) {
          return type === "delete" ? false : type === "clear" ? void 0 : this;
        };
      }
      function createInstrumentations(readonly2, shallow) {
        const instrumentations = {
          get(key) {
            const target = this["__v_raw"];
            const rawTarget = toRaw(target);
            const rawKey = toRaw(key);
            if (!readonly2) {
              if (hasChanged(key, rawKey)) {
                track(rawTarget, "get", key);
              }
              track(rawTarget, "get", rawKey);
            }
            const { has } = getProto(rawTarget);
            const wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive;
            if (has.call(rawTarget, key)) {
              return wrap(target.get(key));
            } else if (has.call(rawTarget, rawKey)) {
              return wrap(target.get(rawKey));
            } else if (target !== rawTarget) {
              target.get(key);
            }
          },
          get size() {
            const target = this["__v_raw"];
            !readonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
            return target.size;
          },
          has(key) {
            const target = this["__v_raw"];
            const rawTarget = toRaw(target);
            const rawKey = toRaw(key);
            if (!readonly2) {
              if (hasChanged(key, rawKey)) {
                track(rawTarget, "has", key);
              }
              track(rawTarget, "has", rawKey);
            }
            return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
          },
          forEach(callback, thisArg) {
            const observed = this;
            const target = observed["__v_raw"];
            const rawTarget = toRaw(target);
            const wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive;
            !readonly2 && track(rawTarget, "iterate", ITERATE_KEY);
            return target.forEach((value, key) => {
              return callback.call(thisArg, wrap(value), wrap(key), observed);
            });
          }
        };
        extend(
          instrumentations,
          readonly2 ? {
            add: createReadonlyMethod("add"),
            set: createReadonlyMethod("set"),
            delete: createReadonlyMethod("delete"),
            clear: createReadonlyMethod("clear")
          } : {
            add(value) {
              if (!shallow && !isShallow(value) && !isReadonly(value)) {
                value = toRaw(value);
              }
              const target = toRaw(this);
              const proto = getProto(target);
              const hadKey = proto.has.call(target, value);
              if (!hadKey) {
                target.add(value);
                trigger(target, "add", value, value);
              }
              return this;
            },
            set(key, value) {
              if (!shallow && !isShallow(value) && !isReadonly(value)) {
                value = toRaw(value);
              }
              const target = toRaw(this);
              const { has, get } = getProto(target);
              let hadKey = has.call(target, key);
              if (!hadKey) {
                key = toRaw(key);
                hadKey = has.call(target, key);
              }
              const oldValue = get.call(target, key);
              target.set(key, value);
              if (!hadKey) {
                trigger(target, "add", key, value);
              } else if (hasChanged(value, oldValue)) {
                trigger(target, "set", key, value);
              }
              return this;
            },
            delete(key) {
              const target = toRaw(this);
              const { has, get } = getProto(target);
              let hadKey = has.call(target, key);
              if (!hadKey) {
                key = toRaw(key);
                hadKey = has.call(target, key);
              }
              get ? get.call(target, key) : void 0;
              const result = target.delete(key);
              if (hadKey) {
                trigger(target, "delete", key, void 0);
              }
              return result;
            },
            clear() {
              const target = toRaw(this);
              const hadItems = target.size !== 0;
              const result = target.clear();
              if (hadItems) {
                trigger(
                  target,
                  "clear",
                  void 0,
                  void 0);
              }
              return result;
            }
          }
        );
        const iteratorMethods = [
          "keys",
          "values",
          "entries",
          Symbol.iterator
        ];
        iteratorMethods.forEach((method) => {
          instrumentations[method] = createIterableMethod(method, readonly2, shallow);
        });
        return instrumentations;
      }
      function createInstrumentationGetter(isReadonly2, shallow) {
        const instrumentations = createInstrumentations(isReadonly2, shallow);
        return (target, key, receiver) => {
          if (key === "__v_isReactive") {
            return !isReadonly2;
          } else if (key === "__v_isReadonly") {
            return isReadonly2;
          } else if (key === "__v_raw") {
            return target;
          }
          return Reflect.get(
            hasOwn(instrumentations, key) && key in target ? instrumentations : target,
            key,
            receiver
          );
        };
      }
      const mutableCollectionHandlers = {
        get: /* @__PURE__ */ createInstrumentationGetter(false, false)
      };
      const shallowCollectionHandlers = {
        get: /* @__PURE__ */ createInstrumentationGetter(false, true)
      };
      const readonlyCollectionHandlers = {
        get: /* @__PURE__ */ createInstrumentationGetter(true, false)
      };
      const shallowReadonlyCollectionHandlers = {
        get: /* @__PURE__ */ createInstrumentationGetter(true, true)
      };
      const reactiveMap = /* @__PURE__ */ new WeakMap();
      const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
      const readonlyMap = /* @__PURE__ */ new WeakMap();
      const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
      function targetTypeMap(rawType) {
        switch (rawType) {
          case "Object":
          case "Array":
            return 1;
          case "Map":
          case "Set":
          case "WeakMap":
          case "WeakSet":
            return 2;
          default:
            return 0;
        }
      }
      function getTargetType(value) {
        return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
      }
      function reactive(target) {
        if (isReadonly(target)) {
          return target;
        }
        return createReactiveObject(
          target,
          false,
          mutableHandlers,
          mutableCollectionHandlers,
          reactiveMap
        );
      }
      function shallowReactive(target) {
        return createReactiveObject(
          target,
          false,
          shallowReactiveHandlers,
          shallowCollectionHandlers,
          shallowReactiveMap
        );
      }
      function readonly(target) {
        return createReactiveObject(
          target,
          true,
          readonlyHandlers,
          readonlyCollectionHandlers,
          readonlyMap
        );
      }
      function shallowReadonly(target) {
        return createReactiveObject(
          target,
          true,
          shallowReadonlyHandlers,
          shallowReadonlyCollectionHandlers,
          shallowReadonlyMap
        );
      }
      function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
        if (!isObject(target)) {
          return target;
        }
        if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
          return target;
        }
        const targetType = getTargetType(target);
        if (targetType === 0) {
          return target;
        }
        const existingProxy = proxyMap.get(target);
        if (existingProxy) {
          return existingProxy;
        }
        const proxy = new Proxy(
          target,
          targetType === 2 ? collectionHandlers : baseHandlers
        );
        proxyMap.set(target, proxy);
        return proxy;
      }
      function isReactive(value) {
        if (isReadonly(value)) {
          return isReactive(value["__v_raw"]);
        }
        return !!(value && value["__v_isReactive"]);
      }
      function isReadonly(value) {
        return !!(value && value["__v_isReadonly"]);
      }
      function isShallow(value) {
        return !!(value && value["__v_isShallow"]);
      }
      function isProxy(value) {
        return value ? !!value["__v_raw"] : false;
      }
      function toRaw(observed) {
        const raw = observed && observed["__v_raw"];
        return raw ? toRaw(raw) : observed;
      }
      function markRaw(value) {
        if (!hasOwn(value, "__v_skip") && Object.isExtensible(value)) {
          def(value, "__v_skip", true);
        }
        return value;
      }
      const toReactive = (value) => isObject(value) ? reactive(value) : value;
      const toReadonly = (value) => isObject(value) ? readonly(value) : value;
      function isRef(r) {
        return r ? r["__v_isRef"] === true : false;
      }
      function ref(value) {
        return createRef(value, false);
      }
      function createRef(rawValue, shallow) {
        if (isRef(rawValue)) {
          return rawValue;
        }
        return new RefImpl(rawValue, shallow);
      }
      class RefImpl {
        constructor(value, isShallow2) {
          this.dep = new Dep();
          this["__v_isRef"] = true;
          this["__v_isShallow"] = false;
          this._rawValue = isShallow2 ? value : toRaw(value);
          this._value = isShallow2 ? value : toReactive(value);
          this["__v_isShallow"] = isShallow2;
        }
        get value() {
          {
            this.dep.track();
          }
          return this._value;
        }
        set value(newValue) {
          const oldValue = this._rawValue;
          const useDirectValue = this["__v_isShallow"] || isShallow(newValue) || isReadonly(newValue);
          newValue = useDirectValue ? newValue : toRaw(newValue);
          if (hasChanged(newValue, oldValue)) {
            this._rawValue = newValue;
            this._value = useDirectValue ? newValue : toReactive(newValue);
            {
              this.dep.trigger();
            }
          }
        }
      }
      function unref(ref2) {
        return isRef(ref2) ? ref2.value : ref2;
      }
      const shallowUnwrapHandlers = {
        get: (target, key, receiver) => key === "__v_raw" ? target : unref(Reflect.get(target, key, receiver)),
        set: (target, key, value, receiver) => {
          const oldValue = target[key];
          if (isRef(oldValue) && !isRef(value)) {
            oldValue.value = value;
            return true;
          } else {
            return Reflect.set(target, key, value, receiver);
          }
        }
      };
      function proxyRefs(objectWithRefs) {
        return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
      }
      class ComputedRefImpl {
        constructor(fn, setter, isSSR) {
          this.fn = fn;
          this.setter = setter;
          this._value = void 0;
          this.dep = new Dep(this);
          this.__v_isRef = true;
          this.deps = void 0;
          this.depsTail = void 0;
          this.flags = 16;
          this.globalVersion = globalVersion - 1;
          this.next = void 0;
          this.effect = this;
          this["__v_isReadonly"] = !setter;
          this.isSSR = isSSR;
        }
        /**
         * @internal
         */
        notify() {
          this.flags |= 16;
          if (!(this.flags & 8) && // avoid infinite self recursion
          activeSub !== this) {
            batch(this, true);
            return true;
          }
        }
        get value() {
          const link = this.dep.track();
          refreshComputed(this);
          if (link) {
            link.version = this.dep.version;
          }
          return this._value;
        }
        set value(newValue) {
          if (this.setter) {
            this.setter(newValue);
          }
        }
      }
      function computed$1(getterOrOptions, debugOptions, isSSR = false) {
        let getter;
        let setter;
        if (isFunction(getterOrOptions)) {
          getter = getterOrOptions;
        } else {
          getter = getterOrOptions.get;
          setter = getterOrOptions.set;
        }
        const cRef = new ComputedRefImpl(getter, setter, isSSR);
        return cRef;
      }
      const INITIAL_WATCHER_VALUE = {};
      const cleanupMap = /* @__PURE__ */ new WeakMap();
      let activeWatcher = void 0;
      function onWatcherCleanup(cleanupFn, failSilently = false, owner = activeWatcher) {
        if (owner) {
          let cleanups = cleanupMap.get(owner);
          if (!cleanups) cleanupMap.set(owner, cleanups = []);
          cleanups.push(cleanupFn);
        }
      }
      function watch$1(source, cb, options = EMPTY_OBJ) {
        const { immediate, deep, once, scheduler, augmentJob, call } = options;
        const reactiveGetter = (source2) => {
          if (deep) return source2;
          if (isShallow(source2) || deep === false || deep === 0)
            return traverse(source2, 1);
          return traverse(source2);
        };
        let effect2;
        let getter;
        let cleanup;
        let boundCleanup;
        let forceTrigger = false;
        let isMultiSource = false;
        if (isRef(source)) {
          getter = () => source.value;
          forceTrigger = isShallow(source);
        } else if (isReactive(source)) {
          getter = () => reactiveGetter(source);
          forceTrigger = true;
        } else if (isArray(source)) {
          isMultiSource = true;
          forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
          getter = () => source.map((s) => {
            if (isRef(s)) {
              return s.value;
            } else if (isReactive(s)) {
              return reactiveGetter(s);
            } else if (isFunction(s)) {
              return call ? call(s, 2) : s();
            } else ;
          });
        } else if (isFunction(source)) {
          if (cb) {
            getter = call ? () => call(source, 2) : source;
          } else {
            getter = () => {
              if (cleanup) {
                pauseTracking();
                try {
                  cleanup();
                } finally {
                  resetTracking();
                }
              }
              const currentEffect = activeWatcher;
              activeWatcher = effect2;
              try {
                return call ? call(source, 3, [boundCleanup]) : source(boundCleanup);
              } finally {
                activeWatcher = currentEffect;
              }
            };
          }
        } else {
          getter = NOOP;
        }
        if (cb && deep) {
          const baseGetter = getter;
          const depth = deep === true ? Infinity : deep;
          getter = () => traverse(baseGetter(), depth);
        }
        const scope = getCurrentScope();
        const watchHandle = () => {
          effect2.stop();
          if (scope && scope.active) {
            remove(scope.effects, effect2);
          }
        };
        if (once && cb) {
          const _cb = cb;
          cb = (...args) => {
            _cb(...args);
            watchHandle();
          };
        }
        let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
        const job = (immediateFirstRun) => {
          if (!(effect2.flags & 1) || !effect2.dirty && !immediateFirstRun) {
            return;
          }
          if (cb) {
            const newValue = effect2.run();
            if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue))) {
              if (cleanup) {
                cleanup();
              }
              const currentWatcher = activeWatcher;
              activeWatcher = effect2;
              try {
                const args = [
                  newValue,
                  // pass undefined as the old value when it's changed for the first time
                  oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
                  boundCleanup
                ];
                oldValue = newValue;
                call ? call(cb, 3, args) : (
                  // @ts-expect-error
                  cb(...args)
                );
              } finally {
                activeWatcher = currentWatcher;
              }
            }
          } else {
            effect2.run();
          }
        };
        if (augmentJob) {
          augmentJob(job);
        }
        effect2 = new ReactiveEffect(getter);
        effect2.scheduler = scheduler ? () => scheduler(job, false) : job;
        boundCleanup = (fn) => onWatcherCleanup(fn, false, effect2);
        cleanup = effect2.onStop = () => {
          const cleanups = cleanupMap.get(effect2);
          if (cleanups) {
            if (call) {
              call(cleanups, 4);
            } else {
              for (const cleanup2 of cleanups) cleanup2();
            }
            cleanupMap.delete(effect2);
          }
        };
        if (cb) {
          if (immediate) {
            job(true);
          } else {
            oldValue = effect2.run();
          }
        } else if (scheduler) {
          scheduler(job.bind(null, true), true);
        } else {
          effect2.run();
        }
        watchHandle.pause = effect2.pause.bind(effect2);
        watchHandle.resume = effect2.resume.bind(effect2);
        watchHandle.stop = watchHandle;
        return watchHandle;
      }
      function traverse(value, depth = Infinity, seen) {
        if (depth <= 0 || !isObject(value) || value["__v_skip"]) {
          return value;
        }
        seen = seen || /* @__PURE__ */ new Map();
        if ((seen.get(value) || 0) >= depth) {
          return value;
        }
        seen.set(value, depth);
        depth--;
        if (isRef(value)) {
          traverse(value.value, depth, seen);
        } else if (isArray(value)) {
          for (let i = 0; i < value.length; i++) {
            traverse(value[i], depth, seen);
          }
        } else if (isSet(value) || isMap(value)) {
          value.forEach((v) => {
            traverse(v, depth, seen);
          });
        } else if (isPlainObject(value)) {
          for (const key in value) {
            traverse(value[key], depth, seen);
          }
          for (const key of Object.getOwnPropertySymbols(value)) {
            if (Object.prototype.propertyIsEnumerable.call(value, key)) {
              traverse(value[key], depth, seen);
            }
          }
        }
        return value;
      }

      /**
      * @vue/runtime-core v3.5.22
      * (c) 2018-present Yuxi (Evan) You and Vue contributors
      * @license MIT
      **/
      const stack = [];
      let isWarning = false;
      function warn$1(msg, ...args) {
        if (isWarning) return;
        isWarning = true;
        pauseTracking();
        const instance = stack.length ? stack[stack.length - 1].component : null;
        const appWarnHandler = instance && instance.appContext.config.warnHandler;
        const trace = getComponentTrace();
        if (appWarnHandler) {
          callWithErrorHandling(
            appWarnHandler,
            instance,
            11,
            [
              // eslint-disable-next-line no-restricted-syntax
              msg + args.map((a) => {
                var _a, _b;
                return (_b = (_a = a.toString) == null ? void 0 : _a.call(a)) != null ? _b : JSON.stringify(a);
              }).join(""),
              instance && instance.proxy,
              trace.map(
                ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`
              ).join("\n"),
              trace
            ]
          );
        } else {
          const warnArgs = [`[Vue warn]: ${msg}`, ...args];
          if (trace.length && // avoid spamming console during tests
          true) {
            warnArgs.push(`
`, ...formatTrace(trace));
          }
          console.warn(...warnArgs);
        }
        resetTracking();
        isWarning = false;
      }
      function getComponentTrace() {
        let currentVNode = stack[stack.length - 1];
        if (!currentVNode) {
          return [];
        }
        const normalizedStack = [];
        while (currentVNode) {
          const last = normalizedStack[0];
          if (last && last.vnode === currentVNode) {
            last.recurseCount++;
          } else {
            normalizedStack.push({
              vnode: currentVNode,
              recurseCount: 0
            });
          }
          const parentInstance = currentVNode.component && currentVNode.component.parent;
          currentVNode = parentInstance && parentInstance.vnode;
        }
        return normalizedStack;
      }
      function formatTrace(trace) {
        const logs = [];
        trace.forEach((entry, i) => {
          logs.push(...i === 0 ? [] : [`
`], ...formatTraceEntry(entry));
        });
        return logs;
      }
      function formatTraceEntry({ vnode, recurseCount }) {
        const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
        const isRoot = vnode.component ? vnode.component.parent == null : false;
        const open = ` at <${formatComponentName(
    vnode.component,
    vnode.type,
    isRoot
  )}`;
        const close = `>` + postfix;
        return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
      }
      function formatProps(props) {
        const res = [];
        const keys = Object.keys(props);
        keys.slice(0, 3).forEach((key) => {
          res.push(...formatProp(key, props[key]));
        });
        if (keys.length > 3) {
          res.push(` ...`);
        }
        return res;
      }
      function formatProp(key, value, raw) {
        if (isString(value)) {
          value = JSON.stringify(value);
          return raw ? value : [`${key}=${value}`];
        } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
          return raw ? value : [`${key}=${value}`];
        } else if (isRef(value)) {
          value = formatProp(key, toRaw(value.value), true);
          return raw ? value : [`${key}=Ref<`, value, `>`];
        } else if (isFunction(value)) {
          return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
        } else {
          value = toRaw(value);
          return raw ? value : [`${key}=`, value];
        }
      }
      function callWithErrorHandling(fn, instance, type, args) {
        try {
          return args ? fn(...args) : fn();
        } catch (err) {
          handleError(err, instance, type);
        }
      }
      function callWithAsyncErrorHandling(fn, instance, type, args) {
        if (isFunction(fn)) {
          const res = callWithErrorHandling(fn, instance, type, args);
          if (res && isPromise(res)) {
            res.catch((err) => {
              handleError(err, instance, type);
            });
          }
          return res;
        }
        if (isArray(fn)) {
          const values = [];
          for (let i = 0; i < fn.length; i++) {
            values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
          }
          return values;
        }
      }
      function handleError(err, instance, type, throwInDev = true) {
        const contextVNode = instance ? instance.vnode : null;
        const { errorHandler, throwUnhandledErrorInProduction } = instance && instance.appContext.config || EMPTY_OBJ;
        if (instance) {
          let cur = instance.parent;
          const exposedInstance = instance.proxy;
          const errorInfo = `https://vuejs.org/error-reference/#runtime-${type}`;
          while (cur) {
            const errorCapturedHooks = cur.ec;
            if (errorCapturedHooks) {
              for (let i = 0; i < errorCapturedHooks.length; i++) {
                if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
                  return;
                }
              }
            }
            cur = cur.parent;
          }
          if (errorHandler) {
            pauseTracking();
            callWithErrorHandling(errorHandler, null, 10, [
              err,
              exposedInstance,
              errorInfo
            ]);
            resetTracking();
            return;
          }
        }
        logError(err, type, contextVNode, throwInDev, throwUnhandledErrorInProduction);
      }
      function logError(err, type, contextVNode, throwInDev = true, throwInProd = false) {
        if (throwInProd) {
          throw err;
        } else {
          console.error(err);
        }
      }
      const queue = [];
      let flushIndex = -1;
      const pendingPostFlushCbs = [];
      let activePostFlushCbs = null;
      let postFlushIndex = 0;
      const resolvedPromise = /* @__PURE__ */ Promise.resolve();
      let currentFlushPromise = null;
      function nextTick(fn) {
        const p = currentFlushPromise || resolvedPromise;
        return fn ? p.then(this ? fn.bind(this) : fn) : p;
      }
      function findInsertionIndex(id) {
        let start = flushIndex + 1;
        let end = queue.length;
        while (start < end) {
          const middle = start + end >>> 1;
          const middleJob = queue[middle];
          const middleJobId = getId(middleJob);
          if (middleJobId < id || middleJobId === id && middleJob.flags & 2) {
            start = middle + 1;
          } else {
            end = middle;
          }
        }
        return start;
      }
      function queueJob(job) {
        if (!(job.flags & 1)) {
          const jobId = getId(job);
          const lastJob = queue[queue.length - 1];
          if (!lastJob || // fast path when the job id is larger than the tail
          !(job.flags & 2) && jobId >= getId(lastJob)) {
            queue.push(job);
          } else {
            queue.splice(findInsertionIndex(jobId), 0, job);
          }
          job.flags |= 1;
          queueFlush();
        }
      }
      function queueFlush() {
        if (!currentFlushPromise) {
          currentFlushPromise = resolvedPromise.then(flushJobs);
        }
      }
      function queuePostFlushCb(cb) {
        if (!isArray(cb)) {
          if (activePostFlushCbs && cb.id === -1) {
            activePostFlushCbs.splice(postFlushIndex + 1, 0, cb);
          } else if (!(cb.flags & 1)) {
            pendingPostFlushCbs.push(cb);
            cb.flags |= 1;
          }
        } else {
          pendingPostFlushCbs.push(...cb);
        }
        queueFlush();
      }
      function flushPreFlushCbs(instance, seen, i = flushIndex + 1) {
        for (; i < queue.length; i++) {
          const cb = queue[i];
          if (cb && cb.flags & 2) {
            if (instance && cb.id !== instance.uid) {
              continue;
            }
            queue.splice(i, 1);
            i--;
            if (cb.flags & 4) {
              cb.flags &= -2;
            }
            cb();
            if (!(cb.flags & 4)) {
              cb.flags &= -2;
            }
          }
        }
      }
      function flushPostFlushCbs(seen) {
        if (pendingPostFlushCbs.length) {
          const deduped = [...new Set(pendingPostFlushCbs)].sort(
            (a, b) => getId(a) - getId(b)
          );
          pendingPostFlushCbs.length = 0;
          if (activePostFlushCbs) {
            activePostFlushCbs.push(...deduped);
            return;
          }
          activePostFlushCbs = deduped;
          for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
            const cb = activePostFlushCbs[postFlushIndex];
            if (cb.flags & 4) {
              cb.flags &= -2;
            }
            if (!(cb.flags & 8)) cb();
            cb.flags &= -2;
          }
          activePostFlushCbs = null;
          postFlushIndex = 0;
        }
      }
      const getId = (job) => job.id == null ? job.flags & 2 ? -1 : Infinity : job.id;
      function flushJobs(seen) {
        try {
          for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
            const job = queue[flushIndex];
            if (job && !(job.flags & 8)) {
              if (false) ;
              if (job.flags & 4) {
                job.flags &= ~1;
              }
              callWithErrorHandling(
                job,
                job.i,
                job.i ? 15 : 14
              );
              if (!(job.flags & 4)) {
                job.flags &= ~1;
              }
            }
          }
        } finally {
          for (; flushIndex < queue.length; flushIndex++) {
            const job = queue[flushIndex];
            if (job) {
              job.flags &= -2;
            }
          }
          flushIndex = -1;
          queue.length = 0;
          flushPostFlushCbs();
          currentFlushPromise = null;
          if (queue.length || pendingPostFlushCbs.length) {
            flushJobs();
          }
        }
      }
      let currentRenderingInstance = null;
      let currentScopeId = null;
      function setCurrentRenderingInstance(instance) {
        const prev = currentRenderingInstance;
        currentRenderingInstance = instance;
        currentScopeId = instance && instance.type.__scopeId || null;
        return prev;
      }
      function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
        if (!ctx) return fn;
        if (fn._n) {
          return fn;
        }
        const renderFnWithContext = (...args) => {
          if (renderFnWithContext._d) {
            setBlockTracking(-1);
          }
          const prevInstance = setCurrentRenderingInstance(ctx);
          let res;
          try {
            res = fn(...args);
          } finally {
            setCurrentRenderingInstance(prevInstance);
            if (renderFnWithContext._d) {
              setBlockTracking(1);
            }
          }
          return res;
        };
        renderFnWithContext._n = true;
        renderFnWithContext._c = true;
        renderFnWithContext._d = true;
        return renderFnWithContext;
      }
      function withDirectives(vnode, directives) {
        if (currentRenderingInstance === null) {
          return vnode;
        }
        const instance = getComponentPublicInstance(currentRenderingInstance);
        const bindings = vnode.dirs || (vnode.dirs = []);
        for (let i = 0; i < directives.length; i++) {
          let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i];
          if (dir) {
            if (isFunction(dir)) {
              dir = {
                mounted: dir,
                updated: dir
              };
            }
            if (dir.deep) {
              traverse(value);
            }
            bindings.push({
              dir,
              instance,
              value,
              oldValue: void 0,
              arg,
              modifiers
            });
          }
        }
        return vnode;
      }
      function invokeDirectiveHook(vnode, prevVNode, instance, name) {
        const bindings = vnode.dirs;
        const oldBindings = prevVNode && prevVNode.dirs;
        for (let i = 0; i < bindings.length; i++) {
          const binding = bindings[i];
          if (oldBindings) {
            binding.oldValue = oldBindings[i].value;
          }
          let hook = binding.dir[name];
          if (hook) {
            pauseTracking();
            callWithAsyncErrorHandling(hook, instance, 8, [
              vnode.el,
              binding,
              vnode,
              prevVNode
            ]);
            resetTracking();
          }
        }
      }
      const TeleportEndKey = Symbol("_vte");
      const isTeleport = (type) => type.__isTeleport;
      const leaveCbKey = Symbol("_leaveCb");
      const enterCbKey = Symbol("_enterCb");
      function useTransitionState() {
        const state = {
          isMounted: false,
          isLeaving: false,
          isUnmounting: false,
          leavingVNodes: /* @__PURE__ */ new Map()
        };
        onMounted(() => {
          state.isMounted = true;
        });
        onBeforeUnmount(() => {
          state.isUnmounting = true;
        });
        return state;
      }
      const TransitionHookValidator = [Function, Array];
      const BaseTransitionPropsValidators = {
        mode: String,
        appear: Boolean,
        persisted: Boolean,
        // enter
        onBeforeEnter: TransitionHookValidator,
        onEnter: TransitionHookValidator,
        onAfterEnter: TransitionHookValidator,
        onEnterCancelled: TransitionHookValidator,
        // leave
        onBeforeLeave: TransitionHookValidator,
        onLeave: TransitionHookValidator,
        onAfterLeave: TransitionHookValidator,
        onLeaveCancelled: TransitionHookValidator,
        // appear
        onBeforeAppear: TransitionHookValidator,
        onAppear: TransitionHookValidator,
        onAfterAppear: TransitionHookValidator,
        onAppearCancelled: TransitionHookValidator
      };
      const recursiveGetSubtree = (instance) => {
        const subTree = instance.subTree;
        return subTree.component ? recursiveGetSubtree(subTree.component) : subTree;
      };
      const BaseTransitionImpl = {
        name: `BaseTransition`,
        props: BaseTransitionPropsValidators,
        setup(props, { slots }) {
          const instance = getCurrentInstance();
          const state = useTransitionState();
          return () => {
            const children = slots.default && getTransitionRawChildren(slots.default(), true);
            if (!children || !children.length) {
              return;
            }
            const child = findNonCommentChild(children);
            const rawProps = toRaw(props);
            const { mode } = rawProps;
            if (state.isLeaving) {
              return emptyPlaceholder(child);
            }
            const innerChild = getInnerChild$1(child);
            if (!innerChild) {
              return emptyPlaceholder(child);
            }
            let enterHooks = resolveTransitionHooks(
              innerChild,
              rawProps,
              state,
              instance,
              // #11061, ensure enterHooks is fresh after clone
              (hooks) => enterHooks = hooks
            );
            if (innerChild.type !== Comment) {
              setTransitionHooks(innerChild, enterHooks);
            }
            let oldInnerChild = instance.subTree && getInnerChild$1(instance.subTree);
            if (oldInnerChild && oldInnerChild.type !== Comment && !isSameVNodeType(oldInnerChild, innerChild) && recursiveGetSubtree(instance).type !== Comment) {
              let leavingHooks = resolveTransitionHooks(
                oldInnerChild,
                rawProps,
                state,
                instance
              );
              setTransitionHooks(oldInnerChild, leavingHooks);
              if (mode === "out-in" && innerChild.type !== Comment) {
                state.isLeaving = true;
                leavingHooks.afterLeave = () => {
                  state.isLeaving = false;
                  if (!(instance.job.flags & 8)) {
                    instance.update();
                  }
                  delete leavingHooks.afterLeave;
                  oldInnerChild = void 0;
                };
                return emptyPlaceholder(child);
              } else if (mode === "in-out" && innerChild.type !== Comment) {
                leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
                  const leavingVNodesCache = getLeavingNodesForType(
                    state,
                    oldInnerChild
                  );
                  leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
                  el[leaveCbKey] = () => {
                    earlyRemove();
                    el[leaveCbKey] = void 0;
                    delete enterHooks.delayedLeave;
                    oldInnerChild = void 0;
                  };
                  enterHooks.delayedLeave = () => {
                    delayedLeave();
                    delete enterHooks.delayedLeave;
                    oldInnerChild = void 0;
                  };
                };
              } else {
                oldInnerChild = void 0;
              }
            } else if (oldInnerChild) {
              oldInnerChild = void 0;
            }
            return child;
          };
        }
      };
      function findNonCommentChild(children) {
        let child = children[0];
        if (children.length > 1) {
          for (const c of children) {
            if (c.type !== Comment) {
              child = c;
              break;
            }
          }
        }
        return child;
      }
      const BaseTransition = BaseTransitionImpl;
      function getLeavingNodesForType(state, vnode) {
        const { leavingVNodes } = state;
        let leavingVNodesCache = leavingVNodes.get(vnode.type);
        if (!leavingVNodesCache) {
          leavingVNodesCache = /* @__PURE__ */ Object.create(null);
          leavingVNodes.set(vnode.type, leavingVNodesCache);
        }
        return leavingVNodesCache;
      }
      function resolveTransitionHooks(vnode, props, state, instance, postClone) {
        const {
          appear,
          mode,
          persisted = false,
          onBeforeEnter,
          onEnter,
          onAfterEnter,
          onEnterCancelled,
          onBeforeLeave,
          onLeave,
          onAfterLeave,
          onLeaveCancelled,
          onBeforeAppear,
          onAppear,
          onAfterAppear,
          onAppearCancelled
        } = props;
        const key = String(vnode.key);
        const leavingVNodesCache = getLeavingNodesForType(state, vnode);
        const callHook2 = (hook, args) => {
          hook && callWithAsyncErrorHandling(
            hook,
            instance,
            9,
            args
          );
        };
        const callAsyncHook = (hook, args) => {
          const done = args[1];
          callHook2(hook, args);
          if (isArray(hook)) {
            if (hook.every((hook2) => hook2.length <= 1)) done();
          } else if (hook.length <= 1) {
            done();
          }
        };
        const hooks = {
          mode,
          persisted,
          beforeEnter(el) {
            let hook = onBeforeEnter;
            if (!state.isMounted) {
              if (appear) {
                hook = onBeforeAppear || onBeforeEnter;
              } else {
                return;
              }
            }
            if (el[leaveCbKey]) {
              el[leaveCbKey](
                true
                /* cancelled */
              );
            }
            const leavingVNode = leavingVNodesCache[key];
            if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey]) {
              leavingVNode.el[leaveCbKey]();
            }
            callHook2(hook, [el]);
          },
          enter(el) {
            let hook = onEnter;
            let afterHook = onAfterEnter;
            let cancelHook = onEnterCancelled;
            if (!state.isMounted) {
              if (appear) {
                hook = onAppear || onEnter;
                afterHook = onAfterAppear || onAfterEnter;
                cancelHook = onAppearCancelled || onEnterCancelled;
              } else {
                return;
              }
            }
            let called = false;
            const done = el[enterCbKey] = (cancelled) => {
              if (called) return;
              called = true;
              if (cancelled) {
                callHook2(cancelHook, [el]);
              } else {
                callHook2(afterHook, [el]);
              }
              if (hooks.delayedLeave) {
                hooks.delayedLeave();
              }
              el[enterCbKey] = void 0;
            };
            if (hook) {
              callAsyncHook(hook, [el, done]);
            } else {
              done();
            }
          },
          leave(el, remove2) {
            const key2 = String(vnode.key);
            if (el[enterCbKey]) {
              el[enterCbKey](
                true
                /* cancelled */
              );
            }
            if (state.isUnmounting) {
              return remove2();
            }
            callHook2(onBeforeLeave, [el]);
            let called = false;
            const done = el[leaveCbKey] = (cancelled) => {
              if (called) return;
              called = true;
              remove2();
              if (cancelled) {
                callHook2(onLeaveCancelled, [el]);
              } else {
                callHook2(onAfterLeave, [el]);
              }
              el[leaveCbKey] = void 0;
              if (leavingVNodesCache[key2] === vnode) {
                delete leavingVNodesCache[key2];
              }
            };
            leavingVNodesCache[key2] = vnode;
            if (onLeave) {
              callAsyncHook(onLeave, [el, done]);
            } else {
              done();
            }
          },
          clone(vnode2) {
            const hooks2 = resolveTransitionHooks(
              vnode2,
              props,
              state,
              instance,
              postClone
            );
            if (postClone) postClone(hooks2);
            return hooks2;
          }
        };
        return hooks;
      }
      function emptyPlaceholder(vnode) {
        if (isKeepAlive(vnode)) {
          vnode = cloneVNode(vnode);
          vnode.children = null;
          return vnode;
        }
      }
      function getInnerChild$1(vnode) {
        if (!isKeepAlive(vnode)) {
          if (isTeleport(vnode.type) && vnode.children) {
            return findNonCommentChild(vnode.children);
          }
          return vnode;
        }
        if (vnode.component) {
          return vnode.component.subTree;
        }
        const { shapeFlag, children } = vnode;
        if (children) {
          if (shapeFlag & 16) {
            return children[0];
          }
          if (shapeFlag & 32 && isFunction(children.default)) {
            return children.default();
          }
        }
      }
      function setTransitionHooks(vnode, hooks) {
        if (vnode.shapeFlag & 6 && vnode.component) {
          vnode.transition = hooks;
          setTransitionHooks(vnode.component.subTree, hooks);
        } else if (vnode.shapeFlag & 128) {
          vnode.ssContent.transition = hooks.clone(vnode.ssContent);
          vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
        } else {
          vnode.transition = hooks;
        }
      }
      function getTransitionRawChildren(children, keepComment = false, parentKey) {
        let ret = [];
        let keyedFragmentCount = 0;
        for (let i = 0; i < children.length; i++) {
          let child = children[i];
          const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);
          if (child.type === Fragment) {
            if (child.patchFlag & 128) keyedFragmentCount++;
            ret = ret.concat(
              getTransitionRawChildren(child.children, keepComment, key)
            );
          } else if (keepComment || child.type !== Comment) {
            ret.push(key != null ? cloneVNode(child, { key }) : child);
          }
        }
        if (keyedFragmentCount > 1) {
          for (let i = 0; i < ret.length; i++) {
            ret[i].patchFlag = -2;
          }
        }
        return ret;
      }
      function markAsyncBoundary(instance) {
        instance.ids = [instance.ids[0] + instance.ids[2]++ + "-", 0, 0];
      }
      const pendingSetRefMap = /* @__PURE__ */ new WeakMap();
      function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
        if (isArray(rawRef)) {
          rawRef.forEach(
            (r, i) => setRef(
              r,
              oldRawRef && (isArray(oldRawRef) ? oldRawRef[i] : oldRawRef),
              parentSuspense,
              vnode,
              isUnmount
            )
          );
          return;
        }
        if (isAsyncWrapper(vnode) && !isUnmount) {
          if (vnode.shapeFlag & 512 && vnode.type.__asyncResolved && vnode.component.subTree.component) {
            setRef(rawRef, oldRawRef, parentSuspense, vnode.component.subTree);
          }
          return;
        }
        const refValue = vnode.shapeFlag & 4 ? getComponentPublicInstance(vnode.component) : vnode.el;
        const value = isUnmount ? null : refValue;
        const { i: owner, r: ref3 } = rawRef;
        const oldRef = oldRawRef && oldRawRef.r;
        const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
        const setupState = owner.setupState;
        const rawSetupState = toRaw(setupState);
        const canSetSetupRef = setupState === EMPTY_OBJ ? NO : (key) => {
          return hasOwn(rawSetupState, key);
        };
        if (oldRef != null && oldRef !== ref3) {
          invalidatePendingSetRef(oldRawRef);
          if (isString(oldRef)) {
            refs[oldRef] = null;
            if (canSetSetupRef(oldRef)) {
              setupState[oldRef] = null;
            }
          } else if (isRef(oldRef)) {
            {
              oldRef.value = null;
            }
            const oldRawRefAtom = oldRawRef;
            if (oldRawRefAtom.k) refs[oldRawRefAtom.k] = null;
          }
        }
        if (isFunction(ref3)) {
          callWithErrorHandling(ref3, owner, 12, [value, refs]);
        } else {
          const _isString = isString(ref3);
          const _isRef = isRef(ref3);
          if (_isString || _isRef) {
            const doSet = () => {
              if (rawRef.f) {
                const existing = _isString ? canSetSetupRef(ref3) ? setupState[ref3] : refs[ref3] : ref3.value ;
                if (isUnmount) {
                  isArray(existing) && remove(existing, refValue);
                } else {
                  if (!isArray(existing)) {
                    if (_isString) {
                      refs[ref3] = [refValue];
                      if (canSetSetupRef(ref3)) {
                        setupState[ref3] = refs[ref3];
                      }
                    } else {
                      const newVal = [refValue];
                      {
                        ref3.value = newVal;
                      }
                      if (rawRef.k) refs[rawRef.k] = newVal;
                    }
                  } else if (!existing.includes(refValue)) {
                    existing.push(refValue);
                  }
                }
              } else if (_isString) {
                refs[ref3] = value;
                if (canSetSetupRef(ref3)) {
                  setupState[ref3] = value;
                }
              } else if (_isRef) {
                {
                  ref3.value = value;
                }
                if (rawRef.k) refs[rawRef.k] = value;
              } else ;
            };
            if (value) {
              const job = () => {
                doSet();
                pendingSetRefMap.delete(rawRef);
              };
              job.id = -1;
              pendingSetRefMap.set(rawRef, job);
              queuePostRenderEffect(job, parentSuspense);
            } else {
              invalidatePendingSetRef(rawRef);
              doSet();
            }
          }
        }
      }
      function invalidatePendingSetRef(rawRef) {
        const pendingSetRef = pendingSetRefMap.get(rawRef);
        if (pendingSetRef) {
          pendingSetRef.flags |= 8;
          pendingSetRefMap.delete(rawRef);
        }
      }
      getGlobalThis().requestIdleCallback || ((cb) => setTimeout(cb, 1));
      getGlobalThis().cancelIdleCallback || ((id) => clearTimeout(id));
      const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
      const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
      function onActivated(hook, target) {
        registerKeepAliveHook(hook, "a", target);
      }
      function onDeactivated(hook, target) {
        registerKeepAliveHook(hook, "da", target);
      }
      function registerKeepAliveHook(hook, type, target = currentInstance) {
        const wrappedHook = hook.__wdc || (hook.__wdc = () => {
          let current = target;
          while (current) {
            if (current.isDeactivated) {
              return;
            }
            current = current.parent;
          }
          return hook();
        });
        injectHook(type, wrappedHook, target);
        if (target) {
          let current = target.parent;
          while (current && current.parent) {
            if (isKeepAlive(current.parent.vnode)) {
              injectToKeepAliveRoot(wrappedHook, type, target, current);
            }
            current = current.parent;
          }
        }
      }
      function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
        const injected = injectHook(
          type,
          hook,
          keepAliveRoot,
          true
          /* prepend */
        );
        onUnmounted(() => {
          remove(keepAliveRoot[type], injected);
        }, target);
      }
      function injectHook(type, hook, target = currentInstance, prepend = false) {
        if (target) {
          const hooks = target[type] || (target[type] = []);
          const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
            pauseTracking();
            const reset = setCurrentInstance(target);
            const res = callWithAsyncErrorHandling(hook, target, type, args);
            reset();
            resetTracking();
            return res;
          });
          if (prepend) {
            hooks.unshift(wrappedHook);
          } else {
            hooks.push(wrappedHook);
          }
          return wrappedHook;
        }
      }
      const createHook = (lifecycle) => (hook, target = currentInstance) => {
        if (!isInSSRComponentSetup || lifecycle === "sp") {
          injectHook(lifecycle, (...args) => hook(...args), target);
        }
      };
      const onBeforeMount = createHook("bm");
      const onMounted = createHook("m");
      const onBeforeUpdate = createHook(
        "bu"
      );
      const onUpdated = createHook("u");
      const onBeforeUnmount = createHook(
        "bum"
      );
      const onUnmounted = createHook("um");
      const onServerPrefetch = createHook(
        "sp"
      );
      const onRenderTriggered = createHook("rtg");
      const onRenderTracked = createHook("rtc");
      function onErrorCaptured(hook, target = currentInstance) {
        injectHook("ec", hook, target);
      }
      const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
      function renderList(source, renderItem, cache, index) {
        let ret;
        const cached = cache;
        const sourceIsArray = isArray(source);
        if (sourceIsArray || isString(source)) {
          const sourceIsReactiveArray = sourceIsArray && isReactive(source);
          let needsWrap = false;
          let isReadonlySource = false;
          if (sourceIsReactiveArray) {
            needsWrap = !isShallow(source);
            isReadonlySource = isReadonly(source);
            source = shallowReadArray(source);
          }
          ret = new Array(source.length);
          for (let i = 0, l = source.length; i < l; i++) {
            ret[i] = renderItem(
              needsWrap ? isReadonlySource ? toReadonly(toReactive(source[i])) : toReactive(source[i]) : source[i],
              i,
              void 0,
              cached
            );
          }
        } else if (typeof source === "number") {
          ret = new Array(source);
          for (let i = 0; i < source; i++) {
            ret[i] = renderItem(i + 1, i, void 0, cached);
          }
        } else if (isObject(source)) {
          if (source[Symbol.iterator]) {
            ret = Array.from(
              source,
              (item, i) => renderItem(item, i, void 0, cached)
            );
          } else {
            const keys = Object.keys(source);
            ret = new Array(keys.length);
            for (let i = 0, l = keys.length; i < l; i++) {
              const key = keys[i];
              ret[i] = renderItem(source[key], key, i, cached);
            }
          }
        } else {
          ret = [];
        }
        return ret;
      }
      function renderSlot(slots, name, props = {}, fallback, noSlotted) {
        if (currentRenderingInstance.ce || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.ce) {
          const hasProps = Object.keys(props).length > 0;
          return openBlock(), createBlock(
            Fragment,
            null,
            [createVNode("slot", props, fallback)],
            hasProps ? -2 : 64
          );
        }
        let slot = slots[name];
        if (slot && slot._c) {
          slot._d = false;
        }
        openBlock();
        const validSlotContent = slot && ensureValidVNode(slot(props));
        const slotKey = props.key || // slot content array of a dynamic conditional slot may have a branch
        // key attached in the `createSlots` helper, respect that
        validSlotContent && validSlotContent.key;
        const rendered = createBlock(
          Fragment,
          {
            key: (slotKey && !isSymbol(slotKey) ? slotKey : `_${name}`) + // #7256 force differentiate fallback content from actual content
            (!validSlotContent && fallback ? "_fb" : "")
          },
          validSlotContent || ([]),
          validSlotContent && slots._ === 1 ? 64 : -2
        );
        if (slot && slot._c) {
          slot._d = true;
        }
        return rendered;
      }
      function ensureValidVNode(vnodes) {
        return vnodes.some((child) => {
          if (!isVNode(child)) return true;
          if (child.type === Comment) return false;
          if (child.type === Fragment && !ensureValidVNode(child.children))
            return false;
          return true;
        }) ? vnodes : null;
      }
      const getPublicInstance = (i) => {
        if (!i) return null;
        if (isStatefulComponent(i)) return getComponentPublicInstance(i);
        return getPublicInstance(i.parent);
      };
      const publicPropertiesMap = (
        // Move PURE marker to new line to workaround compiler discarding it
        // due to type annotation
        /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {
          $: (i) => i,
          $el: (i) => i.vnode.el,
          $data: (i) => i.data,
          $props: (i) => i.props,
          $attrs: (i) => i.attrs,
          $slots: (i) => i.slots,
          $refs: (i) => i.refs,
          $parent: (i) => getPublicInstance(i.parent),
          $root: (i) => getPublicInstance(i.root),
          $host: (i) => i.ce,
          $emit: (i) => i.emit,
          $options: (i) => resolveMergedOptions(i) ,
          $forceUpdate: (i) => i.f || (i.f = () => {
            queueJob(i.update);
          }),
          $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
          $watch: (i) => instanceWatch.bind(i) 
        })
      );
      const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn(state, key);
      const PublicInstanceProxyHandlers = {
        get({ _: instance }, key) {
          if (key === "__v_skip") {
            return true;
          }
          const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
          let normalizedProps;
          if (key[0] !== "$") {
            const n = accessCache[key];
            if (n !== void 0) {
              switch (n) {
                case 1:
                  return setupState[key];
                case 2:
                  return data[key];
                case 4:
                  return ctx[key];
                case 3:
                  return props[key];
              }
            } else if (hasSetupBinding(setupState, key)) {
              accessCache[key] = 1;
              return setupState[key];
            } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
              accessCache[key] = 2;
              return data[key];
            } else if (
              // only cache other properties when instance has declared (thus stable)
              // props
              (normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)
            ) {
              accessCache[key] = 3;
              return props[key];
            } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
              accessCache[key] = 4;
              return ctx[key];
            } else if (shouldCacheAccess) {
              accessCache[key] = 0;
            }
          }
          const publicGetter = publicPropertiesMap[key];
          let cssModule, globalProperties;
          if (publicGetter) {
            if (key === "$attrs") {
              track(instance.attrs, "get", "");
            }
            return publicGetter(instance);
          } else if (
            // css module (injected by vue-loader)
            (cssModule = type.__cssModules) && (cssModule = cssModule[key])
          ) {
            return cssModule;
          } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
            accessCache[key] = 4;
            return ctx[key];
          } else if (
            // global properties
            globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)
          ) {
            {
              return globalProperties[key];
            }
          } else ;
        },
        set({ _: instance }, key, value) {
          const { data, setupState, ctx } = instance;
          if (hasSetupBinding(setupState, key)) {
            setupState[key] = value;
            return true;
          } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
            data[key] = value;
            return true;
          } else if (hasOwn(instance.props, key)) {
            return false;
          }
          if (key[0] === "$" && key.slice(1) in instance) {
            return false;
          } else {
            {
              ctx[key] = value;
            }
          }
          return true;
        },
        has({
          _: { data, setupState, accessCache, ctx, appContext, propsOptions, type }
        }, key) {
          let normalizedProps, cssModules;
          return !!(accessCache[key] || data !== EMPTY_OBJ && key[0] !== "$" && hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key) || (cssModules = type.__cssModules) && cssModules[key]);
        },
        defineProperty(target, key, descriptor) {
          if (descriptor.get != null) {
            target._.accessCache[key] = 0;
          } else if (hasOwn(descriptor, "value")) {
            this.set(target, key, descriptor.value, null);
          }
          return Reflect.defineProperty(target, key, descriptor);
        }
      };
      function normalizePropsOrEmits(props) {
        return isArray(props) ? props.reduce(
          (normalized, p) => (normalized[p] = null, normalized),
          {}
        ) : props;
      }
      let shouldCacheAccess = true;
      function applyOptions(instance) {
        const options = resolveMergedOptions(instance);
        const publicThis = instance.proxy;
        const ctx = instance.ctx;
        shouldCacheAccess = false;
        if (options.beforeCreate) {
          callHook$1(options.beforeCreate, instance, "bc");
        }
        const {
          // state
          data: dataOptions,
          computed: computedOptions,
          methods,
          watch: watchOptions,
          provide: provideOptions,
          inject: injectOptions,
          // lifecycle
          created,
          beforeMount,
          mounted,
          beforeUpdate,
          updated,
          activated,
          deactivated,
          beforeDestroy,
          beforeUnmount,
          destroyed,
          unmounted,
          render,
          renderTracked,
          renderTriggered,
          errorCaptured,
          serverPrefetch,
          // public API
          expose,
          inheritAttrs,
          // assets
          components,
          directives,
          filters
        } = options;
        const checkDuplicateProperties = null;
        if (injectOptions) {
          resolveInjections(injectOptions, ctx, checkDuplicateProperties);
        }
        if (methods) {
          for (const key in methods) {
            const methodHandler = methods[key];
            if (isFunction(methodHandler)) {
              {
                ctx[key] = methodHandler.bind(publicThis);
              }
            }
          }
        }
        if (dataOptions) {
          const data = dataOptions.call(publicThis, publicThis);
          if (!isObject(data)) ; else {
            instance.data = reactive(data);
          }
        }
        shouldCacheAccess = true;
        if (computedOptions) {
          for (const key in computedOptions) {
            const opt = computedOptions[key];
            const get = isFunction(opt) ? opt.bind(publicThis, publicThis) : isFunction(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
            const set = !isFunction(opt) && isFunction(opt.set) ? opt.set.bind(publicThis) : NOOP;
            const c = computed({
              get,
              set
            });
            Object.defineProperty(ctx, key, {
              enumerable: true,
              configurable: true,
              get: () => c.value,
              set: (v) => c.value = v
            });
          }
        }
        if (watchOptions) {
          for (const key in watchOptions) {
            createWatcher(watchOptions[key], ctx, publicThis, key);
          }
        }
        if (provideOptions) {
          const provides = isFunction(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
          Reflect.ownKeys(provides).forEach((key) => {
            provide(key, provides[key]);
          });
        }
        if (created) {
          callHook$1(created, instance, "c");
        }
        function registerLifecycleHook(register, hook) {
          if (isArray(hook)) {
            hook.forEach((_hook) => register(_hook.bind(publicThis)));
          } else if (hook) {
            register(hook.bind(publicThis));
          }
        }
        registerLifecycleHook(onBeforeMount, beforeMount);
        registerLifecycleHook(onMounted, mounted);
        registerLifecycleHook(onBeforeUpdate, beforeUpdate);
        registerLifecycleHook(onUpdated, updated);
        registerLifecycleHook(onActivated, activated);
        registerLifecycleHook(onDeactivated, deactivated);
        registerLifecycleHook(onErrorCaptured, errorCaptured);
        registerLifecycleHook(onRenderTracked, renderTracked);
        registerLifecycleHook(onRenderTriggered, renderTriggered);
        registerLifecycleHook(onBeforeUnmount, beforeUnmount);
        registerLifecycleHook(onUnmounted, unmounted);
        registerLifecycleHook(onServerPrefetch, serverPrefetch);
        if (isArray(expose)) {
          if (expose.length) {
            const exposed = instance.exposed || (instance.exposed = {});
            expose.forEach((key) => {
              Object.defineProperty(exposed, key, {
                get: () => publicThis[key],
                set: (val) => publicThis[key] = val,
                enumerable: true
              });
            });
          } else if (!instance.exposed) {
            instance.exposed = {};
          }
        }
        if (render && instance.render === NOOP) {
          instance.render = render;
        }
        if (inheritAttrs != null) {
          instance.inheritAttrs = inheritAttrs;
        }
        if (components) instance.components = components;
        if (directives) instance.directives = directives;
        if (serverPrefetch) {
          markAsyncBoundary(instance);
        }
      }
      function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
        if (isArray(injectOptions)) {
          injectOptions = normalizeInject(injectOptions);
        }
        for (const key in injectOptions) {
          const opt = injectOptions[key];
          let injected;
          if (isObject(opt)) {
            if ("default" in opt) {
              injected = inject(
                opt.from || key,
                opt.default,
                true
              );
            } else {
              injected = inject(opt.from || key);
            }
          } else {
            injected = inject(opt);
          }
          if (isRef(injected)) {
            Object.defineProperty(ctx, key, {
              enumerable: true,
              configurable: true,
              get: () => injected.value,
              set: (v) => injected.value = v
            });
          } else {
            ctx[key] = injected;
          }
        }
      }
      function callHook$1(hook, instance, type) {
        callWithAsyncErrorHandling(
          isArray(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy),
          instance,
          type
        );
      }
      function createWatcher(raw, ctx, publicThis, key) {
        let getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
        if (isString(raw)) {
          const handler = ctx[raw];
          if (isFunction(handler)) {
            {
              watch(getter, handler);
            }
          }
        } else if (isFunction(raw)) {
          {
            watch(getter, raw.bind(publicThis));
          }
        } else if (isObject(raw)) {
          if (isArray(raw)) {
            raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
          } else {
            const handler = isFunction(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
            if (isFunction(handler)) {
              watch(getter, handler, raw);
            }
          }
        } else ;
      }
      function resolveMergedOptions(instance) {
        const base = instance.type;
        const { mixins, extends: extendsOptions } = base;
        const {
          mixins: globalMixins,
          optionsCache: cache,
          config: { optionMergeStrategies }
        } = instance.appContext;
        const cached = cache.get(base);
        let resolved;
        if (cached) {
          resolved = cached;
        } else if (!globalMixins.length && !mixins && !extendsOptions) {
          {
            resolved = base;
          }
        } else {
          resolved = {};
          if (globalMixins.length) {
            globalMixins.forEach(
              (m) => mergeOptions(resolved, m, optionMergeStrategies, true)
            );
          }
          mergeOptions(resolved, base, optionMergeStrategies);
        }
        if (isObject(base)) {
          cache.set(base, resolved);
        }
        return resolved;
      }
      function mergeOptions(to, from, strats, asMixin = false) {
        const { mixins, extends: extendsOptions } = from;
        if (extendsOptions) {
          mergeOptions(to, extendsOptions, strats, true);
        }
        if (mixins) {
          mixins.forEach(
            (m) => mergeOptions(to, m, strats, true)
          );
        }
        for (const key in from) {
          if (asMixin && key === "expose") ; else {
            const strat = internalOptionMergeStrats[key] || strats && strats[key];
            to[key] = strat ? strat(to[key], from[key]) : from[key];
          }
        }
        return to;
      }
      const internalOptionMergeStrats = {
        data: mergeDataFn,
        props: mergeEmitsOrPropsOptions,
        emits: mergeEmitsOrPropsOptions,
        // objects
        methods: mergeObjectOptions,
        computed: mergeObjectOptions,
        // lifecycle
        beforeCreate: mergeAsArray,
        created: mergeAsArray,
        beforeMount: mergeAsArray,
        mounted: mergeAsArray,
        beforeUpdate: mergeAsArray,
        updated: mergeAsArray,
        beforeDestroy: mergeAsArray,
        beforeUnmount: mergeAsArray,
        destroyed: mergeAsArray,
        unmounted: mergeAsArray,
        activated: mergeAsArray,
        deactivated: mergeAsArray,
        errorCaptured: mergeAsArray,
        serverPrefetch: mergeAsArray,
        // assets
        components: mergeObjectOptions,
        directives: mergeObjectOptions,
        // watch
        watch: mergeWatchOptions,
        // provide / inject
        provide: mergeDataFn,
        inject: mergeInject
      };
      function mergeDataFn(to, from) {
        if (!from) {
          return to;
        }
        if (!to) {
          return from;
        }
        return function mergedDataFn() {
          return extend(
            isFunction(to) ? to.call(this, this) : to,
            isFunction(from) ? from.call(this, this) : from
          );
        };
      }
      function mergeInject(to, from) {
        return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
      }
      function normalizeInject(raw) {
        if (isArray(raw)) {
          const res = {};
          for (let i = 0; i < raw.length; i++) {
            res[raw[i]] = raw[i];
          }
          return res;
        }
        return raw;
      }
      function mergeAsArray(to, from) {
        return to ? [...new Set([].concat(to, from))] : from;
      }
      function mergeObjectOptions(to, from) {
        return to ? extend(/* @__PURE__ */ Object.create(null), to, from) : from;
      }
      function mergeEmitsOrPropsOptions(to, from) {
        if (to) {
          if (isArray(to) && isArray(from)) {
            return [.../* @__PURE__ */ new Set([...to, ...from])];
          }
          return extend(
            /* @__PURE__ */ Object.create(null),
            normalizePropsOrEmits(to),
            normalizePropsOrEmits(from != null ? from : {})
          );
        } else {
          return from;
        }
      }
      function mergeWatchOptions(to, from) {
        if (!to) return from;
        if (!from) return to;
        const merged = extend(/* @__PURE__ */ Object.create(null), to);
        for (const key in from) {
          merged[key] = mergeAsArray(to[key], from[key]);
        }
        return merged;
      }
      function createAppContext() {
        return {
          app: null,
          config: {
            isNativeTag: NO,
            performance: false,
            globalProperties: {},
            optionMergeStrategies: {},
            errorHandler: void 0,
            warnHandler: void 0,
            compilerOptions: {}
          },
          mixins: [],
          components: {},
          directives: {},
          provides: /* @__PURE__ */ Object.create(null),
          optionsCache: /* @__PURE__ */ new WeakMap(),
          propsCache: /* @__PURE__ */ new WeakMap(),
          emitsCache: /* @__PURE__ */ new WeakMap()
        };
      }
      let uid$1 = 0;
      function createAppAPI(render, hydrate) {
        return function createApp(rootComponent, rootProps = null) {
          if (!isFunction(rootComponent)) {
            rootComponent = extend({}, rootComponent);
          }
          if (rootProps != null && !isObject(rootProps)) {
            rootProps = null;
          }
          const context = createAppContext();
          const installedPlugins = /* @__PURE__ */ new WeakSet();
          const pluginCleanupFns = [];
          let isMounted = false;
          const app = context.app = {
            _uid: uid$1++,
            _component: rootComponent,
            _props: rootProps,
            _container: null,
            _context: context,
            _instance: null,
            version,
            get config() {
              return context.config;
            },
            set config(v) {
            },
            use(plugin, ...options) {
              if (installedPlugins.has(plugin)) ; else if (plugin && isFunction(plugin.install)) {
                installedPlugins.add(plugin);
                plugin.install(app, ...options);
              } else if (isFunction(plugin)) {
                installedPlugins.add(plugin);
                plugin(app, ...options);
              } else ;
              return app;
            },
            mixin(mixin) {
              {
                if (!context.mixins.includes(mixin)) {
                  context.mixins.push(mixin);
                }
              }
              return app;
            },
            component(name, component) {
              if (!component) {
                return context.components[name];
              }
              context.components[name] = component;
              return app;
            },
            directive(name, directive) {
              if (!directive) {
                return context.directives[name];
              }
              context.directives[name] = directive;
              return app;
            },
            mount(rootContainer, isHydrate, namespace) {
              if (!isMounted) {
                const vnode = app._ceVNode || createVNode(rootComponent, rootProps);
                vnode.appContext = context;
                if (namespace === true) {
                  namespace = "svg";
                } else if (namespace === false) {
                  namespace = void 0;
                }
                {
                  render(vnode, rootContainer, namespace);
                }
                isMounted = true;
                app._container = rootContainer;
                rootContainer.__vue_app__ = app;
                return getComponentPublicInstance(vnode.component);
              }
            },
            onUnmount(cleanupFn) {
              pluginCleanupFns.push(cleanupFn);
            },
            unmount() {
              if (isMounted) {
                callWithAsyncErrorHandling(
                  pluginCleanupFns,
                  app._instance,
                  16
                );
                render(null, app._container);
                delete app._container.__vue_app__;
              }
            },
            provide(key, value) {
              context.provides[key] = value;
              return app;
            },
            runWithContext(fn) {
              const lastApp = currentApp;
              currentApp = app;
              try {
                return fn();
              } finally {
                currentApp = lastApp;
              }
            }
          };
          return app;
        };
      }
      let currentApp = null;
      function provide(key, value) {
        if (!currentInstance) ; else {
          let provides = currentInstance.provides;
          const parentProvides = currentInstance.parent && currentInstance.parent.provides;
          if (parentProvides === provides) {
            provides = currentInstance.provides = Object.create(parentProvides);
          }
          provides[key] = value;
        }
      }
      function inject(key, defaultValue, treatDefaultAsFactory = false) {
        const instance = getCurrentInstance();
        if (instance || currentApp) {
          let provides = currentApp ? currentApp._context.provides : instance ? instance.parent == null || instance.ce ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : void 0;
          if (provides && key in provides) {
            return provides[key];
          } else if (arguments.length > 1) {
            return treatDefaultAsFactory && isFunction(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
          } else ;
        }
      }
      const internalObjectProto = {};
      const createInternalObject = () => Object.create(internalObjectProto);
      const isInternalObject = (obj) => Object.getPrototypeOf(obj) === internalObjectProto;
      function initProps(instance, rawProps, isStateful, isSSR = false) {
        const props = {};
        const attrs = createInternalObject();
        instance.propsDefaults = /* @__PURE__ */ Object.create(null);
        setFullProps(instance, rawProps, props, attrs);
        for (const key in instance.propsOptions[0]) {
          if (!(key in props)) {
            props[key] = void 0;
          }
        }
        if (isStateful) {
          instance.props = isSSR ? props : shallowReactive(props);
        } else {
          if (!instance.type.props) {
            instance.props = attrs;
          } else {
            instance.props = props;
          }
        }
        instance.attrs = attrs;
      }
      function updateProps(instance, rawProps, rawPrevProps, optimized) {
        const {
          props,
          attrs,
          vnode: { patchFlag }
        } = instance;
        const rawCurrentProps = toRaw(props);
        const [options] = instance.propsOptions;
        let hasAttrsChanged = false;
        if (
          // always force full diff in dev
          // - #1942 if hmr is enabled with sfc component
          // - vite#872 non-sfc component used by sfc component
          (optimized || patchFlag > 0) && !(patchFlag & 16)
        ) {
          if (patchFlag & 8) {
            const propsToUpdate = instance.vnode.dynamicProps;
            for (let i = 0; i < propsToUpdate.length; i++) {
              let key = propsToUpdate[i];
              if (isEmitListener(instance.emitsOptions, key)) {
                continue;
              }
              const value = rawProps[key];
              if (options) {
                if (hasOwn(attrs, key)) {
                  if (value !== attrs[key]) {
                    attrs[key] = value;
                    hasAttrsChanged = true;
                  }
                } else {
                  const camelizedKey = camelize(key);
                  props[camelizedKey] = resolvePropValue(
                    options,
                    rawCurrentProps,
                    camelizedKey,
                    value,
                    instance,
                    false
                  );
                }
              } else {
                if (value !== attrs[key]) {
                  attrs[key] = value;
                  hasAttrsChanged = true;
                }
              }
            }
          }
        } else {
          if (setFullProps(instance, rawProps, props, attrs)) {
            hasAttrsChanged = true;
          }
          let kebabKey;
          for (const key in rawCurrentProps) {
            if (!rawProps || // for camelCase
            !hasOwn(rawProps, key) && // it's possible the original props was passed in as kebab-case
            // and converted to camelCase (#955)
            ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
              if (options) {
                if (rawPrevProps && // for camelCase
                (rawPrevProps[key] !== void 0 || // for kebab-case
                rawPrevProps[kebabKey] !== void 0)) {
                  props[key] = resolvePropValue(
                    options,
                    rawCurrentProps,
                    key,
                    void 0,
                    instance,
                    true
                  );
                }
              } else {
                delete props[key];
              }
            }
          }
          if (attrs !== rawCurrentProps) {
            for (const key in attrs) {
              if (!rawProps || !hasOwn(rawProps, key) && true) {
                delete attrs[key];
                hasAttrsChanged = true;
              }
            }
          }
        }
        if (hasAttrsChanged) {
          trigger(instance.attrs, "set", "");
        }
      }
      function setFullProps(instance, rawProps, props, attrs) {
        const [options, needCastKeys] = instance.propsOptions;
        let hasAttrsChanged = false;
        let rawCastValues;
        if (rawProps) {
          for (let key in rawProps) {
            if (isReservedProp(key)) {
              continue;
            }
            const value = rawProps[key];
            let camelKey;
            if (options && hasOwn(options, camelKey = camelize(key))) {
              if (!needCastKeys || !needCastKeys.includes(camelKey)) {
                props[camelKey] = value;
              } else {
                (rawCastValues || (rawCastValues = {}))[camelKey] = value;
              }
            } else if (!isEmitListener(instance.emitsOptions, key)) {
              if (!(key in attrs) || value !== attrs[key]) {
                attrs[key] = value;
                hasAttrsChanged = true;
              }
            }
          }
        }
        if (needCastKeys) {
          const rawCurrentProps = toRaw(props);
          const castValues = rawCastValues || EMPTY_OBJ;
          for (let i = 0; i < needCastKeys.length; i++) {
            const key = needCastKeys[i];
            props[key] = resolvePropValue(
              options,
              rawCurrentProps,
              key,
              castValues[key],
              instance,
              !hasOwn(castValues, key)
            );
          }
        }
        return hasAttrsChanged;
      }
      function resolvePropValue(options, props, key, value, instance, isAbsent) {
        const opt = options[key];
        if (opt != null) {
          const hasDefault = hasOwn(opt, "default");
          if (hasDefault && value === void 0) {
            const defaultValue = opt.default;
            if (opt.type !== Function && !opt.skipFactory && isFunction(defaultValue)) {
              const { propsDefaults } = instance;
              if (key in propsDefaults) {
                value = propsDefaults[key];
              } else {
                const reset = setCurrentInstance(instance);
                value = propsDefaults[key] = defaultValue.call(
                  null,
                  props
                );
                reset();
              }
            } else {
              value = defaultValue;
            }
            if (instance.ce) {
              instance.ce._setProp(key, value);
            }
          }
          if (opt[
            0
            /* shouldCast */
          ]) {
            if (isAbsent && !hasDefault) {
              value = false;
            } else if (opt[
              1
              /* shouldCastTrue */
            ] && (value === "" || value === hyphenate(key))) {
              value = true;
            }
          }
        }
        return value;
      }
      const mixinPropsCache = /* @__PURE__ */ new WeakMap();
      function normalizePropsOptions(comp, appContext, asMixin = false) {
        const cache = asMixin ? mixinPropsCache : appContext.propsCache;
        const cached = cache.get(comp);
        if (cached) {
          return cached;
        }
        const raw = comp.props;
        const normalized = {};
        const needCastKeys = [];
        let hasExtends = false;
        if (!isFunction(comp)) {
          const extendProps = (raw2) => {
            hasExtends = true;
            const [props, keys] = normalizePropsOptions(raw2, appContext, true);
            extend(normalized, props);
            if (keys) needCastKeys.push(...keys);
          };
          if (!asMixin && appContext.mixins.length) {
            appContext.mixins.forEach(extendProps);
          }
          if (comp.extends) {
            extendProps(comp.extends);
          }
          if (comp.mixins) {
            comp.mixins.forEach(extendProps);
          }
        }
        if (!raw && !hasExtends) {
          if (isObject(comp)) {
            cache.set(comp, EMPTY_ARR);
          }
          return EMPTY_ARR;
        }
        if (isArray(raw)) {
          for (let i = 0; i < raw.length; i++) {
            const normalizedKey = camelize(raw[i]);
            if (validatePropName(normalizedKey)) {
              normalized[normalizedKey] = EMPTY_OBJ;
            }
          }
        } else if (raw) {
          for (const key in raw) {
            const normalizedKey = camelize(key);
            if (validatePropName(normalizedKey)) {
              const opt = raw[key];
              const prop = normalized[normalizedKey] = isArray(opt) || isFunction(opt) ? { type: opt } : extend({}, opt);
              const propType = prop.type;
              let shouldCast = false;
              let shouldCastTrue = true;
              if (isArray(propType)) {
                for (let index = 0; index < propType.length; ++index) {
                  const type = propType[index];
                  const typeName = isFunction(type) && type.name;
                  if (typeName === "Boolean") {
                    shouldCast = true;
                    break;
                  } else if (typeName === "String") {
                    shouldCastTrue = false;
                  }
                }
              } else {
                shouldCast = isFunction(propType) && propType.name === "Boolean";
              }
              prop[
                0
                /* shouldCast */
              ] = shouldCast;
              prop[
                1
                /* shouldCastTrue */
              ] = shouldCastTrue;
              if (shouldCast || hasOwn(prop, "default")) {
                needCastKeys.push(normalizedKey);
              }
            }
          }
        }
        const res = [normalized, needCastKeys];
        if (isObject(comp)) {
          cache.set(comp, res);
        }
        return res;
      }
      function validatePropName(key) {
        if (key[0] !== "$" && !isReservedProp(key)) {
          return true;
        }
        return false;
      }
      const isInternalKey = (key) => key === "_" || key === "_ctx" || key === "$stable";
      const normalizeSlotValue = (value) => isArray(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
      const normalizeSlot = (key, rawSlot, ctx) => {
        if (rawSlot._n) {
          return rawSlot;
        }
        const normalized = withCtx((...args) => {
          if (false) ;
          return normalizeSlotValue(rawSlot(...args));
        }, ctx);
        normalized._c = false;
        return normalized;
      };
      const normalizeObjectSlots = (rawSlots, slots, instance) => {
        const ctx = rawSlots._ctx;
        for (const key in rawSlots) {
          if (isInternalKey(key)) continue;
          const value = rawSlots[key];
          if (isFunction(value)) {
            slots[key] = normalizeSlot(key, value, ctx);
          } else if (value != null) {
            const normalized = normalizeSlotValue(value);
            slots[key] = () => normalized;
          }
        }
      };
      const normalizeVNodeSlots = (instance, children) => {
        const normalized = normalizeSlotValue(children);
        instance.slots.default = () => normalized;
      };
      const assignSlots = (slots, children, optimized) => {
        for (const key in children) {
          if (optimized || !isInternalKey(key)) {
            slots[key] = children[key];
          }
        }
      };
      const initSlots = (instance, children, optimized) => {
        const slots = instance.slots = createInternalObject();
        if (instance.vnode.shapeFlag & 32) {
          const type = children._;
          if (type) {
            assignSlots(slots, children, optimized);
            if (optimized) {
              def(slots, "_", type, true);
            }
          } else {
            normalizeObjectSlots(children, slots);
          }
        } else if (children) {
          normalizeVNodeSlots(instance, children);
        }
      };
      const updateSlots = (instance, children, optimized) => {
        const { vnode, slots } = instance;
        let needDeletionCheck = true;
        let deletionComparisonTarget = EMPTY_OBJ;
        if (vnode.shapeFlag & 32) {
          const type = children._;
          if (type) {
            if (optimized && type === 1) {
              needDeletionCheck = false;
            } else {
              assignSlots(slots, children, optimized);
            }
          } else {
            needDeletionCheck = !children.$stable;
            normalizeObjectSlots(children, slots);
          }
          deletionComparisonTarget = children;
        } else if (children) {
          normalizeVNodeSlots(instance, children);
          deletionComparisonTarget = { default: 1 };
        }
        if (needDeletionCheck) {
          for (const key in slots) {
            if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {
              delete slots[key];
            }
          }
        }
      };
      const queuePostRenderEffect = queueEffectWithSuspense;
      function createRenderer(options) {
        return baseCreateRenderer(options);
      }
      function baseCreateRenderer(options, createHydrationFns) {
        const target = getGlobalThis();
        target.__VUE__ = true;
        const {
          insert: hostInsert,
          remove: hostRemove,
          patchProp: hostPatchProp,
          createElement: hostCreateElement,
          createText: hostCreateText,
          createComment: hostCreateComment,
          setText: hostSetText,
          setElementText: hostSetElementText,
          parentNode: hostParentNode,
          nextSibling: hostNextSibling,
          setScopeId: hostSetScopeId = NOOP,
          insertStaticContent: hostInsertStaticContent
        } = options;
        const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace = void 0, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
          if (n1 === n2) {
            return;
          }
          if (n1 && !isSameVNodeType(n1, n2)) {
            anchor = getNextHostNode(n1);
            unmount(n1, parentComponent, parentSuspense, true);
            n1 = null;
          }
          if (n2.patchFlag === -2) {
            optimized = false;
            n2.dynamicChildren = null;
          }
          const { type, ref: ref3, shapeFlag } = n2;
          switch (type) {
            case Text:
              processText(n1, n2, container, anchor);
              break;
            case Comment:
              processCommentNode(n1, n2, container, anchor);
              break;
            case Static:
              if (n1 == null) {
                mountStaticNode(n2, container, anchor, namespace);
              }
              break;
            case Fragment:
              processFragment(
                n1,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
              break;
            default:
              if (shapeFlag & 1) {
                processElement(
                  n1,
                  n2,
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  namespace,
                  slotScopeIds,
                  optimized
                );
              } else if (shapeFlag & 6) {
                processComponent(
                  n1,
                  n2,
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  namespace,
                  slotScopeIds,
                  optimized
                );
              } else if (shapeFlag & 64) {
                type.process(
                  n1,
                  n2,
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  namespace,
                  slotScopeIds,
                  optimized,
                  internals
                );
              } else if (shapeFlag & 128) {
                type.process(
                  n1,
                  n2,
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  namespace,
                  slotScopeIds,
                  optimized,
                  internals
                );
              } else ;
          }
          if (ref3 != null && parentComponent) {
            setRef(ref3, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
          } else if (ref3 == null && n1 && n1.ref != null) {
            setRef(n1.ref, null, parentSuspense, n1, true);
          }
        };
        const processText = (n1, n2, container, anchor) => {
          if (n1 == null) {
            hostInsert(
              n2.el = hostCreateText(n2.children),
              container,
              anchor
            );
          } else {
            const el = n2.el = n1.el;
            if (n2.children !== n1.children) {
              hostSetText(el, n2.children);
            }
          }
        };
        const processCommentNode = (n1, n2, container, anchor) => {
          if (n1 == null) {
            hostInsert(
              n2.el = hostCreateComment(n2.children || ""),
              container,
              anchor
            );
          } else {
            n2.el = n1.el;
          }
        };
        const mountStaticNode = (n2, container, anchor, namespace) => {
          [n2.el, n2.anchor] = hostInsertStaticContent(
            n2.children,
            container,
            anchor,
            namespace,
            n2.el,
            n2.anchor
          );
        };
        const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
          let next;
          while (el && el !== anchor) {
            next = hostNextSibling(el);
            hostInsert(el, container, nextSibling);
            el = next;
          }
          hostInsert(anchor, container, nextSibling);
        };
        const removeStaticNode = ({ el, anchor }) => {
          let next;
          while (el && el !== anchor) {
            next = hostNextSibling(el);
            hostRemove(el);
            el = next;
          }
          hostRemove(anchor);
        };
        const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
          if (n2.type === "svg") {
            namespace = "svg";
          } else if (n2.type === "math") {
            namespace = "mathml";
          }
          if (n1 == null) {
            mountElement(
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else {
            patchElement(
              n1,
              n2,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          }
        };
        const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
          let el;
          let vnodeHook;
          const { props, shapeFlag, transition, dirs } = vnode;
          el = vnode.el = hostCreateElement(
            vnode.type,
            namespace,
            props && props.is,
            props
          );
          if (shapeFlag & 8) {
            hostSetElementText(el, vnode.children);
          } else if (shapeFlag & 16) {
            mountChildren(
              vnode.children,
              el,
              null,
              parentComponent,
              parentSuspense,
              resolveChildrenNamespace(vnode, namespace),
              slotScopeIds,
              optimized
            );
          }
          if (dirs) {
            invokeDirectiveHook(vnode, null, parentComponent, "created");
          }
          setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
          if (props) {
            for (const key in props) {
              if (key !== "value" && !isReservedProp(key)) {
                hostPatchProp(el, key, null, props[key], namespace, parentComponent);
              }
            }
            if ("value" in props) {
              hostPatchProp(el, "value", null, props.value, namespace);
            }
            if (vnodeHook = props.onVnodeBeforeMount) {
              invokeVNodeHook(vnodeHook, parentComponent, vnode);
            }
          }
          if (dirs) {
            invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
          }
          const needCallTransitionHooks = needTransition(parentSuspense, transition);
          if (needCallTransitionHooks) {
            transition.beforeEnter(el);
          }
          hostInsert(el, container, anchor);
          if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
            queuePostRenderEffect(() => {
              vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
              needCallTransitionHooks && transition.enter(el);
              dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
            }, parentSuspense);
          }
        };
        const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
          if (scopeId) {
            hostSetScopeId(el, scopeId);
          }
          if (slotScopeIds) {
            for (let i = 0; i < slotScopeIds.length; i++) {
              hostSetScopeId(el, slotScopeIds[i]);
            }
          }
          if (parentComponent) {
            let subTree = parentComponent.subTree;
            if (vnode === subTree || isSuspense(subTree.type) && (subTree.ssContent === vnode || subTree.ssFallback === vnode)) {
              const parentVNode = parentComponent.vnode;
              setScopeId(
                el,
                parentVNode,
                parentVNode.scopeId,
                parentVNode.slotScopeIds,
                parentComponent.parent
              );
            }
          }
        };
        const mountChildren = (children, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, start = 0) => {
          for (let i = start; i < children.length; i++) {
            const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
            patch(
              null,
              child,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          }
        };
        const patchElement = (n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
          const el = n2.el = n1.el;
          let { patchFlag, dynamicChildren, dirs } = n2;
          patchFlag |= n1.patchFlag & 16;
          const oldProps = n1.props || EMPTY_OBJ;
          const newProps = n2.props || EMPTY_OBJ;
          let vnodeHook;
          parentComponent && toggleRecurse(parentComponent, false);
          if (vnodeHook = newProps.onVnodeBeforeUpdate) {
            invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
          }
          if (dirs) {
            invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
          }
          parentComponent && toggleRecurse(parentComponent, true);
          if (oldProps.innerHTML && newProps.innerHTML == null || oldProps.textContent && newProps.textContent == null) {
            hostSetElementText(el, "");
          }
          if (dynamicChildren) {
            patchBlockChildren(
              n1.dynamicChildren,
              dynamicChildren,
              el,
              parentComponent,
              parentSuspense,
              resolveChildrenNamespace(n2, namespace),
              slotScopeIds
            );
          } else if (!optimized) {
            patchChildren(
              n1,
              n2,
              el,
              null,
              parentComponent,
              parentSuspense,
              resolveChildrenNamespace(n2, namespace),
              slotScopeIds,
              false
            );
          }
          if (patchFlag > 0) {
            if (patchFlag & 16) {
              patchProps(el, oldProps, newProps, parentComponent, namespace);
            } else {
              if (patchFlag & 2) {
                if (oldProps.class !== newProps.class) {
                  hostPatchProp(el, "class", null, newProps.class, namespace);
                }
              }
              if (patchFlag & 4) {
                hostPatchProp(el, "style", oldProps.style, newProps.style, namespace);
              }
              if (patchFlag & 8) {
                const propsToUpdate = n2.dynamicProps;
                for (let i = 0; i < propsToUpdate.length; i++) {
                  const key = propsToUpdate[i];
                  const prev = oldProps[key];
                  const next = newProps[key];
                  if (next !== prev || key === "value") {
                    hostPatchProp(el, key, prev, next, namespace, parentComponent);
                  }
                }
              }
            }
            if (patchFlag & 1) {
              if (n1.children !== n2.children) {
                hostSetElementText(el, n2.children);
              }
            }
          } else if (!optimized && dynamicChildren == null) {
            patchProps(el, oldProps, newProps, parentComponent, namespace);
          }
          if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
            queuePostRenderEffect(() => {
              vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
              dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
            }, parentSuspense);
          }
        };
        const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace, slotScopeIds) => {
          for (let i = 0; i < newChildren.length; i++) {
            const oldVNode = oldChildren[i];
            const newVNode = newChildren[i];
            const container = (
              // oldVNode may be an errored async setup() component inside Suspense
              // which will not have a mounted element
              oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
              // of the Fragment itself so it can move its children.
              (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
              // which also requires the correct parent container
              !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
              oldVNode.shapeFlag & (6 | 64 | 128)) ? hostParentNode(oldVNode.el) : (
                // In other cases, the parent container is not actually used so we
                // just pass the block element here to avoid a DOM parentNode call.
                fallbackContainer
              )
            );
            patch(
              oldVNode,
              newVNode,
              container,
              null,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              true
            );
          }
        };
        const patchProps = (el, oldProps, newProps, parentComponent, namespace) => {
          if (oldProps !== newProps) {
            if (oldProps !== EMPTY_OBJ) {
              for (const key in oldProps) {
                if (!isReservedProp(key) && !(key in newProps)) {
                  hostPatchProp(
                    el,
                    key,
                    oldProps[key],
                    null,
                    namespace,
                    parentComponent
                  );
                }
              }
            }
            for (const key in newProps) {
              if (isReservedProp(key)) continue;
              const next = newProps[key];
              const prev = oldProps[key];
              if (next !== prev && key !== "value") {
                hostPatchProp(el, key, prev, next, namespace, parentComponent);
              }
            }
            if ("value" in newProps) {
              hostPatchProp(el, "value", oldProps.value, newProps.value, namespace);
            }
          }
        };
        const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
          const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
          const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
          let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
          if (fragmentSlotScopeIds) {
            slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
          }
          if (n1 == null) {
            hostInsert(fragmentStartAnchor, container, anchor);
            hostInsert(fragmentEndAnchor, container, anchor);
            mountChildren(
              // #10007
              // such fragment like `<></>` will be compiled into
              // a fragment which doesn't have a children.
              // In this case fallback to an empty array
              n2.children || [],
              container,
              fragmentEndAnchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else {
            if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
            // of renderSlot() with no valid children
            n1.dynamicChildren) {
              patchBlockChildren(
                n1.dynamicChildren,
                dynamicChildren,
                container,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds
              );
              if (
                // #2080 if the stable fragment has a key, it's a <template v-for> that may
                //  get moved around. Make sure all root level vnodes inherit el.
                // #2134 or if it's a component root, it may also get moved around
                // as the component is being moved.
                n2.key != null || parentComponent && n2 === parentComponent.subTree
              ) {
                traverseStaticChildren(
                  n1,
                  n2,
                  true
                  /* shallow */
                );
              }
            } else {
              patchChildren(
                n1,
                n2,
                container,
                fragmentEndAnchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            }
          }
        };
        const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
          n2.slotScopeIds = slotScopeIds;
          if (n1 == null) {
            if (n2.shapeFlag & 512) {
              parentComponent.ctx.activate(
                n2,
                container,
                anchor,
                namespace,
                optimized
              );
            } else {
              mountComponent(
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                optimized
              );
            }
          } else {
            updateComponent(n1, n2, optimized);
          }
        };
        const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace, optimized) => {
          const instance = initialVNode.component = createComponentInstance(
            initialVNode,
            parentComponent,
            parentSuspense
          );
          if (isKeepAlive(initialVNode)) {
            instance.ctx.renderer = internals;
          }
          {
            setupComponent(instance, false, optimized);
          }
          if (instance.asyncDep) {
            parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect, optimized);
            if (!initialVNode.el) {
              const placeholder = instance.subTree = createVNode(Comment);
              processCommentNode(null, placeholder, container, anchor);
              initialVNode.placeholder = placeholder.el;
            }
          } else {
            setupRenderEffect(
              instance,
              initialVNode,
              container,
              anchor,
              parentSuspense,
              namespace,
              optimized
            );
          }
        };
        const updateComponent = (n1, n2, optimized) => {
          const instance = n2.component = n1.component;
          if (shouldUpdateComponent(n1, n2, optimized)) {
            if (instance.asyncDep && !instance.asyncResolved) {
              updateComponentPreRender(instance, n2, optimized);
              return;
            } else {
              instance.next = n2;
              instance.update();
            }
          } else {
            n2.el = n1.el;
            instance.vnode = n2;
          }
        };
        const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, namespace, optimized) => {
          const componentUpdateFn = () => {
            if (!instance.isMounted) {
              let vnodeHook;
              const { el, props } = initialVNode;
              const { bm, m, parent, root, type } = instance;
              const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
              toggleRecurse(instance, false);
              if (bm) {
                invokeArrayFns(bm);
              }
              if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
                invokeVNodeHook(vnodeHook, parent, initialVNode);
              }
              toggleRecurse(instance, true);
              {
                if (root.ce && // @ts-expect-error _def is private
                root.ce._def.shadowRoot !== false) {
                  root.ce._injectChildStyle(type);
                }
                const subTree = instance.subTree = renderComponentRoot(instance);
                patch(
                  null,
                  subTree,
                  container,
                  anchor,
                  instance,
                  parentSuspense,
                  namespace
                );
                initialVNode.el = subTree.el;
              }
              if (m) {
                queuePostRenderEffect(m, parentSuspense);
              }
              if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
                const scopedInitialVNode = initialVNode;
                queuePostRenderEffect(
                  () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
                  parentSuspense
                );
              }
              if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
                instance.a && queuePostRenderEffect(instance.a, parentSuspense);
              }
              instance.isMounted = true;
              initialVNode = container = anchor = null;
            } else {
              let { next, bu, u, parent, vnode } = instance;
              {
                const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);
                if (nonHydratedAsyncRoot) {
                  if (next) {
                    next.el = vnode.el;
                    updateComponentPreRender(instance, next, optimized);
                  }
                  nonHydratedAsyncRoot.asyncDep.then(() => {
                    if (!instance.isUnmounted) {
                      componentUpdateFn();
                    }
                  });
                  return;
                }
              }
              let originNext = next;
              let vnodeHook;
              toggleRecurse(instance, false);
              if (next) {
                next.el = vnode.el;
                updateComponentPreRender(instance, next, optimized);
              } else {
                next = vnode;
              }
              if (bu) {
                invokeArrayFns(bu);
              }
              if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
                invokeVNodeHook(vnodeHook, parent, next, vnode);
              }
              toggleRecurse(instance, true);
              const nextTree = renderComponentRoot(instance);
              const prevTree = instance.subTree;
              instance.subTree = nextTree;
              patch(
                prevTree,
                nextTree,
                // parent may have changed if it's in a teleport
                hostParentNode(prevTree.el),
                // anchor may have changed if it's in a fragment
                getNextHostNode(prevTree),
                instance,
                parentSuspense,
                namespace
              );
              next.el = nextTree.el;
              if (originNext === null) {
                updateHOCHostEl(instance, nextTree.el);
              }
              if (u) {
                queuePostRenderEffect(u, parentSuspense);
              }
              if (vnodeHook = next.props && next.props.onVnodeUpdated) {
                queuePostRenderEffect(
                  () => invokeVNodeHook(vnodeHook, parent, next, vnode),
                  parentSuspense
                );
              }
            }
          };
          instance.scope.on();
          const effect2 = instance.effect = new ReactiveEffect(componentUpdateFn);
          instance.scope.off();
          const update = instance.update = effect2.run.bind(effect2);
          const job = instance.job = effect2.runIfDirty.bind(effect2);
          job.i = instance;
          job.id = instance.uid;
          effect2.scheduler = () => queueJob(job);
          toggleRecurse(instance, true);
          update();
        };
        const updateComponentPreRender = (instance, nextVNode, optimized) => {
          nextVNode.component = instance;
          const prevProps = instance.vnode.props;
          instance.vnode = nextVNode;
          instance.next = null;
          updateProps(instance, nextVNode.props, prevProps, optimized);
          updateSlots(instance, nextVNode.children, optimized);
          pauseTracking();
          flushPreFlushCbs(instance);
          resetTracking();
        };
        const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized = false) => {
          const c1 = n1 && n1.children;
          const prevShapeFlag = n1 ? n1.shapeFlag : 0;
          const c2 = n2.children;
          const { patchFlag, shapeFlag } = n2;
          if (patchFlag > 0) {
            if (patchFlag & 128) {
              patchKeyedChildren(
                c1,
                c2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
              return;
            } else if (patchFlag & 256) {
              patchUnkeyedChildren(
                c1,
                c2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
              return;
            }
          }
          if (shapeFlag & 8) {
            if (prevShapeFlag & 16) {
              unmountChildren(c1, parentComponent, parentSuspense);
            }
            if (c2 !== c1) {
              hostSetElementText(container, c2);
            }
          } else {
            if (prevShapeFlag & 16) {
              if (shapeFlag & 16) {
                patchKeyedChildren(
                  c1,
                  c2,
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  namespace,
                  slotScopeIds,
                  optimized
                );
              } else {
                unmountChildren(c1, parentComponent, parentSuspense, true);
              }
            } else {
              if (prevShapeFlag & 8) {
                hostSetElementText(container, "");
              }
              if (shapeFlag & 16) {
                mountChildren(
                  c2,
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  namespace,
                  slotScopeIds,
                  optimized
                );
              }
            }
          }
        };
        const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
          c1 = c1 || EMPTY_ARR;
          c2 = c2 || EMPTY_ARR;
          const oldLength = c1.length;
          const newLength = c2.length;
          const commonLength = Math.min(oldLength, newLength);
          let i;
          for (i = 0; i < commonLength; i++) {
            const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
            patch(
              c1[i],
              nextChild,
              container,
              null,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          }
          if (oldLength > newLength) {
            unmountChildren(
              c1,
              parentComponent,
              parentSuspense,
              true,
              false,
              commonLength
            );
          } else {
            mountChildren(
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized,
              commonLength
            );
          }
        };
        const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
          let i = 0;
          const l2 = c2.length;
          let e1 = c1.length - 1;
          let e2 = l2 - 1;
          while (i <= e1 && i <= e2) {
            const n1 = c1[i];
            const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
            if (isSameVNodeType(n1, n2)) {
              patch(
                n1,
                n2,
                container,
                null,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            } else {
              break;
            }
            i++;
          }
          while (i <= e1 && i <= e2) {
            const n1 = c1[e1];
            const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
            if (isSameVNodeType(n1, n2)) {
              patch(
                n1,
                n2,
                container,
                null,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            } else {
              break;
            }
            e1--;
            e2--;
          }
          if (i > e1) {
            if (i <= e2) {
              const nextPos = e2 + 1;
              const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
              while (i <= e2) {
                patch(
                  null,
                  c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]),
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  namespace,
                  slotScopeIds,
                  optimized
                );
                i++;
              }
            }
          } else if (i > e2) {
            while (i <= e1) {
              unmount(c1[i], parentComponent, parentSuspense, true);
              i++;
            }
          } else {
            const s1 = i;
            const s2 = i;
            const keyToNewIndexMap = /* @__PURE__ */ new Map();
            for (i = s2; i <= e2; i++) {
              const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
              if (nextChild.key != null) {
                keyToNewIndexMap.set(nextChild.key, i);
              }
            }
            let j;
            let patched = 0;
            const toBePatched = e2 - s2 + 1;
            let moved = false;
            let maxNewIndexSoFar = 0;
            const newIndexToOldIndexMap = new Array(toBePatched);
            for (i = 0; i < toBePatched; i++) newIndexToOldIndexMap[i] = 0;
            for (i = s1; i <= e1; i++) {
              const prevChild = c1[i];
              if (patched >= toBePatched) {
                unmount(prevChild, parentComponent, parentSuspense, true);
                continue;
              }
              let newIndex;
              if (prevChild.key != null) {
                newIndex = keyToNewIndexMap.get(prevChild.key);
              } else {
                for (j = s2; j <= e2; j++) {
                  if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
                    newIndex = j;
                    break;
                  }
                }
              }
              if (newIndex === void 0) {
                unmount(prevChild, parentComponent, parentSuspense, true);
              } else {
                newIndexToOldIndexMap[newIndex - s2] = i + 1;
                if (newIndex >= maxNewIndexSoFar) {
                  maxNewIndexSoFar = newIndex;
                } else {
                  moved = true;
                }
                patch(
                  prevChild,
                  c2[newIndex],
                  container,
                  null,
                  parentComponent,
                  parentSuspense,
                  namespace,
                  slotScopeIds,
                  optimized
                );
                patched++;
              }
            }
            const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
            j = increasingNewIndexSequence.length - 1;
            for (i = toBePatched - 1; i >= 0; i--) {
              const nextIndex = s2 + i;
              const nextChild = c2[nextIndex];
              const anchorVNode = c2[nextIndex + 1];
              const anchor = nextIndex + 1 < l2 ? (
                // #13559, fallback to el placeholder for unresolved async component
                anchorVNode.el || anchorVNode.placeholder
              ) : parentAnchor;
              if (newIndexToOldIndexMap[i] === 0) {
                patch(
                  null,
                  nextChild,
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  namespace,
                  slotScopeIds,
                  optimized
                );
              } else if (moved) {
                if (j < 0 || i !== increasingNewIndexSequence[j]) {
                  move(nextChild, container, anchor, 2);
                } else {
                  j--;
                }
              }
            }
          }
        };
        const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
          const { el, type, transition, children, shapeFlag } = vnode;
          if (shapeFlag & 6) {
            move(vnode.component.subTree, container, anchor, moveType);
            return;
          }
          if (shapeFlag & 128) {
            vnode.suspense.move(container, anchor, moveType);
            return;
          }
          if (shapeFlag & 64) {
            type.move(vnode, container, anchor, internals);
            return;
          }
          if (type === Fragment) {
            hostInsert(el, container, anchor);
            for (let i = 0; i < children.length; i++) {
              move(children[i], container, anchor, moveType);
            }
            hostInsert(vnode.anchor, container, anchor);
            return;
          }
          if (type === Static) {
            moveStaticNode(vnode, container, anchor);
            return;
          }
          const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
          if (needTransition2) {
            if (moveType === 0) {
              transition.beforeEnter(el);
              hostInsert(el, container, anchor);
              queuePostRenderEffect(() => transition.enter(el), parentSuspense);
            } else {
              const { leave, delayLeave, afterLeave } = transition;
              const remove22 = () => {
                if (vnode.ctx.isUnmounted) {
                  hostRemove(el);
                } else {
                  hostInsert(el, container, anchor);
                }
              };
              const performLeave = () => {
                if (el._isLeaving) {
                  el[leaveCbKey](
                    true
                    /* cancelled */
                  );
                }
                leave(el, () => {
                  remove22();
                  afterLeave && afterLeave();
                });
              };
              if (delayLeave) {
                delayLeave(el, remove22, performLeave);
              } else {
                performLeave();
              }
            }
          } else {
            hostInsert(el, container, anchor);
          }
        };
        const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
          const {
            type,
            props,
            ref: ref3,
            children,
            dynamicChildren,
            shapeFlag,
            patchFlag,
            dirs,
            cacheIndex
          } = vnode;
          if (patchFlag === -2) {
            optimized = false;
          }
          if (ref3 != null) {
            pauseTracking();
            setRef(ref3, null, parentSuspense, vnode, true);
            resetTracking();
          }
          if (cacheIndex != null) {
            parentComponent.renderCache[cacheIndex] = void 0;
          }
          if (shapeFlag & 256) {
            parentComponent.ctx.deactivate(vnode);
            return;
          }
          const shouldInvokeDirs = shapeFlag & 1 && dirs;
          const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
          let vnodeHook;
          if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
            invokeVNodeHook(vnodeHook, parentComponent, vnode);
          }
          if (shapeFlag & 6) {
            unmountComponent(vnode.component, parentSuspense, doRemove);
          } else {
            if (shapeFlag & 128) {
              vnode.suspense.unmount(parentSuspense, doRemove);
              return;
            }
            if (shouldInvokeDirs) {
              invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
            }
            if (shapeFlag & 64) {
              vnode.type.remove(
                vnode,
                parentComponent,
                parentSuspense,
                internals,
                doRemove
              );
            } else if (dynamicChildren && // #5154
            // when v-once is used inside a block, setBlockTracking(-1) marks the
            // parent block with hasOnce: true
            // so that it doesn't take the fast path during unmount - otherwise
            // components nested in v-once are never unmounted.
            !dynamicChildren.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
            (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
              unmountChildren(
                dynamicChildren,
                parentComponent,
                parentSuspense,
                false,
                true
              );
            } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
              unmountChildren(children, parentComponent, parentSuspense);
            }
            if (doRemove) {
              remove2(vnode);
            }
          }
          if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
            queuePostRenderEffect(() => {
              vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
              shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
            }, parentSuspense);
          }
        };
        const remove2 = (vnode) => {
          const { type, el, anchor, transition } = vnode;
          if (type === Fragment) {
            {
              removeFragment(el, anchor);
            }
            return;
          }
          if (type === Static) {
            removeStaticNode(vnode);
            return;
          }
          const performRemove = () => {
            hostRemove(el);
            if (transition && !transition.persisted && transition.afterLeave) {
              transition.afterLeave();
            }
          };
          if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
            const { leave, delayLeave } = transition;
            const performLeave = () => leave(el, performRemove);
            if (delayLeave) {
              delayLeave(vnode.el, performRemove, performLeave);
            } else {
              performLeave();
            }
          } else {
            performRemove();
          }
        };
        const removeFragment = (cur, end) => {
          let next;
          while (cur !== end) {
            next = hostNextSibling(cur);
            hostRemove(cur);
            cur = next;
          }
          hostRemove(end);
        };
        const unmountComponent = (instance, parentSuspense, doRemove) => {
          const { bum, scope, job, subTree, um, m, a } = instance;
          invalidateMount(m);
          invalidateMount(a);
          if (bum) {
            invokeArrayFns(bum);
          }
          scope.stop();
          if (job) {
            job.flags |= 8;
            unmount(subTree, instance, parentSuspense, doRemove);
          }
          if (um) {
            queuePostRenderEffect(um, parentSuspense);
          }
          queuePostRenderEffect(() => {
            instance.isUnmounted = true;
          }, parentSuspense);
        };
        const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
          for (let i = start; i < children.length; i++) {
            unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
          }
        };
        const getNextHostNode = (vnode) => {
          if (vnode.shapeFlag & 6) {
            return getNextHostNode(vnode.component.subTree);
          }
          if (vnode.shapeFlag & 128) {
            return vnode.suspense.next();
          }
          const el = hostNextSibling(vnode.anchor || vnode.el);
          const teleportEnd = el && el[TeleportEndKey];
          return teleportEnd ? hostNextSibling(teleportEnd) : el;
        };
        let isFlushing = false;
        const render = (vnode, container, namespace) => {
          if (vnode == null) {
            if (container._vnode) {
              unmount(container._vnode, null, null, true);
            }
          } else {
            patch(
              container._vnode || null,
              vnode,
              container,
              null,
              null,
              null,
              namespace
            );
          }
          container._vnode = vnode;
          if (!isFlushing) {
            isFlushing = true;
            flushPreFlushCbs();
            flushPostFlushCbs();
            isFlushing = false;
          }
        };
        const internals = {
          p: patch,
          um: unmount,
          m: move,
          r: remove2,
          mt: mountComponent,
          mc: mountChildren,
          pc: patchChildren,
          pbc: patchBlockChildren,
          n: getNextHostNode,
          o: options
        };
        let hydrate;
        return {
          render,
          hydrate,
          createApp: createAppAPI(render)
        };
      }
      function resolveChildrenNamespace({ type, props }, currentNamespace) {
        return currentNamespace === "svg" && type === "foreignObject" || currentNamespace === "mathml" && type === "annotation-xml" && props && props.encoding && props.encoding.includes("html") ? void 0 : currentNamespace;
      }
      function toggleRecurse({ effect: effect2, job }, allowed) {
        if (allowed) {
          effect2.flags |= 32;
          job.flags |= 4;
        } else {
          effect2.flags &= -33;
          job.flags &= -5;
        }
      }
      function needTransition(parentSuspense, transition) {
        return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
      }
      function traverseStaticChildren(n1, n2, shallow = false) {
        const ch1 = n1.children;
        const ch2 = n2.children;
        if (isArray(ch1) && isArray(ch2)) {
          for (let i = 0; i < ch1.length; i++) {
            const c1 = ch1[i];
            let c2 = ch2[i];
            if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
              if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
                c2 = ch2[i] = cloneIfMounted(ch2[i]);
                c2.el = c1.el;
              }
              if (!shallow && c2.patchFlag !== -2)
                traverseStaticChildren(c1, c2);
            }
            if (c2.type === Text && // avoid cached text nodes retaining detached dom nodes
            c2.patchFlag !== -1) {
              c2.el = c1.el;
            }
            if (c2.type === Comment && !c2.el) {
              c2.el = c1.el;
            }
          }
        }
      }
      function getSequence(arr) {
        const p = arr.slice();
        const result = [0];
        let i, j, u, v, c;
        const len = arr.length;
        for (i = 0; i < len; i++) {
          const arrI = arr[i];
          if (arrI !== 0) {
            j = result[result.length - 1];
            if (arr[j] < arrI) {
              p[i] = j;
              result.push(i);
              continue;
            }
            u = 0;
            v = result.length - 1;
            while (u < v) {
              c = u + v >> 1;
              if (arr[result[c]] < arrI) {
                u = c + 1;
              } else {
                v = c;
              }
            }
            if (arrI < arr[result[u]]) {
              if (u > 0) {
                p[i] = result[u - 1];
              }
              result[u] = i;
            }
          }
        }
        u = result.length;
        v = result[u - 1];
        while (u-- > 0) {
          result[u] = v;
          v = p[v];
        }
        return result;
      }
      function locateNonHydratedAsyncRoot(instance) {
        const subComponent = instance.subTree.component;
        if (subComponent) {
          if (subComponent.asyncDep && !subComponent.asyncResolved) {
            return subComponent;
          } else {
            return locateNonHydratedAsyncRoot(subComponent);
          }
        }
      }
      function invalidateMount(hooks) {
        if (hooks) {
          for (let i = 0; i < hooks.length; i++)
            hooks[i].flags |= 8;
        }
      }
      const ssrContextKey = Symbol.for("v-scx");
      const useSSRContext = () => {
        {
          const ctx = inject(ssrContextKey);
          return ctx;
        }
      };
      function watch(source, cb, options) {
        return doWatch(source, cb, options);
      }
      function doWatch(source, cb, options = EMPTY_OBJ) {
        const { immediate, deep, flush, once } = options;
        const baseWatchOptions = extend({}, options);
        const runsImmediately = cb && immediate || !cb && flush !== "post";
        let ssrCleanup;
        if (isInSSRComponentSetup) {
          if (flush === "sync") {
            const ctx = useSSRContext();
            ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
          } else if (!runsImmediately) {
            const watchStopHandle = () => {
            };
            watchStopHandle.stop = NOOP;
            watchStopHandle.resume = NOOP;
            watchStopHandle.pause = NOOP;
            return watchStopHandle;
          }
        }
        const instance = currentInstance;
        baseWatchOptions.call = (fn, type, args) => callWithAsyncErrorHandling(fn, instance, type, args);
        let isPre = false;
        if (flush === "post") {
          baseWatchOptions.scheduler = (job) => {
            queuePostRenderEffect(job, instance && instance.suspense);
          };
        } else if (flush !== "sync") {
          isPre = true;
          baseWatchOptions.scheduler = (job, isFirstRun) => {
            if (isFirstRun) {
              job();
            } else {
              queueJob(job);
            }
          };
        }
        baseWatchOptions.augmentJob = (job) => {
          if (cb) {
            job.flags |= 4;
          }
          if (isPre) {
            job.flags |= 2;
            if (instance) {
              job.id = instance.uid;
              job.i = instance;
            }
          }
        };
        const watchHandle = watch$1(source, cb, baseWatchOptions);
        if (isInSSRComponentSetup) {
          if (ssrCleanup) {
            ssrCleanup.push(watchHandle);
          } else if (runsImmediately) {
            watchHandle();
          }
        }
        return watchHandle;
      }
      function instanceWatch(source, value, options) {
        const publicThis = this.proxy;
        const getter = isString(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
        let cb;
        if (isFunction(value)) {
          cb = value;
        } else {
          cb = value.handler;
          options = value;
        }
        const reset = setCurrentInstance(this);
        const res = doWatch(getter, cb.bind(publicThis), options);
        reset();
        return res;
      }
      function createPathGetter(ctx, path) {
        const segments = path.split(".");
        return () => {
          let cur = ctx;
          for (let i = 0; i < segments.length && cur; i++) {
            cur = cur[segments[i]];
          }
          return cur;
        };
      }
      const getModelModifiers = (props, modelName) => {
        return modelName === "modelValue" || modelName === "model-value" ? props.modelModifiers : props[`${modelName}Modifiers`] || props[`${camelize(modelName)}Modifiers`] || props[`${hyphenate(modelName)}Modifiers`];
      };
      function emit(instance, event, ...rawArgs) {
        if (instance.isUnmounted) return;
        const props = instance.vnode.props || EMPTY_OBJ;
        let args = rawArgs;
        const isModelListener2 = event.startsWith("update:");
        const modifiers = isModelListener2 && getModelModifiers(props, event.slice(7));
        if (modifiers) {
          if (modifiers.trim) {
            args = rawArgs.map((a) => isString(a) ? a.trim() : a);
          }
          if (modifiers.number) {
            args = rawArgs.map(looseToNumber);
          }
        }
        let handlerName;
        let handler = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
        props[handlerName = toHandlerKey(camelize(event))];
        if (!handler && isModelListener2) {
          handler = props[handlerName = toHandlerKey(hyphenate(event))];
        }
        if (handler) {
          callWithAsyncErrorHandling(
            handler,
            instance,
            6,
            args
          );
        }
        const onceHandler = props[handlerName + `Once`];
        if (onceHandler) {
          if (!instance.emitted) {
            instance.emitted = {};
          } else if (instance.emitted[handlerName]) {
            return;
          }
          instance.emitted[handlerName] = true;
          callWithAsyncErrorHandling(
            onceHandler,
            instance,
            6,
            args
          );
        }
      }
      const mixinEmitsCache = /* @__PURE__ */ new WeakMap();
      function normalizeEmitsOptions(comp, appContext, asMixin = false) {
        const cache = asMixin ? mixinEmitsCache : appContext.emitsCache;
        const cached = cache.get(comp);
        if (cached !== void 0) {
          return cached;
        }
        const raw = comp.emits;
        let normalized = {};
        let hasExtends = false;
        if (!isFunction(comp)) {
          const extendEmits = (raw2) => {
            const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
            if (normalizedFromExtend) {
              hasExtends = true;
              extend(normalized, normalizedFromExtend);
            }
          };
          if (!asMixin && appContext.mixins.length) {
            appContext.mixins.forEach(extendEmits);
          }
          if (comp.extends) {
            extendEmits(comp.extends);
          }
          if (comp.mixins) {
            comp.mixins.forEach(extendEmits);
          }
        }
        if (!raw && !hasExtends) {
          if (isObject(comp)) {
            cache.set(comp, null);
          }
          return null;
        }
        if (isArray(raw)) {
          raw.forEach((key) => normalized[key] = null);
        } else {
          extend(normalized, raw);
        }
        if (isObject(comp)) {
          cache.set(comp, normalized);
        }
        return normalized;
      }
      function isEmitListener(options, key) {
        if (!options || !isOn(key)) {
          return false;
        }
        key = key.slice(2).replace(/Once$/, "");
        return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
      }
      function markAttrsAccessed() {
      }
      function renderComponentRoot(instance) {
        const {
          type: Component,
          vnode,
          proxy,
          withProxy,
          propsOptions: [propsOptions],
          slots,
          attrs,
          emit: emit2,
          render,
          renderCache,
          props,
          data,
          setupState,
          ctx,
          inheritAttrs
        } = instance;
        const prev = setCurrentRenderingInstance(instance);
        let result;
        let fallthroughAttrs;
        try {
          if (vnode.shapeFlag & 4) {
            const proxyToUse = withProxy || proxy;
            const thisProxy = false ? new Proxy(proxyToUse, {
              get(target, key, receiver) {
                warn$1(
                  `Property '${String(
              key
            )}' was accessed via 'this'. Avoid using 'this' in templates.`
                );
                return Reflect.get(target, key, receiver);
              }
            }) : proxyToUse;
            result = normalizeVNode(
              render.call(
                thisProxy,
                proxyToUse,
                renderCache,
                false ? shallowReadonly(props) : props,
                setupState,
                data,
                ctx
              )
            );
            fallthroughAttrs = attrs;
          } else {
            const render2 = Component;
            if (false) ;
            result = normalizeVNode(
              render2.length > 1 ? render2(
                false ? shallowReadonly(props) : props,
                false ? {
                  get attrs() {
                    markAttrsAccessed();
                    return shallowReadonly(attrs);
                  },
                  slots,
                  emit: emit2
                } : { attrs, slots, emit: emit2 }
              ) : render2(
                false ? shallowReadonly(props) : props,
                null
              )
            );
            fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
          }
        } catch (err) {
          blockStack.length = 0;
          handleError(err, instance, 1);
          result = createVNode(Comment);
        }
        let root = result;
        if (fallthroughAttrs && inheritAttrs !== false) {
          const keys = Object.keys(fallthroughAttrs);
          const { shapeFlag } = root;
          if (keys.length) {
            if (shapeFlag & (1 | 6)) {
              if (propsOptions && keys.some(isModelListener)) {
                fallthroughAttrs = filterModelListeners(
                  fallthroughAttrs,
                  propsOptions
                );
              }
              root = cloneVNode(root, fallthroughAttrs, false, true);
            }
          }
        }
        if (vnode.dirs) {
          root = cloneVNode(root, null, false, true);
          root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
        }
        if (vnode.transition) {
          setTransitionHooks(root, vnode.transition);
        }
        {
          result = root;
        }
        setCurrentRenderingInstance(prev);
        return result;
      }
      const getFunctionalFallthrough = (attrs) => {
        let res;
        for (const key in attrs) {
          if (key === "class" || key === "style" || isOn(key)) {
            (res || (res = {}))[key] = attrs[key];
          }
        }
        return res;
      };
      const filterModelListeners = (attrs, props) => {
        const res = {};
        for (const key in attrs) {
          if (!isModelListener(key) || !(key.slice(9) in props)) {
            res[key] = attrs[key];
          }
        }
        return res;
      };
      function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
        const { props: prevProps, children: prevChildren, component } = prevVNode;
        const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
        const emits = component.emitsOptions;
        if (nextVNode.dirs || nextVNode.transition) {
          return true;
        }
        if (optimized && patchFlag >= 0) {
          if (patchFlag & 1024) {
            return true;
          }
          if (patchFlag & 16) {
            if (!prevProps) {
              return !!nextProps;
            }
            return hasPropsChanged(prevProps, nextProps, emits);
          } else if (patchFlag & 8) {
            const dynamicProps = nextVNode.dynamicProps;
            for (let i = 0; i < dynamicProps.length; i++) {
              const key = dynamicProps[i];
              if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
                return true;
              }
            }
          }
        } else {
          if (prevChildren || nextChildren) {
            if (!nextChildren || !nextChildren.$stable) {
              return true;
            }
          }
          if (prevProps === nextProps) {
            return false;
          }
          if (!prevProps) {
            return !!nextProps;
          }
          if (!nextProps) {
            return true;
          }
          return hasPropsChanged(prevProps, nextProps, emits);
        }
        return false;
      }
      function hasPropsChanged(prevProps, nextProps, emitsOptions) {
        const nextKeys = Object.keys(nextProps);
        if (nextKeys.length !== Object.keys(prevProps).length) {
          return true;
        }
        for (let i = 0; i < nextKeys.length; i++) {
          const key = nextKeys[i];
          if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
            return true;
          }
        }
        return false;
      }
      function updateHOCHostEl({ vnode, parent }, el) {
        while (parent) {
          const root = parent.subTree;
          if (root.suspense && root.suspense.activeBranch === vnode) {
            root.el = vnode.el;
          }
          if (root === vnode) {
            (vnode = parent.vnode).el = el;
            parent = parent.parent;
          } else {
            break;
          }
        }
      }
      const isSuspense = (type) => type.__isSuspense;
      function queueEffectWithSuspense(fn, suspense) {
        if (suspense && suspense.pendingBranch) {
          if (isArray(fn)) {
            suspense.effects.push(...fn);
          } else {
            suspense.effects.push(fn);
          }
        } else {
          queuePostFlushCb(fn);
        }
      }
      const Fragment = Symbol.for("v-fgt");
      const Text = Symbol.for("v-txt");
      const Comment = Symbol.for("v-cmt");
      const Static = Symbol.for("v-stc");
      const blockStack = [];
      let currentBlock = null;
      function openBlock(disableTracking = false) {
        blockStack.push(currentBlock = disableTracking ? null : []);
      }
      function closeBlock() {
        blockStack.pop();
        currentBlock = blockStack[blockStack.length - 1] || null;
      }
      let isBlockTreeEnabled = 1;
      function setBlockTracking(value, inVOnce = false) {
        isBlockTreeEnabled += value;
        if (value < 0 && currentBlock && inVOnce) {
          currentBlock.hasOnce = true;
        }
      }
      function setupBlock(vnode) {
        vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
        closeBlock();
        if (isBlockTreeEnabled > 0 && currentBlock) {
          currentBlock.push(vnode);
        }
        return vnode;
      }
      function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
        return setupBlock(
          createBaseVNode(
            type,
            props,
            children,
            patchFlag,
            dynamicProps,
            shapeFlag,
            true
          )
        );
      }
      function createBlock(type, props, children, patchFlag, dynamicProps) {
        return setupBlock(
          createVNode(
            type,
            props,
            children,
            patchFlag,
            dynamicProps,
            true
          )
        );
      }
      function isVNode(value) {
        return value ? value.__v_isVNode === true : false;
      }
      function isSameVNodeType(n1, n2) {
        return n1.type === n2.type && n1.key === n2.key;
      }
      const normalizeKey = ({ key }) => key != null ? key : null;
      const normalizeRef = ({
        ref: ref3,
        ref_key,
        ref_for
      }) => {
        if (typeof ref3 === "number") {
          ref3 = "" + ref3;
        }
        return ref3 != null ? isString(ref3) || isRef(ref3) || isFunction(ref3) ? { i: currentRenderingInstance, r: ref3, k: ref_key, f: !!ref_for } : ref3 : null;
      };
      function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
        const vnode = {
          __v_isVNode: true,
          __v_skip: true,
          type,
          props,
          key: props && normalizeKey(props),
          ref: props && normalizeRef(props),
          scopeId: currentScopeId,
          slotScopeIds: null,
          children,
          component: null,
          suspense: null,
          ssContent: null,
          ssFallback: null,
          dirs: null,
          transition: null,
          el: null,
          anchor: null,
          target: null,
          targetStart: null,
          targetAnchor: null,
          staticCount: 0,
          shapeFlag,
          patchFlag,
          dynamicProps,
          dynamicChildren: null,
          appContext: null,
          ctx: currentRenderingInstance
        };
        if (needFullChildrenNormalization) {
          normalizeChildren(vnode, children);
          if (shapeFlag & 128) {
            type.normalize(vnode);
          }
        } else if (children) {
          vnode.shapeFlag |= isString(children) ? 8 : 16;
        }
        if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
        !isBlockNode && // has current parent block
        currentBlock && // presence of a patch flag indicates this node needs patching on updates.
        // component nodes also should always be patched, because even if the
        // component doesn't need to update, it needs to persist the instance on to
        // the next vnode so that it can be properly unmounted later.
        (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
        // vnode should not be considered dynamic due to handler caching.
        vnode.patchFlag !== 32) {
          currentBlock.push(vnode);
        }
        return vnode;
      }
      const createVNode = _createVNode;
      function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
        if (!type || type === NULL_DYNAMIC_COMPONENT) {
          type = Comment;
        }
        if (isVNode(type)) {
          const cloned = cloneVNode(
            type,
            props,
            true
            /* mergeRef: true */
          );
          if (children) {
            normalizeChildren(cloned, children);
          }
          if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
            if (cloned.shapeFlag & 6) {
              currentBlock[currentBlock.indexOf(type)] = cloned;
            } else {
              currentBlock.push(cloned);
            }
          }
          cloned.patchFlag = -2;
          return cloned;
        }
        if (isClassComponent(type)) {
          type = type.__vccOpts;
        }
        if (props) {
          props = guardReactiveProps(props);
          let { class: klass, style } = props;
          if (klass && !isString(klass)) {
            props.class = normalizeClass(klass);
          }
          if (isObject(style)) {
            if (isProxy(style) && !isArray(style)) {
              style = extend({}, style);
            }
            props.style = normalizeStyle(style);
          }
        }
        const shapeFlag = isString(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject(type) ? 4 : isFunction(type) ? 2 : 0;
        return createBaseVNode(
          type,
          props,
          children,
          patchFlag,
          dynamicProps,
          shapeFlag,
          isBlockNode,
          true
        );
      }
      function guardReactiveProps(props) {
        if (!props) return null;
        return isProxy(props) || isInternalObject(props) ? extend({}, props) : props;
      }
      function cloneVNode(vnode, extraProps, mergeRef = false, cloneTransition = false) {
        const { props, ref: ref3, patchFlag, children, transition } = vnode;
        const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
        const cloned = {
          __v_isVNode: true,
          __v_skip: true,
          type: vnode.type,
          props: mergedProps,
          key: mergedProps && normalizeKey(mergedProps),
          ref: extraProps && extraProps.ref ? (
            // #2078 in the case of <component :is="vnode" ref="extra"/>
            // if the vnode itself already has a ref, cloneVNode will need to merge
            // the refs so the single vnode can be set on multiple refs
            mergeRef && ref3 ? isArray(ref3) ? ref3.concat(normalizeRef(extraProps)) : [ref3, normalizeRef(extraProps)] : normalizeRef(extraProps)
          ) : ref3,
          scopeId: vnode.scopeId,
          slotScopeIds: vnode.slotScopeIds,
          children: children,
          target: vnode.target,
          targetStart: vnode.targetStart,
          targetAnchor: vnode.targetAnchor,
          staticCount: vnode.staticCount,
          shapeFlag: vnode.shapeFlag,
          // if the vnode is cloned with extra props, we can no longer assume its
          // existing patch flag to be reliable and need to add the FULL_PROPS flag.
          // note: preserve flag for fragments since they use the flag for children
          // fast paths only.
          patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
          dynamicProps: vnode.dynamicProps,
          dynamicChildren: vnode.dynamicChildren,
          appContext: vnode.appContext,
          dirs: vnode.dirs,
          transition,
          // These should technically only be non-null on mounted VNodes. However,
          // they *should* be copied for kept-alive vnodes. So we just always copy
          // them since them being non-null during a mount doesn't affect the logic as
          // they will simply be overwritten.
          component: vnode.component,
          suspense: vnode.suspense,
          ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
          ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
          placeholder: vnode.placeholder,
          el: vnode.el,
          anchor: vnode.anchor,
          ctx: vnode.ctx,
          ce: vnode.ce
        };
        if (transition && cloneTransition) {
          setTransitionHooks(
            cloned,
            transition.clone(cloned)
          );
        }
        return cloned;
      }
      function createTextVNode(text = " ", flag = 0) {
        return createVNode(Text, null, text, flag);
      }
      function createStaticVNode(content, numberOfNodes) {
        const vnode = createVNode(Static, null, content);
        vnode.staticCount = numberOfNodes;
        return vnode;
      }
      function createCommentVNode(text = "", asBlock = false) {
        return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
      }
      function normalizeVNode(child) {
        if (child == null || typeof child === "boolean") {
          return createVNode(Comment);
        } else if (isArray(child)) {
          return createVNode(
            Fragment,
            null,
            // #3666, avoid reference pollution when reusing vnode
            child.slice()
          );
        } else if (isVNode(child)) {
          return cloneIfMounted(child);
        } else {
          return createVNode(Text, null, String(child));
        }
      }
      function cloneIfMounted(child) {
        return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
      }
      function normalizeChildren(vnode, children) {
        let type = 0;
        const { shapeFlag } = vnode;
        if (children == null) {
          children = null;
        } else if (isArray(children)) {
          type = 16;
        } else if (typeof children === "object") {
          if (shapeFlag & (1 | 64)) {
            const slot = children.default;
            if (slot) {
              slot._c && (slot._d = false);
              normalizeChildren(vnode, slot());
              slot._c && (slot._d = true);
            }
            return;
          } else {
            type = 32;
            const slotFlag = children._;
            if (!slotFlag && !isInternalObject(children)) {
              children._ctx = currentRenderingInstance;
            } else if (slotFlag === 3 && currentRenderingInstance) {
              if (currentRenderingInstance.slots._ === 1) {
                children._ = 1;
              } else {
                children._ = 2;
                vnode.patchFlag |= 1024;
              }
            }
          }
        } else if (isFunction(children)) {
          children = { default: children, _ctx: currentRenderingInstance };
          type = 32;
        } else {
          children = String(children);
          if (shapeFlag & 64) {
            type = 16;
            children = [createTextVNode(children)];
          } else {
            type = 8;
          }
        }
        vnode.children = children;
        vnode.shapeFlag |= type;
      }
      function mergeProps(...args) {
        const ret = {};
        for (let i = 0; i < args.length; i++) {
          const toMerge = args[i];
          for (const key in toMerge) {
            if (key === "class") {
              if (ret.class !== toMerge.class) {
                ret.class = normalizeClass([ret.class, toMerge.class]);
              }
            } else if (key === "style") {
              ret.style = normalizeStyle([ret.style, toMerge.style]);
            } else if (isOn(key)) {
              const existing = ret[key];
              const incoming = toMerge[key];
              if (incoming && existing !== incoming && !(isArray(existing) && existing.includes(incoming))) {
                ret[key] = existing ? [].concat(existing, incoming) : incoming;
              }
            } else if (key !== "") {
              ret[key] = toMerge[key];
            }
          }
        }
        return ret;
      }
      function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
        callWithAsyncErrorHandling(hook, instance, 7, [
          vnode,
          prevVNode
        ]);
      }
      const emptyAppContext = createAppContext();
      let uid = 0;
      function createComponentInstance(vnode, parent, suspense) {
        const type = vnode.type;
        const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
        const instance = {
          uid: uid++,
          vnode,
          type,
          parent,
          appContext,
          root: null,
          // to be immediately set
          next: null,
          subTree: null,
          // will be set synchronously right after creation
          effect: null,
          update: null,
          // will be set synchronously right after creation
          job: null,
          scope: new EffectScope(
            true
            /* detached */
          ),
          render: null,
          proxy: null,
          exposed: null,
          exposeProxy: null,
          withProxy: null,
          provides: parent ? parent.provides : Object.create(appContext.provides),
          ids: parent ? parent.ids : ["", 0, 0],
          accessCache: null,
          renderCache: [],
          // local resolved assets
          components: null,
          directives: null,
          // resolved props and emits options
          propsOptions: normalizePropsOptions(type, appContext),
          emitsOptions: normalizeEmitsOptions(type, appContext),
          // emit
          emit: null,
          // to be set immediately
          emitted: null,
          // props default value
          propsDefaults: EMPTY_OBJ,
          // inheritAttrs
          inheritAttrs: type.inheritAttrs,
          // state
          ctx: EMPTY_OBJ,
          data: EMPTY_OBJ,
          props: EMPTY_OBJ,
          attrs: EMPTY_OBJ,
          slots: EMPTY_OBJ,
          refs: EMPTY_OBJ,
          setupState: EMPTY_OBJ,
          setupContext: null,
          // suspense related
          suspense,
          suspenseId: suspense ? suspense.pendingId : 0,
          asyncDep: null,
          asyncResolved: false,
          // lifecycle hooks
          // not using enums here because it results in computed properties
          isMounted: false,
          isUnmounted: false,
          isDeactivated: false,
          bc: null,
          c: null,
          bm: null,
          m: null,
          bu: null,
          u: null,
          um: null,
          bum: null,
          da: null,
          a: null,
          rtg: null,
          rtc: null,
          ec: null,
          sp: null
        };
        {
          instance.ctx = { _: instance };
        }
        instance.root = parent ? parent.root : instance;
        instance.emit = emit.bind(null, instance);
        if (vnode.ce) {
          vnode.ce(instance);
        }
        return instance;
      }
      let currentInstance = null;
      const getCurrentInstance = () => currentInstance || currentRenderingInstance;
      let internalSetCurrentInstance;
      let setInSSRSetupState;
      {
        const g = getGlobalThis();
        const registerGlobalSetter = (key, setter) => {
          let setters;
          if (!(setters = g[key])) setters = g[key] = [];
          setters.push(setter);
          return (v) => {
            if (setters.length > 1) setters.forEach((set) => set(v));
            else setters[0](v);
          };
        };
        internalSetCurrentInstance = registerGlobalSetter(
          `__VUE_INSTANCE_SETTERS__`,
          (v) => currentInstance = v
        );
        setInSSRSetupState = registerGlobalSetter(
          `__VUE_SSR_SETTERS__`,
          (v) => isInSSRComponentSetup = v
        );
      }
      const setCurrentInstance = (instance) => {
        const prev = currentInstance;
        internalSetCurrentInstance(instance);
        instance.scope.on();
        return () => {
          instance.scope.off();
          internalSetCurrentInstance(prev);
        };
      };
      const unsetCurrentInstance = () => {
        currentInstance && currentInstance.scope.off();
        internalSetCurrentInstance(null);
      };
      function isStatefulComponent(instance) {
        return instance.vnode.shapeFlag & 4;
      }
      let isInSSRComponentSetup = false;
      function setupComponent(instance, isSSR = false, optimized = false) {
        isSSR && setInSSRSetupState(isSSR);
        const { props, children } = instance.vnode;
        const isStateful = isStatefulComponent(instance);
        initProps(instance, props, isStateful, isSSR);
        initSlots(instance, children, optimized || isSSR);
        const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
        isSSR && setInSSRSetupState(false);
        return setupResult;
      }
      function setupStatefulComponent(instance, isSSR) {
        const Component = instance.type;
        instance.accessCache = /* @__PURE__ */ Object.create(null);
        instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);
        const { setup } = Component;
        if (setup) {
          pauseTracking();
          const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
          const reset = setCurrentInstance(instance);
          const setupResult = callWithErrorHandling(
            setup,
            instance,
            0,
            [
              instance.props,
              setupContext
            ]
          );
          const isAsyncSetup = isPromise(setupResult);
          resetTracking();
          reset();
          if ((isAsyncSetup || instance.sp) && !isAsyncWrapper(instance)) {
            markAsyncBoundary(instance);
          }
          if (isAsyncSetup) {
            setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
            if (isSSR) {
              return setupResult.then((resolvedResult) => {
                handleSetupResult(instance, resolvedResult);
              }).catch((e) => {
                handleError(e, instance, 0);
              });
            } else {
              instance.asyncDep = setupResult;
            }
          } else {
            handleSetupResult(instance, setupResult);
          }
        } else {
          finishComponentSetup(instance);
        }
      }
      function handleSetupResult(instance, setupResult, isSSR) {
        if (isFunction(setupResult)) {
          if (instance.type.__ssrInlineRender) {
            instance.ssrRender = setupResult;
          } else {
            instance.render = setupResult;
          }
        } else if (isObject(setupResult)) {
          instance.setupState = proxyRefs(setupResult);
        } else ;
        finishComponentSetup(instance);
      }
      function finishComponentSetup(instance, isSSR, skipOptions) {
        const Component = instance.type;
        if (!instance.render) {
          instance.render = Component.render || NOOP;
        }
        {
          const reset = setCurrentInstance(instance);
          pauseTracking();
          try {
            applyOptions(instance);
          } finally {
            resetTracking();
            reset();
          }
        }
      }
      const attrsProxyHandlers = {
        get(target, key) {
          track(target, "get", "");
          return target[key];
        }
      };
      function createSetupContext(instance) {
        const expose = (exposed) => {
          instance.exposed = exposed || {};
        };
        {
          return {
            attrs: new Proxy(instance.attrs, attrsProxyHandlers),
            slots: instance.slots,
            emit: instance.emit,
            expose
          };
        }
      }
      function getComponentPublicInstance(instance) {
        if (instance.exposed) {
          return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
            get(target, key) {
              if (key in target) {
                return target[key];
              } else if (key in publicPropertiesMap) {
                return publicPropertiesMap[key](instance);
              }
            },
            has(target, key) {
              return key in target || key in publicPropertiesMap;
            }
          }));
        } else {
          return instance.proxy;
        }
      }
      const classifyRE = /(?:^|[-_])\w/g;
      const classify = (str) => str.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, "");
      function getComponentName(Component, includeInferred = true) {
        return isFunction(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
      }
      function formatComponentName(instance, Component, isRoot = false) {
        let name = getComponentName(Component);
        if (!name && Component.__file) {
          const match = Component.__file.match(/([^/\\]+)\.\w+$/);
          if (match) {
            name = match[1];
          }
        }
        if (!name && instance && instance.parent) {
          const inferFromRegistry = (registry) => {
            for (const key in registry) {
              if (registry[key] === Component) {
                return key;
              }
            }
          };
          name = inferFromRegistry(
            instance.components || instance.parent.type.components
          ) || inferFromRegistry(instance.appContext.components);
        }
        return name ? classify(name) : isRoot ? `App` : `Anonymous`;
      }
      function isClassComponent(value) {
        return isFunction(value) && "__vccOpts" in value;
      }
      const computed = (getterOrOptions, debugOptions) => {
        const c = computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
        return c;
      };
      function h(type, propsOrChildren, children) {
        try {
          setBlockTracking(-1);
          const l = arguments.length;
          if (l === 2) {
            if (isObject(propsOrChildren) && !isArray(propsOrChildren)) {
              if (isVNode(propsOrChildren)) {
                return createVNode(type, null, [propsOrChildren]);
              }
              return createVNode(type, propsOrChildren);
            } else {
              return createVNode(type, null, propsOrChildren);
            }
          } else {
            if (l > 3) {
              children = Array.prototype.slice.call(arguments, 2);
            } else if (l === 3 && isVNode(children)) {
              children = [children];
            }
            return createVNode(type, propsOrChildren, children);
          }
        } finally {
          setBlockTracking(1);
        }
      }
      const version = "3.5.22";

      /**
      * @vue/runtime-dom v3.5.22
      * (c) 2018-present Yuxi (Evan) You and Vue contributors
      * @license MIT
      **/
      let policy = void 0;
      const tt = typeof window !== "undefined" && window.trustedTypes;
      if (tt) {
        try {
          policy = /* @__PURE__ */ tt.createPolicy("vue", {
            createHTML: (val) => val
          });
        } catch (e) {
        }
      }
      const unsafeToTrustedHTML = policy ? (val) => policy.createHTML(val) : (val) => val;
      const svgNS = "http://www.w3.org/2000/svg";
      const mathmlNS = "http://www.w3.org/1998/Math/MathML";
      const doc = typeof document !== "undefined" ? document : null;
      const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
      const nodeOps = {
        insert: (child, parent, anchor) => {
          parent.insertBefore(child, anchor || null);
        },
        remove: (child) => {
          const parent = child.parentNode;
          if (parent) {
            parent.removeChild(child);
          }
        },
        createElement: (tag, namespace, is, props) => {
          const el = namespace === "svg" ? doc.createElementNS(svgNS, tag) : namespace === "mathml" ? doc.createElementNS(mathmlNS, tag) : is ? doc.createElement(tag, { is }) : doc.createElement(tag);
          if (tag === "select" && props && props.multiple != null) {
            el.setAttribute("multiple", props.multiple);
          }
          return el;
        },
        createText: (text) => doc.createTextNode(text),
        createComment: (text) => doc.createComment(text),
        setText: (node, text) => {
          node.nodeValue = text;
        },
        setElementText: (el, text) => {
          el.textContent = text;
        },
        parentNode: (node) => node.parentNode,
        nextSibling: (node) => node.nextSibling,
        querySelector: (selector) => doc.querySelector(selector),
        setScopeId(el, id) {
          el.setAttribute(id, "");
        },
        // __UNSAFE__
        // Reason: innerHTML.
        // Static content here can only come from compiled templates.
        // As long as the user only uses trusted templates, this is safe.
        insertStaticContent(content, parent, anchor, namespace, start, end) {
          const before = anchor ? anchor.previousSibling : parent.lastChild;
          if (start && (start === end || start.nextSibling)) {
            while (true) {
              parent.insertBefore(start.cloneNode(true), anchor);
              if (start === end || !(start = start.nextSibling)) break;
            }
          } else {
            templateContainer.innerHTML = unsafeToTrustedHTML(
              namespace === "svg" ? `<svg>${content}</svg>` : namespace === "mathml" ? `<math>${content}</math>` : content
            );
            const template = templateContainer.content;
            if (namespace === "svg" || namespace === "mathml") {
              const wrapper = template.firstChild;
              while (wrapper.firstChild) {
                template.appendChild(wrapper.firstChild);
              }
              template.removeChild(wrapper);
            }
            parent.insertBefore(template, anchor);
          }
          return [
            // first
            before ? before.nextSibling : parent.firstChild,
            // last
            anchor ? anchor.previousSibling : parent.lastChild
          ];
        }
      };
      const TRANSITION = "transition";
      const ANIMATION = "animation";
      const vtcKey = Symbol("_vtc");
      const DOMTransitionPropsValidators = {
        name: String,
        type: String,
        css: {
          type: Boolean,
          default: true
        },
        duration: [String, Number, Object],
        enterFromClass: String,
        enterActiveClass: String,
        enterToClass: String,
        appearFromClass: String,
        appearActiveClass: String,
        appearToClass: String,
        leaveFromClass: String,
        leaveActiveClass: String,
        leaveToClass: String
      };
      const TransitionPropsValidators = /* @__PURE__ */ extend(
        {},
        BaseTransitionPropsValidators,
        DOMTransitionPropsValidators
      );
      const decorate$1 = (t) => {
        t.displayName = "Transition";
        t.props = TransitionPropsValidators;
        return t;
      };
      const Transition = /* @__PURE__ */ decorate$1(
        (props, { slots }) => h(BaseTransition, resolveTransitionProps(props), slots)
      );
      const callHook = (hook, args = []) => {
        if (isArray(hook)) {
          hook.forEach((h2) => h2(...args));
        } else if (hook) {
          hook(...args);
        }
      };
      const hasExplicitCallback = (hook) => {
        return hook ? isArray(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
      };
      function resolveTransitionProps(rawProps) {
        const baseProps = {};
        for (const key in rawProps) {
          if (!(key in DOMTransitionPropsValidators)) {
            baseProps[key] = rawProps[key];
          }
        }
        if (rawProps.css === false) {
          return baseProps;
        }
        const {
          name = "v",
          type,
          duration,
          enterFromClass = `${name}-enter-from`,
          enterActiveClass = `${name}-enter-active`,
          enterToClass = `${name}-enter-to`,
          appearFromClass = enterFromClass,
          appearActiveClass = enterActiveClass,
          appearToClass = enterToClass,
          leaveFromClass = `${name}-leave-from`,
          leaveActiveClass = `${name}-leave-active`,
          leaveToClass = `${name}-leave-to`
        } = rawProps;
        const durations = normalizeDuration(duration);
        const enterDuration = durations && durations[0];
        const leaveDuration = durations && durations[1];
        const {
          onBeforeEnter,
          onEnter,
          onEnterCancelled,
          onLeave,
          onLeaveCancelled,
          onBeforeAppear = onBeforeEnter,
          onAppear = onEnter,
          onAppearCancelled = onEnterCancelled
        } = baseProps;
        const finishEnter = (el, isAppear, done, isCancelled) => {
          el._enterCancelled = isCancelled;
          removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
          removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
          done && done();
        };
        const finishLeave = (el, done) => {
          el._isLeaving = false;
          removeTransitionClass(el, leaveFromClass);
          removeTransitionClass(el, leaveToClass);
          removeTransitionClass(el, leaveActiveClass);
          done && done();
        };
        const makeEnterHook = (isAppear) => {
          return (el, done) => {
            const hook = isAppear ? onAppear : onEnter;
            const resolve = () => finishEnter(el, isAppear, done);
            callHook(hook, [el, resolve]);
            nextFrame(() => {
              removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
              addTransitionClass(el, isAppear ? appearToClass : enterToClass);
              if (!hasExplicitCallback(hook)) {
                whenTransitionEnds(el, type, enterDuration, resolve);
              }
            });
          };
        };
        return extend(baseProps, {
          onBeforeEnter(el) {
            callHook(onBeforeEnter, [el]);
            addTransitionClass(el, enterFromClass);
            addTransitionClass(el, enterActiveClass);
          },
          onBeforeAppear(el) {
            callHook(onBeforeAppear, [el]);
            addTransitionClass(el, appearFromClass);
            addTransitionClass(el, appearActiveClass);
          },
          onEnter: makeEnterHook(false),
          onAppear: makeEnterHook(true),
          onLeave(el, done) {
            el._isLeaving = true;
            const resolve = () => finishLeave(el, done);
            addTransitionClass(el, leaveFromClass);
            if (!el._enterCancelled) {
              forceReflow(el);
              addTransitionClass(el, leaveActiveClass);
            } else {
              addTransitionClass(el, leaveActiveClass);
              forceReflow(el);
            }
            nextFrame(() => {
              if (!el._isLeaving) {
                return;
              }
              removeTransitionClass(el, leaveFromClass);
              addTransitionClass(el, leaveToClass);
              if (!hasExplicitCallback(onLeave)) {
                whenTransitionEnds(el, type, leaveDuration, resolve);
              }
            });
            callHook(onLeave, [el, resolve]);
          },
          onEnterCancelled(el) {
            finishEnter(el, false, void 0, true);
            callHook(onEnterCancelled, [el]);
          },
          onAppearCancelled(el) {
            finishEnter(el, true, void 0, true);
            callHook(onAppearCancelled, [el]);
          },
          onLeaveCancelled(el) {
            finishLeave(el);
            callHook(onLeaveCancelled, [el]);
          }
        });
      }
      function normalizeDuration(duration) {
        if (duration == null) {
          return null;
        } else if (isObject(duration)) {
          return [NumberOf(duration.enter), NumberOf(duration.leave)];
        } else {
          const n = NumberOf(duration);
          return [n, n];
        }
      }
      function NumberOf(val) {
        const res = toNumber(val);
        return res;
      }
      function addTransitionClass(el, cls) {
        cls.split(/\s+/).forEach((c) => c && el.classList.add(c));
        (el[vtcKey] || (el[vtcKey] = /* @__PURE__ */ new Set())).add(cls);
      }
      function removeTransitionClass(el, cls) {
        cls.split(/\s+/).forEach((c) => c && el.classList.remove(c));
        const _vtc = el[vtcKey];
        if (_vtc) {
          _vtc.delete(cls);
          if (!_vtc.size) {
            el[vtcKey] = void 0;
          }
        }
      }
      function nextFrame(cb) {
        requestAnimationFrame(() => {
          requestAnimationFrame(cb);
        });
      }
      let endId = 0;
      function whenTransitionEnds(el, expectedType, explicitTimeout, resolve) {
        const id = el._endId = ++endId;
        const resolveIfNotStale = () => {
          if (id === el._endId) {
            resolve();
          }
        };
        if (explicitTimeout != null) {
          return setTimeout(resolveIfNotStale, explicitTimeout);
        }
        const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
        if (!type) {
          return resolve();
        }
        const endEvent = type + "end";
        let ended = 0;
        const end = () => {
          el.removeEventListener(endEvent, onEnd);
          resolveIfNotStale();
        };
        const onEnd = (e) => {
          if (e.target === el && ++ended >= propCount) {
            end();
          }
        };
        setTimeout(() => {
          if (ended < propCount) {
            end();
          }
        }, timeout + 1);
        el.addEventListener(endEvent, onEnd);
      }
      function getTransitionInfo(el, expectedType) {
        const styles = window.getComputedStyle(el);
        const getStyleProperties = (key) => (styles[key] || "").split(", ");
        const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
        const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
        const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
        const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
        const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
        const animationTimeout = getTimeout(animationDelays, animationDurations);
        let type = null;
        let timeout = 0;
        let propCount = 0;
        if (expectedType === TRANSITION) {
          if (transitionTimeout > 0) {
            type = TRANSITION;
            timeout = transitionTimeout;
            propCount = transitionDurations.length;
          }
        } else if (expectedType === ANIMATION) {
          if (animationTimeout > 0) {
            type = ANIMATION;
            timeout = animationTimeout;
            propCount = animationDurations.length;
          }
        } else {
          timeout = Math.max(transitionTimeout, animationTimeout);
          type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
          propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
        }
        const hasTransform = type === TRANSITION && /\b(?:transform|all)(?:,|$)/.test(
          getStyleProperties(`${TRANSITION}Property`).toString()
        );
        return {
          type,
          timeout,
          propCount,
          hasTransform
        };
      }
      function getTimeout(delays, durations) {
        while (delays.length < durations.length) {
          delays = delays.concat(delays);
        }
        return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));
      }
      function toMs(s) {
        if (s === "auto") return 0;
        return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
      }
      function forceReflow(el) {
        const targetDocument = el ? el.ownerDocument : document;
        return targetDocument.body.offsetHeight;
      }
      function patchClass(el, value, isSVG) {
        const transitionClasses = el[vtcKey];
        if (transitionClasses) {
          value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
        }
        if (value == null) {
          el.removeAttribute("class");
        } else if (isSVG) {
          el.setAttribute("class", value);
        } else {
          el.className = value;
        }
      }
      const vShowOriginalDisplay = Symbol("_vod");
      const vShowHidden = Symbol("_vsh");
      const CSS_VAR_TEXT = Symbol("");
      const displayRE = /(?:^|;)\s*display\s*:/;
      function patchStyle(el, prev, next) {
        const style = el.style;
        const isCssString = isString(next);
        let hasControlledDisplay = false;
        if (next && !isCssString) {
          if (prev) {
            if (!isString(prev)) {
              for (const key in prev) {
                if (next[key] == null) {
                  setStyle(style, key, "");
                }
              }
            } else {
              for (const prevStyle of prev.split(";")) {
                const key = prevStyle.slice(0, prevStyle.indexOf(":")).trim();
                if (next[key] == null) {
                  setStyle(style, key, "");
                }
              }
            }
          }
          for (const key in next) {
            if (key === "display") {
              hasControlledDisplay = true;
            }
            setStyle(style, key, next[key]);
          }
        } else {
          if (isCssString) {
            if (prev !== next) {
              const cssVarText = style[CSS_VAR_TEXT];
              if (cssVarText) {
                next += ";" + cssVarText;
              }
              style.cssText = next;
              hasControlledDisplay = displayRE.test(next);
            }
          } else if (prev) {
            el.removeAttribute("style");
          }
        }
        if (vShowOriginalDisplay in el) {
          el[vShowOriginalDisplay] = hasControlledDisplay ? style.display : "";
          if (el[vShowHidden]) {
            style.display = "none";
          }
        }
      }
      const importantRE = /\s*!important$/;
      function setStyle(style, name, val) {
        if (isArray(val)) {
          val.forEach((v) => setStyle(style, name, v));
        } else {
          if (val == null) val = "";
          if (name.startsWith("--")) {
            style.setProperty(name, val);
          } else {
            const prefixed = autoPrefix(style, name);
            if (importantRE.test(val)) {
              style.setProperty(
                hyphenate(prefixed),
                val.replace(importantRE, ""),
                "important"
              );
            } else {
              style[prefixed] = val;
            }
          }
        }
      }
      const prefixes = ["Webkit", "Moz", "ms"];
      const prefixCache = {};
      function autoPrefix(style, rawName) {
        const cached = prefixCache[rawName];
        if (cached) {
          return cached;
        }
        let name = camelize(rawName);
        if (name !== "filter" && name in style) {
          return prefixCache[rawName] = name;
        }
        name = capitalize(name);
        for (let i = 0; i < prefixes.length; i++) {
          const prefixed = prefixes[i] + name;
          if (prefixed in style) {
            return prefixCache[rawName] = prefixed;
          }
        }
        return rawName;
      }
      const xlinkNS = "http://www.w3.org/1999/xlink";
      function patchAttr(el, key, value, isSVG, instance, isBoolean = isSpecialBooleanAttr(key)) {
        if (isSVG && key.startsWith("xlink:")) {
          if (value == null) {
            el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
          } else {
            el.setAttributeNS(xlinkNS, key, value);
          }
        } else {
          if (value == null || isBoolean && !includeBooleanAttr(value)) {
            el.removeAttribute(key);
          } else {
            el.setAttribute(
              key,
              isBoolean ? "" : isSymbol(value) ? String(value) : value
            );
          }
        }
      }
      function patchDOMProp(el, key, value, parentComponent, attrName) {
        if (key === "innerHTML" || key === "textContent") {
          if (value != null) {
            el[key] = key === "innerHTML" ? unsafeToTrustedHTML(value) : value;
          }
          return;
        }
        const tag = el.tagName;
        if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
        !tag.includes("-")) {
          const oldValue = tag === "OPTION" ? el.getAttribute("value") || "" : el.value;
          const newValue = value == null ? (
            // #11647: value should be set as empty string for null and undefined,
            // but <input type="checkbox"> should be set as 'on'.
            el.type === "checkbox" ? "on" : ""
          ) : String(value);
          if (oldValue !== newValue || !("_value" in el)) {
            el.value = newValue;
          }
          if (value == null) {
            el.removeAttribute(key);
          }
          el._value = value;
          return;
        }
        let needRemove = false;
        if (value === "" || value == null) {
          const type = typeof el[key];
          if (type === "boolean") {
            value = includeBooleanAttr(value);
          } else if (value == null && type === "string") {
            value = "";
            needRemove = true;
          } else if (type === "number") {
            value = 0;
            needRemove = true;
          }
        }
        try {
          el[key] = value;
        } catch (e) {
        }
        needRemove && el.removeAttribute(attrName || key);
      }
      function addEventListener(el, event, handler, options) {
        el.addEventListener(event, handler, options);
      }
      function removeEventListener(el, event, handler, options) {
        el.removeEventListener(event, handler, options);
      }
      const veiKey = Symbol("_vei");
      function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
        const invokers = el[veiKey] || (el[veiKey] = {});
        const existingInvoker = invokers[rawName];
        if (nextValue && existingInvoker) {
          existingInvoker.value = nextValue;
        } else {
          const [name, options] = parseName(rawName);
          if (nextValue) {
            const invoker = invokers[rawName] = createInvoker(
              nextValue,
              instance
            );
            addEventListener(el, name, invoker, options);
          } else if (existingInvoker) {
            removeEventListener(el, name, existingInvoker, options);
            invokers[rawName] = void 0;
          }
        }
      }
      const optionsModifierRE = /(?:Once|Passive|Capture)$/;
      function parseName(name) {
        let options;
        if (optionsModifierRE.test(name)) {
          options = {};
          let m;
          while (m = name.match(optionsModifierRE)) {
            name = name.slice(0, name.length - m[0].length);
            options[m[0].toLowerCase()] = true;
          }
        }
        const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
        return [event, options];
      }
      let cachedNow = 0;
      const p = /* @__PURE__ */ Promise.resolve();
      const getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());
      function createInvoker(initialValue, instance) {
        const invoker = (e) => {
          if (!e._vts) {
            e._vts = Date.now();
          } else if (e._vts <= invoker.attached) {
            return;
          }
          callWithAsyncErrorHandling(
            patchStopImmediatePropagation(e, invoker.value),
            instance,
            5,
            [e]
          );
        };
        invoker.value = initialValue;
        invoker.attached = getNow();
        return invoker;
      }
      function patchStopImmediatePropagation(e, value) {
        if (isArray(value)) {
          const originalStop = e.stopImmediatePropagation;
          e.stopImmediatePropagation = () => {
            originalStop.call(e);
            e._stopped = true;
          };
          return value.map(
            (fn) => (e2) => !e2._stopped && fn && fn(e2)
          );
        } else {
          return value;
        }
      }
      const isNativeOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // lowercase letter
      key.charCodeAt(2) > 96 && key.charCodeAt(2) < 123;
      const patchProp = (el, key, prevValue, nextValue, namespace, parentComponent) => {
        const isSVG = namespace === "svg";
        if (key === "class") {
          patchClass(el, nextValue, isSVG);
        } else if (key === "style") {
          patchStyle(el, prevValue, nextValue);
        } else if (isOn(key)) {
          if (!isModelListener(key)) {
            patchEvent(el, key, prevValue, nextValue, parentComponent);
          }
        } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
          patchDOMProp(el, key, nextValue);
          if (!el.tagName.includes("-") && (key === "value" || key === "checked" || key === "selected")) {
            patchAttr(el, key, nextValue, isSVG, parentComponent, key !== "value");
          }
        } else if (
          // #11081 force set props for possible async custom element
          el._isVueCE && (/[A-Z]/.test(key) || !isString(nextValue))
        ) {
          patchDOMProp(el, camelize(key), nextValue, parentComponent, key);
        } else {
          if (key === "true-value") {
            el._trueValue = nextValue;
          } else if (key === "false-value") {
            el._falseValue = nextValue;
          }
          patchAttr(el, key, nextValue, isSVG);
        }
      };
      function shouldSetAsProp(el, key, value, isSVG) {
        if (isSVG) {
          if (key === "innerHTML" || key === "textContent") {
            return true;
          }
          if (key in el && isNativeOn(key) && isFunction(value)) {
            return true;
          }
          return false;
        }
        if (key === "spellcheck" || key === "draggable" || key === "translate" || key === "autocorrect") {
          return false;
        }
        if (key === "form") {
          return false;
        }
        if (key === "list" && el.tagName === "INPUT") {
          return false;
        }
        if (key === "type" && el.tagName === "TEXTAREA") {
          return false;
        }
        if (key === "width" || key === "height") {
          const tag = el.tagName;
          if (tag === "IMG" || tag === "VIDEO" || tag === "CANVAS" || tag === "SOURCE") {
            return false;
          }
        }
        if (isNativeOn(key) && isString(value)) {
          return false;
        }
        return key in el;
      }
      const getModelAssigner = (vnode) => {
        const fn = vnode.props["onUpdate:modelValue"] || false;
        return isArray(fn) ? (value) => invokeArrayFns(fn, value) : fn;
      };
      function onCompositionStart(e) {
        e.target.composing = true;
      }
      function onCompositionEnd(e) {
        const target = e.target;
        if (target.composing) {
          target.composing = false;
          target.dispatchEvent(new Event("input"));
        }
      }
      const assignKey = Symbol("_assign");
      const vModelText = {
        created(el, { modifiers: { lazy, trim, number } }, vnode) {
          el[assignKey] = getModelAssigner(vnode);
          const castToNumber = number || vnode.props && vnode.props.type === "number";
          addEventListener(el, lazy ? "change" : "input", (e) => {
            if (e.target.composing) return;
            let domValue = el.value;
            if (trim) {
              domValue = domValue.trim();
            }
            if (castToNumber) {
              domValue = looseToNumber(domValue);
            }
            el[assignKey](domValue);
          });
          if (trim) {
            addEventListener(el, "change", () => {
              el.value = el.value.trim();
            });
          }
          if (!lazy) {
            addEventListener(el, "compositionstart", onCompositionStart);
            addEventListener(el, "compositionend", onCompositionEnd);
            addEventListener(el, "change", onCompositionEnd);
          }
        },
        // set value on mounted so it's after min/max for type="range"
        mounted(el, { value }) {
          el.value = value == null ? "" : value;
        },
        beforeUpdate(el, { value, oldValue, modifiers: { lazy, trim, number } }, vnode) {
          el[assignKey] = getModelAssigner(vnode);
          if (el.composing) return;
          const elValue = (number || el.type === "number") && !/^0\d/.test(el.value) ? looseToNumber(el.value) : el.value;
          const newValue = value == null ? "" : value;
          if (elValue === newValue) {
            return;
          }
          if (document.activeElement === el && el.type !== "range") {
            if (lazy && value === oldValue) {
              return;
            }
            if (trim && el.value.trim() === newValue) {
              return;
            }
          }
          el.value = newValue;
        }
      };
      const vModelCheckbox = {
        // #4096 array checkboxes need to be deep traversed
        deep: true,
        created(el, _, vnode) {
          el[assignKey] = getModelAssigner(vnode);
          addEventListener(el, "change", () => {
            const modelValue = el._modelValue;
            const elementValue = getValue(el);
            const checked = el.checked;
            const assign = el[assignKey];
            if (isArray(modelValue)) {
              const index = looseIndexOf(modelValue, elementValue);
              const found = index !== -1;
              if (checked && !found) {
                assign(modelValue.concat(elementValue));
              } else if (!checked && found) {
                const filtered = [...modelValue];
                filtered.splice(index, 1);
                assign(filtered);
              }
            } else if (isSet(modelValue)) {
              const cloned = new Set(modelValue);
              if (checked) {
                cloned.add(elementValue);
              } else {
                cloned.delete(elementValue);
              }
              assign(cloned);
            } else {
              assign(getCheckboxValue(el, checked));
            }
          });
        },
        // set initial checked on mount to wait for true-value/false-value
        mounted: setChecked,
        beforeUpdate(el, binding, vnode) {
          el[assignKey] = getModelAssigner(vnode);
          setChecked(el, binding, vnode);
        }
      };
      function setChecked(el, { value, oldValue }, vnode) {
        el._modelValue = value;
        let checked;
        if (isArray(value)) {
          checked = looseIndexOf(value, vnode.props.value) > -1;
        } else if (isSet(value)) {
          checked = value.has(vnode.props.value);
        } else {
          if (value === oldValue) return;
          checked = looseEqual(value, getCheckboxValue(el, true));
        }
        if (el.checked !== checked) {
          el.checked = checked;
        }
      }
      function getValue(el) {
        return "_value" in el ? el._value : el.value;
      }
      function getCheckboxValue(el, checked) {
        const key = checked ? "_trueValue" : "_falseValue";
        return key in el ? el[key] : checked;
      }
      const systemModifiers = ["ctrl", "shift", "alt", "meta"];
      const modifierGuards = {
        stop: (e) => e.stopPropagation(),
        prevent: (e) => e.preventDefault(),
        self: (e) => e.target !== e.currentTarget,
        ctrl: (e) => !e.ctrlKey,
        shift: (e) => !e.shiftKey,
        alt: (e) => !e.altKey,
        meta: (e) => !e.metaKey,
        left: (e) => "button" in e && e.button !== 0,
        middle: (e) => "button" in e && e.button !== 1,
        right: (e) => "button" in e && e.button !== 2,
        exact: (e, modifiers) => systemModifiers.some((m) => e[`${m}Key`] && !modifiers.includes(m))
      };
      const withModifiers = (fn, modifiers) => {
        const cache = fn._withMods || (fn._withMods = {});
        const cacheKey = modifiers.join(".");
        return cache[cacheKey] || (cache[cacheKey] = (event, ...args) => {
          for (let i = 0; i < modifiers.length; i++) {
            const guard = modifierGuards[modifiers[i]];
            if (guard && guard(event, modifiers)) return;
          }
          return fn(event, ...args);
        });
      };
      const rendererOptions = /* @__PURE__ */ extend({ patchProp }, nodeOps);
      let renderer;
      function ensureRenderer() {
        return renderer || (renderer = createRenderer(rendererOptions));
      }
      const createApp = (...args) => {
        const app = ensureRenderer().createApp(...args);
        const { mount } = app;
        app.mount = (containerOrSelector) => {
          const container = normalizeContainer(containerOrSelector);
          if (!container) return;
          const component = app._component;
          if (!isFunction(component) && !component.render && !component.template) {
            component.template = container.innerHTML;
          }
          if (container.nodeType === 1) {
            container.textContent = "";
          }
          const proxy = mount(container, false, resolveRootNamespace(container));
          if (container instanceof Element) {
            container.removeAttribute("v-cloak");
            container.setAttribute("data-v-app", "");
          }
          return proxy;
        };
        return app;
      };
      function resolveRootNamespace(container) {
        if (container instanceof SVGElement) {
          return "svg";
        }
        if (typeof MathMLElement === "function" && container instanceof MathMLElement) {
          return "mathml";
        }
      }
      function normalizeContainer(container) {
        if (isString(container)) {
          const res = document.querySelector(container);
          return res;
        }
        return container;
      }

      const _export_sfc = (sfc, props) => {
        const target = sfc.__vccOpts || sfc;
        for (const [key, val] of props) {
          target[key] = val;
        }
        return target;
      };

      const _hoisted_1$8 = { class: "window-content" };


      const _sfc_main$9 = {
        __name: 'FloatingWindow',
        props: {
        isVisible: {
          type: Boolean,
          default: false
        },
        title: {
          type: String,
          default: 'Beeline Helper'
        },
        showBackButton: {
          type: Boolean,
          default: false
        },
        autoAnswerMode: {
          type: Boolean,
          default: false
        },
        initialPosition: {
          type: Object,
          default: () => ({
            top: window.innerHeight / 2 - 150,
            left: 20 // 移动到屏幕左侧
          })
        }
      },
        emits: ['close', 'back'],
        setup(__props, { emit: __emit }) {

      const floatingWindow = ref(null);
      const isDragging = ref(false);
      const dragOffset = reactive({ x: 0, y: 0 });
      const position = reactive({
        top: 20, // 固定在顶部
        left: 20 // 固定在左侧
      });

      const startDrag = (e) => {
        isDragging.value = true;

        const rect = floatingWindow.value.getBoundingClientRect();
        if (e.type === 'mousedown') {
          dragOffset.x = e.clientX - rect.left;
          dragOffset.y = e.clientY - rect.top;
        } else if (e.type === 'touchstart') {
          const touch = e.touches[0];
          dragOffset.x = touch.clientX - rect.left;
          dragOffset.y = touch.clientY - rect.top;
        }

        e.preventDefault();
      };

      const onDrag = (e) => {
        if (!isDragging.value) return

        let clientX, clientY;
        if (e.type === 'mousemove') {
          clientX = e.clientX;
          clientY = e.clientY;
        } else if (e.type === 'touchmove') {
          const touch = e.touches[0];
          clientX = touch.clientX;
          clientY = touch.clientY;
        }

        const newLeft = clientX - dragOffset.x;
        const newTop = clientY - dragOffset.y;

        const windowWidth = floatingWindow.value.offsetWidth;
        const windowHeight = floatingWindow.value.offsetHeight;

        // 使用requestAnimationFrame优化性能
        requestAnimationFrame(() => {
          position.left = Math.max(0, Math.min(newLeft, window.innerWidth - windowWidth));
          position.top = Math.max(0, Math.min(newTop, window.innerHeight - windowHeight));
        });

        e.preventDefault();
      };

      const stopDrag = () => {
        isDragging.value = false;
      };

      onMounted(() => {
        document.addEventListener('mousemove', onDrag);
        document.addEventListener('mouseup', stopDrag);
        document.addEventListener('touchmove', onDrag, { passive: false });
        document.addEventListener('touchend', stopDrag);
      });

      onUnmounted(() => {
        document.removeEventListener('mousemove', onDrag);
        document.removeEventListener('mouseup', stopDrag);
        document.removeEventListener('touchmove', onDrag);
        document.removeEventListener('touchend', stopDrag);
      });

      return (_ctx, _cache) => {
        return (__props.isVisible)
          ? (openBlock(), createElementBlock("div", {
              key: 0,
              ref_key: "floatingWindow",
              ref: floatingWindow,
              class: normalizeClass(["floating-window", { 'window-hidden': !__props.isVisible, 'auto-answer-mode': __props.autoAnswerMode }]),
              style: normalizeStyle({
            top: position.top + 'px',
            left: position.left + 'px',
            transform: 'none',
            willChange: isDragging.value ? 'transform' : 'auto'
          })
            }, [
              createBaseVNode("div", {
                class: "window-header",
                onMousedown: startDrag,
                onTouchstart: startDrag
              }, [
                (__props.showBackButton)
                  ? (openBlock(), createElementBlock("button", {
                      key: 0,
                      class: "back-btn",
                      onClick: _cache[0] || (_cache[0] = $event => (_ctx.$emit('back')))
                    }, "←"))
                  : createCommentVNode("", true),
                createBaseVNode("h3", null, toDisplayString(__props.title), 1),
                createBaseVNode("button", {
                  class: "close-btn",
                  onClick: _cache[1] || (_cache[1] = $event => (_ctx.$emit('close')))
                }, "×")
              ], 32),
              createBaseVNode("div", _hoisted_1$8, [
                renderSlot(_ctx.$slots, "default", {}, undefined)
              ])
            ], 6))
          : createCommentVNode("", true)
      }
      }

      };
      const FloatingWindow = /*#__PURE__*/_export_sfc(_sfc_main$9, [['__scopeId',"data-v-1f178cdb"]]);

      const _hoisted_1$7 = { class: "status-window" };
      const _hoisted_2$6 = { class: "status-content" };
      const _hoisted_3$6 = { class: "current-status" };
      const _hoisted_4$6 = { class: "operation-history" };
      const _hoisted_5$6 = { class: "history-list" };
      const _hoisted_6$5 = { class: "history-time" };
      const _hoisted_7$5 = { class: "history-message" };
      const _hoisted_8$5 = {
        key: 0,
        class: "no-history"
      };


      const _sfc_main$8 = {
        __name: 'StatusWindow',
        props: {
        currentStatus: {
          type: String,
          default: '未启动'
        },
        operationHistory: {
          type: Array,
          default: () => []
        }
      },
        setup(__props) {

      const getStatusClass = (status) => {
        const statusClasses = {
          '检测中...': 'status-detecting',
          '检测到按钮，等待点击...': 'status-waiting',
          '已点击完成按钮': 'status-success',
          '未检测到按钮': 'status-no-button',
          '已停止': 'status-stopped'
        };
        return statusClasses[status] || ''
      };

      return (_ctx, _cache) => {
        return (openBlock(), createElementBlock("div", _hoisted_1$7, [
          _cache[2] || (_cache[2] = createBaseVNode("div", { class: "status-header" }, [
            createBaseVNode("span", { class: "status-title" }, "操作日志")
          ], -1)),
          createBaseVNode("div", _hoisted_2$6, [
            createBaseVNode("div", _hoisted_3$6, [
              _cache[0] || (_cache[0] = createBaseVNode("span", { class: "status-label" }, "当前状态：", -1)),
              createBaseVNode("span", {
                class: normalizeClass(["status-value", getStatusClass(__props.currentStatus)])
              }, toDisplayString(__props.currentStatus), 3)
            ]),
            createBaseVNode("div", _hoisted_4$6, [
              _cache[1] || (_cache[1] = createBaseVNode("div", { class: "history-title" }, "操作历史", -1)),
              createBaseVNode("div", _hoisted_5$6, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(__props.operationHistory, (item, index) => {
                  return (openBlock(), createElementBlock("div", {
                    key: index,
                    class: "history-item"
                  }, [
                    createBaseVNode("span", _hoisted_6$5, toDisplayString(item.time), 1),
                    createBaseVNode("span", _hoisted_7$5, toDisplayString(item.message), 1)
                  ]))
                }), 128)),
                (__props.operationHistory.length === 0)
                  ? (openBlock(), createElementBlock("div", _hoisted_8$5, " 暂无操作记录 "))
                  : createCommentVNode("", true)
              ])
            ])
          ])
        ]))
      }
      }

      };
      const StatusWindow = /*#__PURE__*/_export_sfc(_sfc_main$8, [['__scopeId',"data-v-99aa1d36"]]);

      const _sfc_main$7 = {
        __name: 'ControlButton',
        props: {
        isWindowVisible: {
          type: Boolean,
          default: false
        }
      },
        emits: ['click'],
        setup(__props) {





      return (_ctx, _cache) => {
        return (openBlock(), createElementBlock("div", {
          class: normalizeClass(["control-button", { 'button-hidden': __props.isWindowVisible }]),
          onClick: _cache[0] || (_cache[0] = $event => (_ctx.$emit('click')))
        }, [...(_cache[1] || (_cache[1] = [
          createBaseVNode("span", { class: "button-icon" }, "🔧", -1)
        ]))], 2))
      }
      }

      };
      const ControlButton = /*#__PURE__*/_export_sfc(_sfc_main$7, [['__scopeId',"data-v-29767e33"]]);

      const _hoisted_1$6 = { class: "features" };


      const _sfc_main$6 = {
        __name: 'MainPage',
        emits: ['navigate', 'open-about'],
        setup(__props) {



      return (_ctx, _cache) => {
        return (openBlock(), createElementBlock("div", null, [
          _cache[4] || (_cache[4] = createBaseVNode("p", null, "欢迎使用 Beeline Helper！", -1)),
          createBaseVNode("div", _hoisted_1$6, [
            createBaseVNode("button", {
              class: "feature-btn",
              onClick: _cache[0] || (_cache[0] = $event => (_ctx.$emit('navigate', 'auto-course')))
            }, "全自动刷课配置"),
            createBaseVNode("button", {
              class: "feature-btn",
              onClick: _cache[1] || (_cache[1] = $event => (_ctx.$emit('navigate', 'auto-answer')))
            }, "自动答题"),
            createBaseVNode("button", {
              class: "feature-btn",
              onClick: _cache[2] || (_cache[2] = $event => (_ctx.$emit('navigate', 'advanced-settings')))
            }, "高级设置"),
            createBaseVNode("button", {
              class: "feature-btn",
              onClick: _cache[3] || (_cache[3] = $event => (_ctx.$emit('open-about')))
            }, "关于")
          ])
        ]))
      }
      }

      };
      const MainPage = /*#__PURE__*/_export_sfc(_sfc_main$6, [['__scopeId',"data-v-fb2a58e0"]]);

      const _hoisted_1$5 = { class: "toggle-features" };
      const _hoisted_2$5 = { class: "toggle-item" };
      const _hoisted_3$5 = { class: "toggle-switch" };
      const _hoisted_4$5 = ["checked"];
      const _hoisted_5$5 = { class: "toggle-item" };
      const _hoisted_6$4 = { class: "toggle-switch" };
      const _hoisted_7$4 = ["checked"];
      const _hoisted_8$4 = { class: "toggle-item" };
      const _hoisted_9$3 = { class: "toggle-switch" };
      const _hoisted_10$3 = ["checked"];


      const _sfc_main$5 = {
        __name: 'AutoCoursePage',
        props: {
        autoCompleteEnabled: {
          type: Boolean,
          default: false
        },
        autoMuteEnabled: {
          type: Boolean,
          default: false
        },
        FxxKXinWeiEnabled: {
          type: Boolean,
          default: false
        }
      },
        emits: ['toggle-auto-complete', 'toggle-auto-mute', 'toggle-FxxK-xin-wei'],
        setup(__props) {

      const props = __props;



      return (_ctx, _cache) => {
        return (openBlock(), createElementBlock("div", null, [
          createBaseVNode("div", _hoisted_1$5, [
            createBaseVNode("div", _hoisted_2$5, [
              _cache[4] || (_cache[4] = createBaseVNode("span", { class: "toggle-label" }, "自动点击下一集", -1)),
              createBaseVNode("label", _hoisted_3$5, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: props.autoCompleteEnabled,
                  onChange: _cache[0] || (_cache[0] = $event => (_ctx.$emit('toggle-auto-complete', !props.autoCompleteEnabled)))
                }, null, 40, _hoisted_4$5),
                _cache[3] || (_cache[3] = createBaseVNode("span", { class: "toggle-slider" }, null, -1))
              ])
            ]),
            createBaseVNode("div", _hoisted_5$5, [
              _cache[6] || (_cache[6] = createBaseVNode("span", { class: "toggle-label" }, "自动静音", -1)),
              createBaseVNode("label", _hoisted_6$4, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: props.autoMuteEnabled,
                  onChange: _cache[1] || (_cache[1] = $event => (_ctx.$emit('toggle-auto-mute', !props.autoMuteEnabled)))
                }, null, 40, _hoisted_7$4),
                _cache[5] || (_cache[5] = createBaseVNode("span", { class: "toggle-slider" }, null, -1))
              ])
            ]),
            createBaseVNode("div", _hoisted_8$4, [
              _cache[8] || (_cache[8] = createBaseVNode("span", { class: "toggle-label FxxK-xin-wei" }, "FxxK XinWei", -1)),
              createBaseVNode("label", _hoisted_9$3, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: props.FxxKXinWeiEnabled,
                  onChange: _cache[2] || (_cache[2] = $event => (_ctx.$emit('toggle-FxxK-xin-wei', !props.FxxKXinWeiEnabled)))
                }, null, 40, _hoisted_10$3),
                _cache[7] || (_cache[7] = createBaseVNode("span", { class: "toggle-slider" }, null, -1))
              ])
            ])
          ])
        ]))
      }
      }

      };
      const AutoCoursePage = /*#__PURE__*/_export_sfc(_sfc_main$5, [['__scopeId',"data-v-3bb0b416"]]);

      const _imports_0$1 = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='95'%20height='88'%20fill='none'%3e%3cpath%20fill='%23FFD21E'%20d='M47.21%2076.5a34.75%2034.75%200%201%200%200-69.5%2034.75%2034.75%200%200%200%200%2069.5Z'%20/%3e%3cpath%20fill='%23FF9D0B'%20d='M81.96%2041.75a34.75%2034.75%200%201%200-69.5%200%2034.75%2034.75%200%200%200%2069.5%200Zm-73.5%200a38.75%2038.75%200%201%201%2077.5%200%2038.75%2038.75%200%200%201-77.5%200Z'%20/%3e%3cpath%20fill='%233A3B45'%20d='M58.5%2032.3c1.28.44%201.78%203.06%203.07%202.38a5%205%200%201%200-6.76-2.07c.61%201.15%202.55-.72%203.7-.32ZM34.95%2032.3c-1.28.44-1.79%203.06-3.07%202.38a5%205%200%201%201%206.76-2.07c-.61%201.15-2.56-.72-3.7-.32Z'%20/%3e%3cpath%20fill='%23FF323D'%20d='M46.96%2056.29c9.83%200%2013-8.76%2013-13.26%200-2.34-1.57-1.6-4.09-.36-2.33%201.15-5.46%202.74-8.9%202.74-7.19%200-13-6.88-13-2.38s3.16%2013.26%2013%2013.26Z'%20/%3e%3cpath%20fill='%233A3B45'%20fill-rule='evenodd'%20d='M39.43%2054a8.7%208.7%200%200%201%205.3-4.49c.4-.12.81.57%201.24%201.28.4.68.82%201.37%201.24%201.37.45%200%20.9-.68%201.33-1.35.45-.7.89-1.38%201.32-1.25a8.61%208.61%200%200%201%205%204.17c3.73-2.94%205.1-7.74%205.1-10.7%200-2.34-1.57-1.6-4.09-.36l-.14.07c-2.31%201.15-5.39%202.67-8.77%202.67s-6.45-1.52-8.77-2.67c-2.6-1.29-4.23-2.1-4.23.29%200%203.05%201.46%208.06%205.47%2010.97Z'%20clip-rule='evenodd'%20/%3e%3cpath%20fill='%23FF9D0B'%20d='M70.71%2037a3.25%203.25%200%201%200%200-6.5%203.25%203.25%200%200%200%200%206.5ZM24.21%2037a3.25%203.25%200%201%200%200-6.5%203.25%203.25%200%200%200%200%206.5ZM17.52%2048c-1.62%200-3.06.66-4.07%201.87a5.97%205.97%200%200%200-1.33%203.76%207.1%207.1%200%200%200-1.94-.3c-1.55%200-2.95.59-3.94%201.66a5.8%205.8%200%200%200-.8%207%205.3%205.3%200%200%200-1.79%202.82c-.24.9-.48%202.8.8%204.74a5.22%205.22%200%200%200-.37%205.02c1.02%202.32%203.57%204.14%208.52%206.1%203.07%201.22%205.89%202%205.91%202.01a44.33%2044.33%200%200%200%2010.93%201.6c5.86%200%2010.05-1.8%2012.46-5.34%203.88-5.69%203.33-10.9-1.7-15.92-2.77-2.78-4.62-6.87-5-7.77-.78-2.66-2.84-5.62-6.25-5.62a5.7%205.7%200%200%200-4.6%202.46c-1-1.26-1.98-2.25-2.86-2.82A7.4%207.4%200%200%200%2017.52%2048Zm0%204c.51%200%201.14.22%201.82.65%202.14%201.36%206.25%208.43%207.76%2011.18.5.92%201.37%201.31%202.14%201.31%201.55%200%202.75-1.53.15-3.48-3.92-2.93-2.55-7.72-.68-8.01.08-.02.17-.02.24-.02%201.7%200%202.45%202.93%202.45%202.93s2.2%205.52%205.98%209.3c3.77%203.77%203.97%206.8%201.22%2010.83-1.88%202.75-5.47%203.58-9.16%203.58-3.81%200-7.73-.9-9.92-1.46-.11-.03-13.45-3.8-11.76-7%20.28-.54.75-.76%201.34-.76%202.38%200%206.7%203.54%208.57%203.54.41%200%20.7-.17.83-.6.79-2.85-12.06-4.05-10.98-8.17.2-.73.71-1.02%201.44-1.02%203.14%200%2010.2%205.53%2011.68%205.53.11%200%20.2-.03.24-.1.74-1.2.33-2.04-4.9-5.2-5.21-3.16-8.88-5.06-6.8-7.33.24-.26.58-.38%201-.38%203.17%200%2010.66%206.82%2010.66%206.82s2.02%202.1%203.25%202.1c.28%200%20.52-.1.68-.38.86-1.46-8.06-8.22-8.56-11.01-.34-1.9.24-2.85%201.31-2.85Z'%20/%3e%3cpath%20fill='%23FFD21E'%20d='M38.6%2076.69c2.75-4.04%202.55-7.07-1.22-10.84-3.78-3.77-5.98-9.3-5.98-9.3s-.82-3.2-2.69-2.9c-1.87.3-3.24%205.08.68%208.01%203.91%202.93-.78%204.92-2.29%202.17-1.5-2.75-5.62-9.82-7.76-11.18-2.13-1.35-3.63-.6-3.13%202.2.5%202.79%209.43%209.55%208.56%2011-.87%201.47-3.93-1.71-3.93-1.71s-9.57-8.71-11.66-6.44c-2.08%202.27%201.59%204.17%206.8%207.33%205.23%203.16%205.64%204%204.9%205.2-.75%201.2-12.28-8.53-13.36-4.4-1.08%204.11%2011.77%205.3%2010.98%208.15-.8%202.85-9.06-5.38-10.74-2.18-1.7%203.21%2011.65%206.98%2011.76%207.01%204.3%201.12%2015.25%203.49%2019.08-2.12Z'%20/%3e%3cpath%20fill='%23FF9D0B'%20d='M77.4%2048c1.62%200%203.07.66%204.07%201.87a5.97%205.97%200%200%201%201.33%203.76%207.1%207.1%200%200%201%201.95-.3c1.55%200%202.95.59%203.94%201.66a5.8%205.8%200%200%201%20.8%207%205.3%205.3%200%200%201%201.78%202.82c.24.9.48%202.8-.8%204.74a5.22%205.22%200%200%201%20.37%205.02c-1.02%202.32-3.57%204.14-8.51%206.1-3.08%201.22-5.9%202-5.92%202.01a44.33%2044.33%200%200%201-10.93%201.6c-5.86%200-10.05-1.8-12.46-5.34-3.88-5.69-3.33-10.9%201.7-15.92%202.78-2.78%204.63-6.87%205.01-7.77.78-2.66%202.83-5.62%206.24-5.62a5.7%205.7%200%200%201%204.6%202.46c1-1.26%201.98-2.25%202.87-2.82A7.4%207.4%200%200%201%2077.4%2048Zm0%204c-.51%200-1.13.22-1.82.65-2.13%201.36-6.25%208.43-7.76%2011.18a2.43%202.43%200%200%201-2.14%201.31c-1.54%200-2.75-1.53-.14-3.48%203.91-2.93%202.54-7.72.67-8.01a1.54%201.54%200%200%200-.24-.02c-1.7%200-2.45%202.93-2.45%202.93s-2.2%205.52-5.97%209.3c-3.78%203.77-3.98%206.8-1.22%2010.83%201.87%202.75%205.47%203.58%209.15%203.58%203.82%200%207.73-.9%209.93-1.46.1-.03%2013.45-3.8%2011.76-7-.29-.54-.75-.76-1.34-.76-2.38%200-6.71%203.54-8.57%203.54-.42%200-.71-.17-.83-.6-.8-2.85%2012.05-4.05%2010.97-8.17-.19-.73-.7-1.02-1.44-1.02-3.14%200-10.2%205.53-11.68%205.53-.1%200-.19-.03-.23-.1-.74-1.2-.34-2.04%204.88-5.2%205.23-3.16%208.9-5.06%206.8-7.33-.23-.26-.57-.38-.98-.38-3.18%200-10.67%206.82-10.67%206.82s-2.02%202.1-3.24%202.1a.74.74%200%200%201-.68-.38c-.87-1.46%208.05-8.22%208.55-11.01.34-1.9-.24-2.85-1.31-2.85Z'%20/%3e%3cpath%20fill='%23FFD21E'%20d='M56.33%2076.69c-2.75-4.04-2.56-7.07%201.22-10.84%203.77-3.77%205.97-9.3%205.97-9.3s.82-3.2%202.7-2.9c1.86.3%203.23%205.08-.68%208.01-3.92%202.93.78%204.92%202.28%202.17%201.51-2.75%205.63-9.82%207.76-11.18%202.13-1.35%203.64-.6%203.13%202.2-.5%202.79-9.42%209.55-8.55%2011%20.86%201.47%203.92-1.71%203.92-1.71s9.58-8.71%2011.66-6.44c2.08%202.27-1.58%204.17-6.8%207.33-5.23%203.16-5.63%204-4.9%205.2.75%201.2%2012.28-8.53%2013.36-4.4%201.08%204.11-11.76%205.3-10.97%208.15.8%202.85%209.05-5.38%2010.74-2.18%201.69%203.21-11.65%206.98-11.76%207.01-4.31%201.12-15.26%203.49-19.08-2.12Z'%20/%3e%3c/svg%3e";

      // src/native/alias.ts
      var _GM_getValue = /* @__PURE__ */ (() => typeof GM_getValue != "undefined" ? GM_getValue : void 0)();
      var _GM_setValue = /* @__PURE__ */ (() => typeof GM_setValue != "undefined" ? GM_setValue : void 0)();

      /**
       * 获取存储的值
       * @param {string} key 存储键名
       * @param {any} defaultValue 默认值
       * @returns {Promise<any>}
       */
      async function getStorageValue$1(key, defaultValue = null) {
        try {
          const value = await _GM_getValue(key, defaultValue);
          // 如果是字符串，尝试解析为 JSON
          if (typeof value === 'string') {
            try {
              return JSON.parse(value)
            } catch {
              return value
            }
          }
          return value
        } catch (error) {
          console.warn(`Failed to get storage value for key "${key}":`, error);
          return defaultValue
        }
      }

      /**
       * 设置存储的值
       * @param {string} key 存储键名
       * @param {any} value 要存储的值
       * @returns {Promise<void>}
       */
      async function setStorageValue(key, value) {
        try {
          // 如果是对象或数组，转换为 JSON 字符串
          const storageValue = typeof value === 'object' || Array.isArray(value)
            ? JSON.stringify(value)
            : value;

          await _GM_setValue(key, storageValue);
        } catch (error) {
          console.warn(`Failed to set storage value for key "${key}":`, error);
        }
      }

      const scriptRel = (function detectScriptRel() {
        const relList = typeof document !== "undefined" && document.createElement("link").relList;
        return relList && relList.supports && relList.supports("modulepreload") ? "modulepreload" : "preload";
      })();const assetsURL = function(dep) { return "/"+dep };const seen = {};const __vitePreload = function preload(baseModule, deps, importerUrl) {
        let promise = Promise.resolve();
        if (deps && deps.length > 0) {
          document.getElementsByTagName("link");
          const cspNonceMeta = document.querySelector(
            "meta[property=csp-nonce]"
          );
          const cspNonce = cspNonceMeta?.nonce || cspNonceMeta?.getAttribute("nonce");
          promise = Promise.allSettled(
            deps.map((dep) => {
              dep = assetsURL(dep);
              if (dep in seen) return;
              seen[dep] = true;
              const isCss = dep.endsWith(".css");
              const cssSelector = isCss ? '[rel="stylesheet"]' : "";
              if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
                return;
              }
              const link = document.createElement("link");
              link.rel = isCss ? "stylesheet" : scriptRel;
              if (!isCss) {
                link.as = "script";
              }
              link.crossOrigin = "";
              link.href = dep;
              if (cspNonce) {
                link.setAttribute("nonce", cspNonce);
              }
              document.head.appendChild(link);
              if (isCss) {
                return new Promise((res, rej) => {
                  link.addEventListener("load", res);
                  link.addEventListener(
                    "error",
                    () => rej(new Error(`Unable to preload CSS for ${dep}`))
                  );
                });
              }
            })
          );
        }
        function handlePreloadError(err) {
          const e = new Event("vite:preloadError", {
            cancelable: true
          });
          e.payload = err;
          window.dispatchEvent(e);
          if (!e.defaultPrevented) {
            throw err;
          }
        }
        return promise.then((res) => {
          for (const item of res || []) {
            if (item.status !== "rejected") continue;
            handlePreloadError(item.reason);
          }
          return baseModule().catch(handlePreloadError);
        });
      };

      /**
       * 题目检测工具类
       * 用于检测题目类型、提取题目内容、获取选项等
       */

      /**
       * 检测题目类型
       * @returns {string} 题目类型 'single' | 'multiple' | 'judgement' | 'completion' | 'subjective' | 'unknown'
       */
      function detectQuestionType() {
        const typeElement = document.querySelector('span.tag.el-tooltip__trigger');
        if (!typeElement) return 'unknown';

        const typeText = typeElement.textContent.trim();
        const questionType = (() => {
          switch (typeText) {
            case '单选题': return 'single';
            case '单一选择': return 'single';
            case '多选题': return 'multiple';
            case '多项选择': return 'multiple';
            case '判断题': return 'judgement';
            case '判断': return 'judgement';
            case '填空题': return 'completion';
            case '主观题': return 'subjective';
            default: return 'unknown';
          }
        })();
        console.log('[BeelineHelper] detectQuestionType result:', typeText, '->', questionType);
        return questionType;
      }

      /**
       * 提取题目内容
       * @param {string} questionType 题目类型
       * @returns {object} 题目信息 { question: string, options: string[] }
       */
      function extractQuestionContent(questionType) {
        let question = '';
        let options = [];

        switch (questionType) {
          case 'single':
          case 'multiple':
            // 单选题和多选题 - 使用更通用的选择器
            const questionElement = document.querySelector('.question');
            if (questionElement) {
              // 提取题目
              const titleElement = questionElement.querySelector('.topic-title');
              if (titleElement) {
                question = titleElement.textContent.trim();
              }

              // 提取选项
              const optionElements = questionElement.querySelectorAll('.el-radio, .el-checkbox');
              options = Array.from(optionElements).map(option => {
                const labelElement = option.querySelector('.label');
                return labelElement ? labelElement.textContent.trim() : '';
              }).filter(text => text);
            }
            break;

          case 'judgement':
            // 判断题 - 使用更通用的选择器
            const judgementElement = document.querySelector('.topic-title');
            if (judgementElement) {
              question = judgementElement.textContent.trim();
              options = ['正确', '错误'];
            }
            break;

          case 'completion':
            // 填空题 - 提取题目内容
            const completionElement = document.querySelector('.topic-title');
            if (completionElement) {
              question = completionElement.textContent.trim();
            }
            break;

          case 'subjective':
            // 主观题 - 提取题目内容
            let subjectiveElement = document.querySelector('.homework-question-editor .content span');
            if (!subjectiveElement) {
              // 尝试新的路径
              subjectiveElement = document.querySelector('#LayoutTeaching .homework-question-editor .content p');
            }
            if (subjectiveElement) {
              question = subjectiveElement.textContent.trim();
            }
            break;
        }

        return { question, options };
      }

      /**
       * 获取选项对应的DOM元素
       * @param {string} questionType 题目类型
       * @param {string} option 选项标识 (A, B, C, D 等)
       * @returns {HTMLElement|null} 选项DOM元素
       */
      function getOptionElement(questionType, option) {
        const optionIndex = option.charCodeAt(0) - 65; // A=0, B=1, C=2, D=3

        switch (questionType) {
          case 'single':
            // 使用更通用的选择器
            const radioGroup = document.querySelector('.el-radio-group');
            if (radioGroup) {
              const radioLabels = radioGroup.querySelectorAll('label');
              if (radioLabels.length > optionIndex) {
                return radioLabels[optionIndex].querySelector('.el-radio__input span');
              }
            }
            break;

          case 'multiple':
            // 使用更通用的选择器
            const checkboxGroup = document.querySelector('.el-checkbox-group');
            if (checkboxGroup) {
              const checkboxLabels = checkboxGroup.querySelectorAll('label');
              if (checkboxLabels.length > optionIndex) {
                return checkboxLabels[optionIndex].querySelector('.el-checkbox__input span');
              }
            }
            break;

          case 'judgement':
            // 判断题
            const judgementGroup = document.querySelector('.el-radio-group');
            if (judgementGroup) {
              const judgementLabels = judgementGroup.querySelectorAll('label');
              if (option === 'A' && judgementLabels.length > 0) {
                return judgementLabels[0].querySelector('.el-radio__input span');
              } else if (option === 'B' && judgementLabels.length > 1) {
                return judgementLabels[1].querySelector('.el-radio__input span');
              }
            }
            break;
        }

        return null;
      }

      /**
       * 点击选项
       * @param {string} questionType 题目类型
       * @param {string} option 选项标识
       * @returns {boolean} 是否成功点击
       */
      async function clickOption(questionType, option) {
        const element = getOptionElement(questionType, option);
        if (element) {
          // 对于多选题，使用轮询式点击
          if (questionType === 'multiple') {
            const checkboxInput = element.closest('.el-checkbox__input');
            if (checkboxInput) {
              const input = checkboxInput.querySelector('input[type="checkbox"]');
              if (input) {
                // 轮询式点击：先点击一次，然后检查状态，如果没选中再点击
                let clickCount = 0;
                const maxClicks = 3; // 最多尝试3次

                while (clickCount < maxClicks && !input.checked) {
                  element.click();
                  clickCount++;

                  // 短暂延迟让DOM更新
                  await new Promise(resolve => setTimeout(resolve, 100));
                }

                return input.checked;
              }
            }
          } else {
            // 单选题和判断题直接点击
            element.click();
            return true;
          }
        }
        return false;
      }

      /**
       * 检查题目是否已有选择
       * @param {string} questionType 题目类型
       * @returns {boolean} 是否已有选择
       */
      async function hasExistingSelection(questionType) {
        switch (questionType) {
          case 'single':
          case 'judgement':
            // 检查单选题和判断题是否已有选中项
            const radioInputs = document.querySelectorAll('.el-radio__input input[type="radio"]');
            for (const input of radioInputs) {
              if (input.checked) {
                return true;
              }
            }
            break;

          case 'multiple':
            // 检查多选题是否已有选中项
            const checkboxInputs = document.querySelectorAll('.el-checkbox__input input[type="checkbox"]');
            for (const input of checkboxInputs) {
              if (input.checked) {
                return true;
              }
            }
            break;

          case 'completion':
            // 填空题已有内容检查在 completionAnswer.js 中处理
            return false;

          case 'subjective':
            // 主观题已有内容检查在 subjectiveAnswer.js 中处理
            return false;
        }

        return false;
      }
      /**
       * Converts a detected question type to a standardized format for the question bank API.
       * @param {string} type The detected question type (e.g., '单选题', '多选题', '判断题', '填空题', '主观题').
       * @returns {string} The standardized question type (e.g., 'single', 'multiple', 'judgment', 'completion', 'subjective'). Returns 'unknown' if not recognized.
       */
      function convertQuestionType(type) {
        switch (type) {
          case '单选题':
            return 'single';
          case '多选题':
            return 'multiple';
          case '判断题':
            return 'judgement';
          case '填空题':
            return 'completion';
          case '主观题':
            return 'subjective';
          default:
            return 'unknown';
        }
      }

      const API_BASE_URL = 'https://tk.enncy.cn/query';

      /**
       * 查询题目答案
       * @param {string} question 题目内容
       * @param {string[]} options 选项数组
       * @param {string} questionType 题目类型
       * @param {string} token API token
       * @returns {Promise<object>} 查询结果
       */
      async function queryAnswer(question, options = [], questionType = 'unknown', token = '') {
        if (!question.trim()) {
          return {
            success: false,
            message: '题目内容为空'
          };
        }

        try {
          const apiToken = token || getStorageValue('beelineHelper_apiToken', ''); // Use passed token or retrieve from storage
          if (!apiToken) {
            return { success: false, message: '请在答题设置中配置题库 Token' };
          }

          const params = new URLSearchParams({
            title: question,
            type: convertQuestionType(questionType),
            ...(apiToken && { token: apiToken })
          });

          // 如果有选项，添加到参数中
          if (options.length > 0) {
            params.append('options', options.join('\n'));
          }

          const response = await fetch(`${API_BASE_URL}?${params.toString()}`);

          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }

          const data = await response.json();

          if (data.code === 1) {
            return {
              success: true,
              question: data.data.question,
              answer: data.data.answer,
              times: data.data.times,
              message: data.message
            };
          } else {
            return {
              success: false,
              question: data.data?.question || '未找到答案',
              answer: data.data?.answer || '很抱歉，题目搜索不到',
              times: data.data?.times || 0,
              message: data.message
            };
          }
        } catch (error) {
          console.error('题库API查询失败:', error);
          return {
            success: false,
            message: `查询失败: ${error.message}`
          };
        }
      }

      /**
       * 解析答案文本
       * @param {string} answerText 答案文本
       * @param {string} questionType 题目类型
       * @param {string[]} options 选项内容数组
       * @returns {string[]} 解析后的选项数组
       */
      function parseAnswer(answerText, questionType, options = []) {
        if (!answerText) return [];

        // 去除标点符号和空格
        const cleanAnswer = answerText.replace(/[\s\p{P}]/gu, '');

        switch (questionType) {
          case 'single':
            // 方法1: 尝试匹配选项字母
            const letterMatch = cleanAnswer.match(/[A-D]/i);
            if (letterMatch) {
              return [letterMatch[0].toUpperCase()];
            }

            // 方法2: 根据答案内容匹配选项
            if (options.length > 0) {
              for (let i = 0; i < options.length; i++) {
                const optionText = options[i].replace(/[\s\p{P}]/gu, '');
                if (cleanAnswer.includes(optionText) || optionText.includes(cleanAnswer)) {
                  return [String.fromCharCode(65 + i)]; // A, B, C, D
                }
              }
            }

            // 方法3: 根据常见答案模式匹配
            if (cleanAnswer.includes('正确') || cleanAnswer.includes('对') || cleanAnswer.includes('是')) {
              return ['A'];
            } else if (cleanAnswer.includes('错误') || cleanAnswer.includes('错') || cleanAnswer.includes('否')) {
              return ['B'];
            }

            return [];

          case 'multiple':
            // 多选题答案通常是多个字母
            const multipleMatch = cleanAnswer.match(/[A-D]/gi);
            if (multipleMatch) {
              return [...new Set(multipleMatch.map(m => m.toUpperCase()))];
            }

            // 如果没有找到字母，尝试根据内容匹配
            if (options.length > 0) {
              const matchedOptions = [];
              for (let i = 0; i < options.length; i++) {
                const optionText = options[i].replace(/[\s\p{P}]/gu, '');
                // 检查答案是否包含选项的关键词
                const optionKeywords = optionText.split('、').map(k => k.trim()).filter(k => k);
                const hasMatch = optionKeywords.some(keyword =>
                  cleanAnswer.includes(keyword) || keyword.includes(cleanAnswer)
                );
                if (hasMatch) {
                  matchedOptions.push(String.fromCharCode(65 + i));
                }
              }
              return matchedOptions;
            }

            return [];

          case 'judgement':
            // 判断题答案
            if (cleanAnswer.includes('正确') || cleanAnswer.includes('对') || cleanAnswer.includes('是')) {
              return ['A'];
            } else if (cleanAnswer.includes('错误') || cleanAnswer.includes('错') || cleanAnswer.includes('否')) {
              return ['B'];
            }
            return [];

          default:
            return [];
        }
      }

      /**
       * 获取下一题按钮元素
       * @returns {HTMLElement|null} 下一题按钮
       */
      function getNextQuestionButton() {
        return document.querySelector("#LayoutTeaching > main > div > div > div > div.content-area > div.content > div.toggle-box > button:nth-child(2)");
      }

      /**
       * 检查下一题按钮是否可用
       * @returns {boolean} 是否可用
       */
      function isNextButtonEnabled() {
        const button = getNextQuestionButton();
        if (!button) return false;

        // 检查按钮是否禁用
        return !button.disabled && !button.classList.contains('is-disabled');
      }

      /**
       * 点击下一题按钮
       * @returns {boolean} 是否成功点击
       */
      function clickNextQuestion() {
        const button = getNextQuestionButton();
        if (button && isNextButtonEnabled()) {
          button.click();
          return true;
        }
        return false;
      }

      /**
       * 回答当前题目并返回结果
       * @param {string} token API token
       * @returns {Promise<object>} 答题结果
       */
      async function answerCurrentQuestion(token = '') {
        try {
          console.log('[DEBUG] 顺序答题 - answerCurrentQuestion 开始执行');
          // 检测题目类型
          const questionType = detectQuestionType();
          console.log('[DEBUG] 顺序答题 - 检测到的题目类型:', questionType);

          if (questionType === 'unknown') {
            return {
              success: false,
              message: '无法检测到题目类型'
            };
          }

          // 处理填空题
          if (questionType === 'completion') {
            const { question } = extractQuestionContent(questionType);
            if (!question) {
              return {
                success: false,
                message: '无法提取填空题题目内容',
                type: questionType
              };
            }

            try {
              // 导入填空题回答功能
              const { autoAnswerCompletionQuestion } = await __vitePreload(async () => { const { autoAnswerCompletionQuestion } = await module.import('./completionAnswer-YNeMB8H5-CWESuEKv.js');return { autoAnswerCompletionQuestion }},true?void 0:void 0);

              const result = await autoAnswerCompletionQuestion(token);
              return {
                ...result,
                type: questionType
              };
            } catch (error) {
              return {
                success: false,
                message: `填空题回答失败: ${error.message}`,
                question: question,
                type: questionType
              };
            }
          }

          // 处理主观题
          if (questionType === 'subjective') {
            const { question } = extractQuestionContent(questionType);
            if (!question) {
              return {
                success: false,
                message: '无法提取主观题题目内容',
                type: questionType
              };
            }

            try {
              console.log('[DEBUG] 顺序答题 - 开始处理主观题');
              // 导入主观题回答功能
              const { streamAnswerSubjectiveQuestion, checkSubjectiveAnswerConfig } = await __vitePreload(async () => { const { streamAnswerSubjectiveQuestion, checkSubjectiveAnswerConfig } = await module.import('./subjectiveAnswer-YKVl7e_4-DPJa3JEe.js');return { streamAnswerSubjectiveQuestion, checkSubjectiveAnswerConfig }},true?void 0:void 0);

              // 检查主观题回答配置
              console.log('[DEBUG] 顺序答题 - 检查主观题配置');
              const configCheck = await checkSubjectiveAnswerConfig();
              console.log('[DEBUG] 顺序答题 - 配置检查结果:', configCheck);
              if (!configCheck.valid) {
                console.log('[DEBUG] 顺序答题 - 配置检查失败:', configCheck.message);
                return {
                  success: false,
                  message: configCheck.message,
                  type: questionType
                };
              }

              console.log('[DEBUG] 顺序答题 - 开始调用主观题回答函数');
              const result = await streamAnswerSubjectiveQuestion(question);
              console.log('[DEBUG] 顺序答题 - 主观题回答结果:', result);
              return {
                ...result,
                type: questionType
              };
            } catch (error) {
              console.error('[DEBUG] 顺序答题 - 主观题回答过程中出错:', error);
              console.error('[DEBUG] 顺序答题 - 错误堆栈:', error.stack);
              return {
                success: false,
                message: `主观题回答失败: ${error.message}`,
                question: question,
                type: questionType
              };
            }
          }

          // 提取题目内容
          const { question, options } = extractQuestionContent(questionType);

          if (!question) {
            return {
              success: false,
              message: '无法提取题目内容'
            };
          }

          console.log('检测到题目:', question);
          console.log('选项:', options);

          // 检查是否已有选择（跳过逻辑）
          if (await hasExistingSelection(questionType)) {
            console.log('题目已有选择，跳过自动答题');
            return {
              success: false,
              message: '题目已有选择，跳过自动答题',
              question: question,
              type: questionType
            };
          }

          // 查询题库
          const apiResult = await queryAnswer(question, options, questionType, token);

          if (!apiResult.success) {
            return {
              success: false,
              message: apiResult.message,
              question: question,
              answer: apiResult.answer,
              type: questionType
            };
          }

          console.log('题库查询结果:', apiResult);

          // 解析答案
          const answerOptions = parseAnswer(apiResult.answer, questionType, options);

          if (answerOptions.length === 0) {
            return {
              success: false,
              message: '无法解析答案',
              question: apiResult.question,
              answer: apiResult.answer,
              type: questionType
            };
          }

          console.log('解析后的答案选项:', answerOptions);

          // 点击选项
          let clickedCount = 0;
          for (const option of answerOptions) {
            if (await clickOption(questionType, option)) {
              clickedCount++;
              console.log(`已选择选项: ${option}`);
            }
          }

          return {
            success: clickedCount > 0,
            message: clickedCount > 0 ? `成功选择 ${clickedCount} 个选项` : '选择选项失败',
            question: apiResult.question,
            answer: apiResult.answer,
            selectedOptions: answerOptions,
            times: apiResult.times,
            type: questionType
          };

        } catch (error) {
          console.error('[DEBUG] 顺序答题 - 回答当前题目失败:', error);
          console.error('[DEBUG] 顺序答题 - 错误堆栈:', error.stack);
          return {
            success: false,
            message: `回答当前题目失败: ${error.message}`
          };
        }
      }

      /**
       * 获取当前题目编号
       * @returns {number} 题目编号，如果无法获取则返回0
       */
      function getCurrentQuestionNumber() {
        try {
          // 使用XPath获取题目编号元素
          const xpathResult = document.evaluate(
            '//*[@id="LayoutTeaching"]/main/div/div/div/div[2]/div[2]/div[2]/div/div/div[1]/span',
            document,
            null,
            XPathResult.FIRST_ORDERED_NODE_TYPE,
            null
          );

          const questionElement = xpathResult.singleNodeValue;
          if (questionElement && questionElement.textContent) {
            // 提取题目编号，格式为 "1.（10 分）"，只需要数字部分
            const text = questionElement.textContent.trim();
            const match = text.match(/^(\d+)\./);
            if (match && match[1]) {
              return parseInt(match[1], 10);
            }
          }
        } catch (error) {
          console.warn('获取题目编号失败:', error);
        }

        return 0;
      }

      // 全局变量用于控制自动答题终止
      let shouldStopSequentialAnswering = false;

      /**
       * 顺序回答所有题目
       * @param {string} token API token
       * @param {function} onProgress 进度回调函数
       * @returns {Promise<object>} 批量答题结果
       */
      async function sequentialAnswerAllQuestions(token = '', onProgress = null) {
        const results = [];
        let questionCount = 0;
        let successCount = 0;
        shouldStopSequentialAnswering = false;

        try {
          console.log('开始顺序答题...');

          // 循环回答题目，直到没有下一题或被终止
          while (true) {
            // 检查是否应该停止答题 - 在每个循环开始时检查
            if (shouldStopSequentialAnswering) {
              console.log('自动答题已被终止');
              break;
            }
            questionCount++;

            // 获取当前题目编号
            const currentQuestionNumber = getCurrentQuestionNumber();
            const displayNumber = currentQuestionNumber > 0 ? currentQuestionNumber : questionCount;

            // 报告进度
            if (onProgress) {
              onProgress({
                current: displayNumber,
                status: '正在回答第 ' + displayNumber + ' 题...'
              });
            }

            console.log(`正在回答第 ${displayNumber} 题...`);

            // 检查是否应该停止答题 - 在回答题目前再次检查
            if (shouldStopSequentialAnswering) {
              console.log('自动答题已被终止');
              break;
            }

            // 回答当前题目
            console.log(`[DEBUG] 顺序答题 - 开始回答第 ${displayNumber} 题`);
            const result = await answerCurrentQuestion(token);

            // 记录结果
            results.push({
              questionNumber: displayNumber,
              ...result
            });

            if (result.success) {
              successCount++;
              console.log(`第 ${displayNumber} 题回答成功`);
            } else {
              console.log(`第 ${displayNumber} 题回答失败: ${result.message}`);
              console.log(`[DEBUG] 顺序答题 - 详细失败信息:`, result);
            }

            // 检查是否应该停止答题 - 在等待前检查
            if (shouldStopSequentialAnswering) {
              console.log('自动答题已被终止');
              break;
            }

            // 等待选项点击生效
            await new Promise(resolve => setTimeout(resolve, 1000));

            // 检查是否应该停止答题 - 在检查下一题前检查
            if (shouldStopSequentialAnswering) {
              console.log('自动答题已被终止');
              break;
            }

            // 检查是否有下一题
            if (!isNextButtonEnabled()) {
              console.log('没有下一题，答题完成');
              break;
            }

            // 检查是否应该停止答题 - 在点击下一题前检查
            if (shouldStopSequentialAnswering) {
              console.log('自动答题已被终止');
              break;
            }

            // 点击下一题
            console.log('点击下一题...');
            const nextClicked = clickNextQuestion();

            if (!nextClicked) {
              console.log('无法点击下一题，答题完成');
              break;
            }

            // 检查是否应该停止答题 - 在等待下一题加载前检查
            if (shouldStopSequentialAnswering) {
              console.log('自动答题已被终止');
              break;
            }

            // 等待下一题加载
            await new Promise(resolve => setTimeout(resolve, 1500));

            // 检查是否应该停止答题 - 在检查页面状态前检查
            if (shouldStopSequentialAnswering) {
              console.log('自动答题已被终止');
              break;
            }

            // 检查是否还在答题页面（防止意外跳转）
            const stillOnQuestionPage = detectQuestionType() !== 'unknown';
            if (!stillOnQuestionPage) {
              console.log('已离开答题页面，答题完成');
              break;
            }

            // 检查是否应该停止答题 - 在最终延迟前检查
            if (shouldStopSequentialAnswering) {
              console.log('自动答题已被终止');
              break;
            }

            // 添加延迟避免频繁请求
            await new Promise(resolve => setTimeout(resolve, 500));
          }

          // 答题完成后弹出提示框
          setTimeout(() => {
            alert('答题完成，请务必检查答案结果！');
          }, 1000);

          return {
            success: successCount > 0,
            message: `答题完成: 成功 ${successCount}/${questionCount} 题`,
            totalQuestions: questionCount,
            successCount: successCount,
            results: results
          };

        } catch (error) {
          console.error('顺序答题失败:', error);
          return {
            success: false,
            message: `顺序答题失败: ${error.message}`,
            totalQuestions: questionCount,
            successCount: successCount,
            results: results
          };
        }
      }

      /**
       * 停止顺序答题
       * @returns {boolean} 是否成功停止
       */
      function stopSequentialAnswering() {
        shouldStopSequentialAnswering = true;
        console.log('停止顺序答题');
        return true;
      }

      // 主观题回答功能使用动态导入

      /**
       * 自动回答单个题目
       * @param {string} token API token
       * @returns {Promise<object>} 答题结果
       */
      async function autoAnswerSingleQuestion(token = '') {
        try {
          console.log('[DEBUG] autoAnswerSingleQuestion 开始执行');
          // 检测题目类型
          const questionType = detectQuestionType();
          console.log('[DEBUG] 检测到的题目类型:', questionType);

          if (questionType === 'unknown') {
            return {
              success: false,
              message: '无法检测到题目类型'
            };
          }

          // 处理主观题
          if (questionType === 'subjective') {
            console.log('[DEBUG] 开始处理主观题');
            const { question } = extractQuestionContent(questionType);
            console.log('[DEBUG] 提取的主观题内容:', question);
            if (!question) {
              console.log('[DEBUG] 无法提取主观题题目内容');
              return {
                success: false,
                message: '无法提取主观题题目内容'
              };
            }

            try {
              console.log('[DEBUG] 开始动态导入主观题模块');
              // 动态导入主观题回答功能
              const { streamAnswerSubjectiveQuestion, checkSubjectiveAnswerConfig } = await __vitePreload(async () => { const { streamAnswerSubjectiveQuestion, checkSubjectiveAnswerConfig } = await module.import('./subjectiveAnswer-YKVl7e_4-DPJa3JEe.js');return { streamAnswerSubjectiveQuestion, checkSubjectiveAnswerConfig }},true?void 0:void 0);
              console.log('[DEBUG] 主观题模块导入成功');

              // 检查主观题回答配置
              console.log('[DEBUG] 开始检查主观题配置');
              const configCheck = await checkSubjectiveAnswerConfig();
              console.log('[DEBUG] 配置检查结果:', configCheck);
              if (!configCheck.valid) {
                console.log('[DEBUG] 配置检查失败:', configCheck.message);
                return {
                  success: false,
                  message: configCheck.message
                };
              }

              console.log('[DEBUG] 开始调用主观题回答函数');
              const result = await streamAnswerSubjectiveQuestion(question);
              console.log('[DEBUG] 主观题回答结果:', result);
              return {
                ...result,
                type: 'subjective'
              };
            } catch (error) {
              console.error('主观题回答过程中出错:', error);
              return {
                success: false,
                message: `主观题回答失败: ${error.message}`,
                question: question
              };
            }
          }

          // 处理填空题
          if (questionType === 'completion') {
            const { question } = extractQuestionContent(questionType);
            if (!question) {
              return {
                success: false,
                message: '无法提取填空题题目内容'
              };
            }

            try {
              // 动态导入填空题回答功能
              const { autoAnswerCompletionQuestion } = await __vitePreload(async () => { const { autoAnswerCompletionQuestion } = await module.import('./completionAnswer-YNeMB8H5-CWESuEKv.js');return { autoAnswerCompletionQuestion }},true?void 0:void 0);

              const result = await autoAnswerCompletionQuestion(token);
              return {
                ...result,
                type: 'completion'
              };
            } catch (error) {
              return {
                success: false,
                message: `填空题回答失败: ${error.message}`,
                question: question
              };
            }
          }

          // 提取题目内容
          const { question, options } = extractQuestionContent(questionType);

          if (!question) {
            return {
              success: false,
              message: '无法提取题目内容'
            };
          }

          console.log('检测到题目:', question);
          console.log('选项:', options);

          // 检查是否已有选择（跳过逻辑）
          if (await hasExistingSelection(questionType)) {
            console.log('题目已有选择，跳过自动答题');
            return {
              success: false,
              message: '题目已有选择，跳过自动答题',
              question: question,
              type: questionType
            };
          }

          // 查询题库
          const apiResult = await queryAnswer(question, options, questionType, token);

          if (!apiResult.success) {
            return {
              success: false,
              message: apiResult.message,
              question: question,
              answer: apiResult.answer
            };
          }

          console.log('题库查询结果:', apiResult);

          // 解析答案
          const answerOptions = parseAnswer(apiResult.answer, questionType, options);

          if (answerOptions.length === 0) {
            return {
              success: false,
              message: '无法解析答案',
              question: apiResult.question,
              answer: apiResult.answer
            };
          }

          console.log('解析后的答案选项:', answerOptions);

          // 点击选项
          let clickedCount = 0;
          for (const option of answerOptions) {
            if (await clickOption(questionType, option)) {
              clickedCount++;
              console.log(`已选择选项: ${option}`);
            }
          }

          return {
            success: clickedCount > 0,
            message: clickedCount > 0 ? `成功选择 ${clickedCount} 个选项` : '选择选项失败',
            question: apiResult.question,
            answer: apiResult.answer,
            selectedOptions: answerOptions,
            times: apiResult.times
          };

        } catch (error) {
          console.error('[DEBUG] 自动答题失败:', error);
          console.error('[DEBUG] 错误堆栈:', error.stack);
          return {
            success: false,
            message: `自动答题失败: ${error.message}`
          };
        }
      }

      /**
       * 自动回答当前页面所有题目（使用顺序答题方式）
       * @param {string} token API token
       * @param {function} onProgress 进度回调函数
       * @returns {Promise<object>} 批量答题结果
       */
      async function autoAnswerAllQuestions(token = '', onProgress = null) {
        return await sequentialAnswerAllQuestions(token, onProgress);
      }

      const _hoisted_1$4 = { class: "answer-settings-page" };
      const _hoisted_2$4 = { class: "settings-section" };
      const _hoisted_3$4 = { class: "token-section" };
      const _hoisted_4$4 = { class: "token-input-box" };
      const _hoisted_5$4 = { class: "token-input-box" };
      const _hoisted_6$3 = { class: "ai-settings-section" };
      const _hoisted_7$3 = { class: "toggle-item" };
      const _hoisted_8$3 = { class: "toggle-label" };
      const _hoisted_9$2 = { class: "advanced-section" };
      const _hoisted_10$2 = { class: "token-input-box" };
      const _hoisted_11$2 = { class: "token-input-box" };
      const _hoisted_12$2 = { class: "token-input-box" };
      const _hoisted_13$2 = {
        key: 0,
        class: "status-section"
      };
      const _sfc_main$4 = {
        __name: "AnswerSettingsPage",
        setup(__props) {
          const apiToken = ref("");
          const aiToken = ref("");
          const baseUrl = ref("");
          const modelName = ref("");
          const systemPrompt = ref("");
          const aiAssistedEnabled = ref(false);
          const statusMessage = ref("");
          const isSuccess = ref(false);
          const loadApiToken = async () => {
            const saved = await getStorageValue$1("beelineHelper_apiToken");
            if (saved) apiToken.value = saved;
          };
          const saveApiToken = async () => {
            if (apiToken.value) {
              await setStorageValue("beelineHelper_apiToken", apiToken.value);
              showStatus("题库 Token 已保存", true);
            }
          };
          const loadAiToken = async () => {
            const saved = await getStorageValue$1("beelineHelper_aiToken");
            if (saved) aiToken.value = saved;
          };
          const saveAiToken = async () => {
            if (aiToken.value) {
              await setStorageValue("beelineHelper_aiToken", aiToken.value);
              showStatus("AI Token 已保存", true);
            }
          };
          const loadBaseUrl = async () => {
            const saved = await getStorageValue$1("beelineHelper_baseUrl");
            baseUrl.value = saved || "https://api.siliconflow.cn/v1";
          };
          const saveBaseUrl = async () => {
            await setStorageValue("beelineHelper_baseUrl", baseUrl.value);
            showStatus("BASE_URL 已保存", true);
          };
          const loadModelName = async () => {
            const saved = await getStorageValue$1("beelineHelper_modelName");
            modelName.value = saved || "THUDM/GLM-4.1V-9B-Thinking";
          };
          const saveModelName = async () => {
            await setStorageValue("beelineHelper_modelName", modelName.value);
            showStatus("MODEL_NAME 已保存", true);
          };
          const loadSystemPrompt = async () => {
            const saved = await getStorageValue$1("beelineHelper_systemPrompt");
            systemPrompt.value = saved || "你是一个专业全能的助手。请清晰、准确地回答问题，提供简明而准确的信息。使用正式、专业的语气。在适当情况下解释你的推理或提供背景信息，但避免不必要的冗长。始终确保答案可靠、易于理解。";
          };
          const saveSystemPrompt = async () => {
            await setStorageValue("beelineHelper_systemPrompt", systemPrompt.value);
            showStatus("SYSTEM_PROMPT 已保存", true);
          };
          const loadAIAssisted = async () => {
            const saved = await getStorageValue$1("beelineHelper_aiAssistedEnabled");
            aiAssistedEnabled.value = saved === "true" || saved === true;
          };
          const toggleAIAssisted = async () => {
            await setStorageValue("beelineHelper_aiAssistedEnabled", aiAssistedEnabled.value);
            if (aiAssistedEnabled.value) {
              showStatus("AI辅助答题已启用", true);
            } else {
              showStatus("AI辅助答题已禁用", false);
            }
          };
          const showStatus = (message, success) => {
            statusMessage.value = message;
            isSuccess.value = success;
            setTimeout(() => {
              statusMessage.value = "";
            }, 3e3);
          };
          onMounted(async () => {
            await loadApiToken();
            await loadAiToken();
            await loadBaseUrl();
            await loadModelName();
            await loadSystemPrompt();
            await loadAIAssisted();
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", _hoisted_1$4, [
              createBaseVNode("div", _hoisted_2$4, [
                _cache[18] || (_cache[18] = createBaseVNode("h3", null, "API Token 设置", -1)),
                createBaseVNode("div", _hoisted_3$4, [
                  _cache[8] || (_cache[8] = createBaseVNode("a", {
                    href: "https://tk.enncy.cn",
                    target: "_blank",
                    class: "token-link"
                  }, " 📖 获取 Token（言溪题库） ", -1)),
                  createBaseVNode("div", _hoisted_4$4, [
                    _cache[6] || (_cache[6] = createBaseVNode("label", { for: "tokenInput" }, "用户凭证 (Token/密钥):", -1)),
                    withDirectives(createBaseVNode("input", {
                      id: "tokenInput",
                      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => apiToken.value = $event),
                      onInput: saveApiToken,
                      placeholder: "请输入题库 API Token",
                      class: "token-input"
                    }, null, 544), [
                      [vModelText, apiToken.value]
                    ])
                  ]),
                  _cache[9] || (_cache[9] = createBaseVNode("a", {
                    href: "https://cloud.siliconflow.cn/i/kcw2LF5Y",
                    target: "_blank",
                    class: "token-link"
                  }, " 获取 Token(硅基流动) ", -1)),
                  createBaseVNode("div", _hoisted_5$4, [
                    _cache[7] || (_cache[7] = createBaseVNode("label", { for: "aiTokenInput" }, "AI Token:", -1)),
                    withDirectives(createBaseVNode("input", {
                      id: "aiTokenInput",
                      "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => aiToken.value = $event),
                      onInput: saveAiToken,
                      placeholder: "请输入 AI Token",
                      class: "token-input"
                    }, null, 544), [
                      [vModelText, aiToken.value]
                    ])
                  ])
                ]),
                createBaseVNode("div", _hoisted_6$3, [
                  _cache[12] || (_cache[12] = createBaseVNode("h4", null, "AI 辅助设置(这个还没做，别用)", -1)),
                  createBaseVNode("div", _hoisted_7$3, [
                    createBaseVNode("label", _hoisted_8$3, [
                      withDirectives(createBaseVNode("input", {
                        type: "checkbox",
                        "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => aiAssistedEnabled.value = $event),
                        onChange: toggleAIAssisted
                      }, null, 544), [
                        [vModelCheckbox, aiAssistedEnabled.value]
                      ]),
                      _cache[10] || (_cache[10] = createBaseVNode("span", { class: "toggle-slider" }, null, -1)),
                      _cache[11] || (_cache[11] = createTextVNode(" AI辅助回答选择判断题 ", -1))
                    ])
                  ])
                ]),
                createBaseVNode("div", _hoisted_9$2, [
                  _cache[16] || (_cache[16] = createBaseVNode("h4", null, "高级设置", -1)),
                  _cache[17] || (_cache[17] = createBaseVNode("p", { class: "warning-text" }, "⚠️ 一般情况下请不要修改以下设置", -1)),
                  createBaseVNode("div", _hoisted_10$2, [
                    _cache[13] || (_cache[13] = createBaseVNode("label", { for: "baseUrlInput" }, "BASE_URL:", -1)),
                    withDirectives(createBaseVNode("input", {
                      id: "baseUrlInput",
                      "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => baseUrl.value = $event),
                      onInput: saveBaseUrl,
                      placeholder: "请输入 API 基础地址",
                      class: "token-input"
                    }, null, 544), [
                      [vModelText, baseUrl.value]
                    ])
                  ]),
                  createBaseVNode("div", _hoisted_11$2, [
                    _cache[14] || (_cache[14] = createBaseVNode("label", { for: "modelNameInput" }, "MODEL_NAME:", -1)),
                    withDirectives(createBaseVNode("input", {
                      id: "modelNameInput",
                      "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => modelName.value = $event),
                      onInput: saveModelName,
                      placeholder: "请输入模型名称",
                      class: "token-input"
                    }, null, 544), [
                      [vModelText, modelName.value]
                    ])
                  ]),
                  createBaseVNode("div", _hoisted_12$2, [
                    _cache[15] || (_cache[15] = createBaseVNode("label", { for: "systemPromptInput" }, "SYSTEM_PROMPT:", -1)),
                    withDirectives(createBaseVNode("textarea", {
                      id: "systemPromptInput",
                      "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => systemPrompt.value = $event),
                      onInput: saveSystemPrompt,
                      placeholder: "请输入系统提示词",
                      class: "token-input textarea-input",
                      rows: "3"
                    }, null, 544), [
                      [vModelText, systemPrompt.value]
                    ])
                  ])
                ]),
                _cache[19] || (_cache[19] = createBaseVNode("div", { class: "settings-info" }, [
                  createBaseVNode("p", { class: "info-text" }, [
                    createBaseVNode("strong", null, "使用说明：")
                  ]),
                  createBaseVNode("ul", { class: "info-list" }, [
                    createBaseVNode("li", null, "题库 Token 用于查询题目答案"),
                    createBaseVNode("li", null, "AI Token 用于生成式回答（如需要）"),
                    createBaseVNode("li", null, "请确保输入的 Token 正确有效"),
                    createBaseVNode("li", null, "Token 会安全保存在本地浏览器中"),
                    createBaseVNode("li", null, "高级设置仅供高级用户使用，一般情况请保持默认")
                  ])
                ], -1))
              ]),
              statusMessage.value ? (openBlock(), createElementBlock("div", _hoisted_13$2, [
                createBaseVNode("div", {
                  class: normalizeClass(["status-message", { success: isSuccess.value, error: !isSuccess.value }])
                }, toDisplayString(statusMessage.value), 3)
              ])) : createCommentVNode("", true)
            ]);
          };
        }
      };
      const AnswerSettingsPage = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["__scopeId", "data-v-bbdf02b5"]]);

      const _hoisted_1$3 = { class: "auto-answer-page" };
      const _hoisted_2$3 = {
        key: 0,
        class: "overlay-blocker"
      };
      const _hoisted_3$3 = { class: "navigation-section" };
      const _hoisted_4$3 = {
        key: 1,
        class: "subpage-content"
      };
      const _hoisted_5$3 = { class: "config-section" };
      const _hoisted_6$2 = { class: "config-item" };
      const _hoisted_7$2 = { class: "toggle-with-actions" };
      const _hoisted_8$2 = { class: "action-buttons" };
      const _hoisted_9$1 = ["disabled"];
      const _hoisted_10$1 = ["disabled"];
      const _hoisted_11$1 = { class: "results-section" };
      const _hoisted_12$1 = { key: 0 };
      const _hoisted_13$1 = {
        key: 1,
        class: "single-result"
      };
      const _hoisted_14$1 = { class: "result-header" };
      const _hoisted_15$1 = { class: "result-type" };
      const _hoisted_16$1 = { class: "result-message" };
      const _hoisted_17$1 = {
        key: 0,
        class: "result-question"
      };
      const _hoisted_18$1 = {
        key: 1,
        class: "result-answer"
      };
      const _hoisted_19 = {
        key: 2,
        class: "result-options"
      };
      const _hoisted_20 = {
        key: 2,
        class: "batch-results"
      };
      const _hoisted_21 = { class: "filter-buttons" };
      const _hoisted_22 = { class: "results-list" };
      const _hoisted_23 = { class: "result-header" };
      const _hoisted_24 = { class: "result-type" };
      const _hoisted_25 = {
        key: 0,
        class: "ai-indicator"
      };
      const _hoisted_26 = { class: "result-message" };
      const _hoisted_27 = {
        key: 0,
        class: "result-question"
      };
      const _hoisted_28 = {
        key: 1,
        class: "result-answer"
      };
      const _hoisted_29 = {
        key: 2,
        class: "result-options"
      };
      const _hoisted_30 = {
        key: 0,
        class: "progress-section"
      };
      const _hoisted_31 = { class: "progress-info" };
      const _hoisted_32 = { class: "progress-text" };
      const _hoisted_33 = { class: "progress-status" };
      const _hoisted_34 = {
        key: 2,
        class: "subpage-content"
      };
      const _hoisted_35 = {
        key: 3,
        class: "status-section"
      };


      const _sfc_main$3 = {
        __name: 'AutoAnswerPage',
        setup(__props) {

      const isAnswering = ref(false);
      const singleResult = ref(null);
      const batchResults = ref([]);
      const statusMessage = ref('');
      const isSuccess = ref(false);
      const progressInfo = ref(null);
      const currentFilter = ref('all');
      const isAgreementChecked = ref(false);
      const currentSubpage = ref('main'); // 当前子页面：main, settings

      // 从存储获取API Token
      const getApiToken = async () => {
        return await getStorageValue$1('beelineHelper_apiToken', '') || ''
      };

      // 回答当前题目
      const answerCurrentQuestion = async () => {
        const token = await getApiToken();
        if (!token) {
          showStatus('请先在答题设置页面设置API Token', false);
          return
        }

        isAnswering.value = true;
        showStatus('正在查询答案...', true);

        try {
          const result = await autoAnswerSingleQuestion(token);

          // 单题结果直接覆盖，不保留历史
          singleResult.value = {
            type: 'single',
            ...result,
            timestamp: new Date().toLocaleTimeString()
          };

          if (result.success) {
            showStatus('答题成功！', true);
          } else {
            showStatus(`答题失败: ${result.message}`, false);
          }
        } catch (error) {
          showStatus(`答题失败: ${error.message}`, false);
        } finally {
          isAnswering.value = false;
        }
      };

      // 回答所有题目
      const answerAllQuestions = async () => {
        const token = await getApiToken();
        if (!token) {
          showStatus('请先在答题设置页面设置API Token', false);
          return
        }

        isAnswering.value = true;
        progressInfo.value = null;
        showStatus('开始顺序答题...', true);

        try {
          const result = await autoAnswerAllQuestions(token, (progress) => {
            progressInfo.value = progress;
            showStatus(progress.status, true);
          });

          if (result.success) {
            showStatus(`顺序答题完成: ${result.message}`, true);
          } else {
            showStatus(`顺序答题失败: ${result.message}`, false);
          }

          // 批量结果存储到独立的数组中
          if (result.results && result.results.length > 0) {
            batchResults.value = result.results.map((item) => ({
              questionNumber: item.questionNumber,
              ...item,
              timestamp: new Date().toLocaleTimeString()
            }));
          }
        } catch (error) {
          showStatus(`顺序答题失败: ${error.message}`, false);
        } finally {
          isAnswering.value = false;
          progressInfo.value = null;
        }
      };

      // 显示状态消息
      const showStatus = (message, success) => {
        statusMessage.value = message;
        isSuccess.value = success;

        // 3秒后清除状态消息
        setTimeout(() => {
          statusMessage.value = '';
        }, 3000);
      };

      // 获取题型文本
      const getTypeText = (type) => {
        const typeMap = {
          'single': '单选题',
          'multiple': '多选题',
          'judgement': '判断题',
          'completion': '填空题',
          'subjective': '主观题',
          'batch': '批量答题'
        };
        return typeMap[type] || type
      };

      // 计算筛选后的批量结果
      const filteredBatchResults = computed(() => {
        if (currentFilter.value === 'all') {
          return batchResults.value
        } else if (currentFilter.value === 'abnormal') {
          return batchResults.value.filter(result => !result.success)
        } else if (currentFilter.value === 'ai') {
          return batchResults.value.filter(result => result.aiAssisted)
        }
        return batchResults.value
      });


      // 终止自动答题
      const terminateAutoAnswer = () => {
        stopSequentialAnswering();
        isAnswering.value = false;
        progressInfo.value = null;
        showStatus('已终止自动答题', true);
      };

      // 检查同意状态
      const checkAgreementState = async () => {
        const savedState = await getStorageValue$1('beelineHelper_agreeState');
        if (savedState !== null) {
          isAgreementChecked.value = savedState;
        }
      };

      // 页面加载时初始化
      onMounted(async () => {
        // 检查同意状态
        await checkAgreementState();

        // 监听localStorage变化
        window.addEventListener('storage', checkAgreementState);
      });

      onUnmounted(() => {
        // 清理工作
        window.removeEventListener('storage', checkAgreementState);
      });

      return (_ctx, _cache) => {
        return (openBlock(), createElementBlock("div", _hoisted_1$3, [
          (!isAgreementChecked.value)
            ? (openBlock(), createElementBlock("div", _hoisted_2$3, [...(_cache[5] || (_cache[5] = [
                createBaseVNode("div", { class: "overlay-content" }, [
                  createBaseVNode("div", { class: "warning-icon" }, [
                    createBaseVNode("img", {
                      src: _imports_0$1,
                      alt: "提示图标",
                      class: "icon-img"
                    })
                  ]),
                  createBaseVNode("div", { class: "warning-text" }, "如要使用此功能请先阅读关于中的内容")
                ], -1)
              ]))]))
            : createCommentVNode("", true),
          createBaseVNode("div", _hoisted_3$3, [
            createBaseVNode("button", {
              class: normalizeClass(["nav-btn", { active: currentSubpage.value === 'main' }]),
              onClick: _cache[0] || (_cache[0] = $event => (currentSubpage.value = 'main'))
            }, " 自动答题 ", 2),
            createBaseVNode("button", {
              class: normalizeClass(["nav-btn", { active: currentSubpage.value === 'settings' }]),
              onClick: _cache[1] || (_cache[1] = $event => (currentSubpage.value = 'settings'))
            }, " 答题设置 ", 2)
          ]),
          (currentSubpage.value === 'main')
            ? (openBlock(), createElementBlock("div", _hoisted_4$3, [
                createBaseVNode("div", _hoisted_5$3, [
                  createBaseVNode("div", _hoisted_6$2, [
                    createBaseVNode("div", _hoisted_7$2, [
                      createBaseVNode("div", _hoisted_8$2, [
                        createBaseVNode("button", {
                          class: "action-btn primary",
                          onClick: answerCurrentQuestion,
                          disabled: isAnswering.value
                        }, toDisplayString(isAnswering.value ? '答题中...' : '回答当前题目'), 9, _hoisted_9$1),
                        createBaseVNode("button", {
                          class: "action-btn secondary",
                          onClick: answerAllQuestions,
                          disabled: isAnswering.value
                        }, toDisplayString(isAnswering.value ? '答题中...' : '回答所有题目'), 9, _hoisted_10$1),
                        createBaseVNode("button", {
                          class: "action-btn danger",
                          onClick: terminateAutoAnswer
                        }, " 终止自动答题 ")
                      ])
                    ])
                  ])
                ]),
                createBaseVNode("div", _hoisted_11$1, [
                  (singleResult.value)
                    ? (openBlock(), createElementBlock("h3", _hoisted_12$1, "单次答题结果"))
                    : createCommentVNode("", true),
                  (singleResult.value)
                    ? (openBlock(), createElementBlock("div", _hoisted_13$1, [
                        createBaseVNode("div", {
                          class: normalizeClass(["result-item", { success: singleResult.value.success, error: !singleResult.value.success }])
                        }, [
                          createBaseVNode("div", _hoisted_14$1, [
                            createBaseVNode("span", _hoisted_15$1, toDisplayString(getTypeText(singleResult.value.type)), 1),
                            createBaseVNode("span", {
                              class: normalizeClass(["result-status", { success: singleResult.value.success, error: !singleResult.value.success }])
                            }, toDisplayString(singleResult.value.success ? '成功' : '失败'), 3)
                          ]),
                          createBaseVNode("div", _hoisted_16$1, toDisplayString(singleResult.value.message), 1),
                          (singleResult.value.question)
                            ? (openBlock(), createElementBlock("div", _hoisted_17$1, "题目: " + toDisplayString(singleResult.value.question), 1))
                            : createCommentVNode("", true),
                          (singleResult.value.answer)
                            ? (openBlock(), createElementBlock("div", _hoisted_18$1, "答案: " + toDisplayString(singleResult.value.answer), 1))
                            : createCommentVNode("", true),
                          (singleResult.value.selectedOptions && singleResult.value.selectedOptions.length > 0)
                            ? (openBlock(), createElementBlock("div", _hoisted_19, " 选择: " + toDisplayString(singleResult.value.selectedOptions.join(', ')), 1))
                            : createCommentVNode("", true)
                        ], 2)
                      ]))
                    : createCommentVNode("", true),
                  (batchResults.value.length > 0)
                    ? (openBlock(), createElementBlock("div", _hoisted_20, [
                        createBaseVNode("div", _hoisted_21, [
                          createBaseVNode("button", {
                            class: normalizeClass(["filter-btn", { active: currentFilter.value === 'all' }]),
                            onClick: _cache[2] || (_cache[2] = $event => (currentFilter.value = 'all'))
                          }, " 全部 ", 2),
                          createBaseVNode("button", {
                            class: normalizeClass(["filter-btn", { active: currentFilter.value === 'abnormal' }]),
                            onClick: _cache[3] || (_cache[3] = $event => (currentFilter.value = 'abnormal'))
                          }, " 异常 ", 2),
                          createBaseVNode("button", {
                            class: normalizeClass(["filter-btn ai-filter", { active: currentFilter.value === 'ai' }]),
                            onClick: _cache[4] || (_cache[4] = $event => (currentFilter.value = 'ai'))
                          }, " AI辅助 ", 2)
                        ]),
                        createBaseVNode("div", _hoisted_22, [
                          (openBlock(true), createElementBlock(Fragment, null, renderList(filteredBatchResults.value, (result, index) => {
                            return (openBlock(), createElementBlock("div", {
                              key: index,
                              class: normalizeClass(["result-item", { success: result.success, error: !result.success, 'ai-assisted': result.aiAssisted }])
                            }, [
                              createBaseVNode("div", _hoisted_23, [
                                createBaseVNode("span", _hoisted_24, [
                                  createTextVNode(" 第" + toDisplayString(result.questionNumber) + "题 ", 1),
                                  (result.aiAssisted)
                                    ? (openBlock(), createElementBlock("span", _hoisted_25, "AI辅助"))
                                    : createCommentVNode("", true)
                                ]),
                                createBaseVNode("span", {
                                  class: normalizeClass(["result-status", { success: result.success, error: !result.success }])
                                }, toDisplayString(result.success ? '成功' : '失败'), 3)
                              ]),
                              createBaseVNode("div", _hoisted_26, toDisplayString(result.message), 1),
                              (result.question)
                                ? (openBlock(), createElementBlock("div", _hoisted_27, "题目: " + toDisplayString(result.question), 1))
                                : createCommentVNode("", true),
                              (result.answer)
                                ? (openBlock(), createElementBlock("div", _hoisted_28, "答案: " + toDisplayString(result.answer), 1))
                                : createCommentVNode("", true),
                              (result.selectedOptions && result.selectedOptions.length > 0)
                                ? (openBlock(), createElementBlock("div", _hoisted_29, " 选择: " + toDisplayString(result.selectedOptions.join(', ')), 1))
                                : createCommentVNode("", true)
                            ], 2))
                          }), 128))
                        ])
                      ]))
                    : createCommentVNode("", true)
                ]),
                (progressInfo.value)
                  ? (openBlock(), createElementBlock("div", _hoisted_30, [
                      _cache[6] || (_cache[6] = createBaseVNode("h3", null, "答题进度", -1)),
                      createBaseVNode("div", _hoisted_31, [
                        createBaseVNode("div", _hoisted_32, "正在回答第 " + toDisplayString(progressInfo.value.current) + " 题...", 1),
                        createBaseVNode("div", _hoisted_33, toDisplayString(progressInfo.value.status), 1)
                      ])
                    ]))
                  : createCommentVNode("", true)
              ]))
            : createCommentVNode("", true),
          (currentSubpage.value === 'settings')
            ? (openBlock(), createElementBlock("div", _hoisted_34, [
                createVNode(AnswerSettingsPage)
              ]))
            : createCommentVNode("", true),
          (statusMessage.value)
            ? (openBlock(), createElementBlock("div", _hoisted_35, [
                createBaseVNode("div", {
                  class: normalizeClass(["status-message", { success: isSuccess.value, error: !isSuccess.value }])
                }, toDisplayString(statusMessage.value), 3)
              ]))
            : createCommentVNode("", true)
        ]))
      }
      }

      };
      const AutoAnswerPage = /*#__PURE__*/_export_sfc(_sfc_main$3, [['__scopeId',"data-v-c8c99884"]]);

      const _hoisted_1$2 = { class: "toggle-features" };
      const _hoisted_2$2 = { class: "toggle-item" };
      const _hoisted_3$2 = { class: "toggle-switch" };
      const _hoisted_4$2 = ["checked"];
      const _hoisted_5$2 = { class: "toggle-item" };
      const _hoisted_6$1 = { class: "toggle-switch" };
      const _hoisted_7$1 = ["checked"];
      const _hoisted_8$1 = { class: "modal-body" };
      const _hoisted_9 = { class: "setting-group" };
      const _hoisted_10 = { class: "image-input-group" };
      const _hoisted_11 = { class: "setting-group" };
      const _hoisted_12 = { class: "slider-group" };
      const _hoisted_13 = { class: "slider-value" };
      const _hoisted_14 = { class: "setting-group" };
      const _hoisted_15 = { class: "slider-group" };
      const _hoisted_16 = { class: "slider-value" };
      const _hoisted_17 = { class: "preview-section" };
      const _hoisted_18 = { class: "back-btn-container" };


      const _sfc_main$2 = {
        __name: 'AdvancedSettingsPage',
        emits: ['navigate'],
        setup(__props, { emit: __emit }) {

      const operationLogEnabled = ref(true); // 当前显示状态
      const userOperationLogPref = ref(true); // 用户操作日志偏好，默认开启
      const showRainbowModal = ref(false);
      const fileInput = ref(null);

      // 使用全局Rainbow状态
      const rainbowEnabled = ref(false);
      const rainbowSettings = ref({
        backgroundUrl: 'https://images.unsplash.com/photo-1593642532973-d31b6557fa68?auto=format&fit=crop&w=1920&q=80',
        backgroundOpacity: 0.9,
        glassEffectIntensity: 15
      });

      // 预览样式
      const previewStyle = computed(() => ({
        backgroundImage: `url(${rainbowSettings.value.backgroundUrl})`,
        backgroundSize: 'cover',
        backgroundPosition: 'center',
        opacity: 1 // 背景图片始终保持完全不透明
      }));

      const previewGlassStyle = computed(() => ({
        backdropFilter: `blur(${rainbowSettings.value.glassEffectIntensity}px)`
      }));

      onMounted(async () => {
        // 同步全局Rainbow状态
        if (window.beelineHelperApp) {
          // 同步Rainbow启用状态
          if (window.beelineHelperApp.rainbowEnabled && typeof window.beelineHelperApp.rainbowEnabled === 'object' && 'value' in window.beelineHelperApp.rainbowEnabled) {
            rainbowEnabled.value = window.beelineHelperApp.rainbowEnabled.value;
          } else if (window.beelineHelperApp.rainbowEnabled !== undefined) {
            rainbowEnabled.value = window.beelineHelperApp.rainbowEnabled;
          }

          // 同步Rainbow设置
          if (window.beelineHelperApp.rainbowSettings && typeof window.beelineHelperApp.rainbowSettings === 'object' && 'value' in window.beelineHelperApp.rainbowSettings) {
            rainbowSettings.value = { ...rainbowSettings.value, ...window.beelineHelperApp.rainbowSettings.value };
          } else if (window.beelineHelperApp.rainbowSettings) {
            rainbowSettings.value = { ...rainbowSettings.value, ...window.beelineHelperApp.rainbowSettings };
          }
        }

        // 初始化用户偏好
        if (window.beelineHelperApp) {
          if (window.beelineHelperApp.userOperationLogPref && typeof window.beelineHelperApp.userOperationLogPref === 'object' && 'value' in window.beelineHelperApp.userOperationLogPref) {
            userOperationLogPref.value = window.beelineHelperApp.userOperationLogPref.value;
          } else if (window.beelineHelperApp.userOperationLogPref !== undefined) {
            userOperationLogPref.value = window.beelineHelperApp.userOperationLogPref;
          }

          // 显示状态完全由用户偏好决定
          operationLogEnabled.value = !!userOperationLogPref.value;
        } else {
          operationLogEnabled.value = userOperationLogPref.value;
        }
      });

      const handleOperationLogToggle = async () => {
        // 切换用户偏好（持久化的开关），而不是直接切换 transient 的显示状态
        userOperationLogPref.value = !userOperationLogPref.value;

        try {
          console.log(`操作日志偏好已设置为: ${userOperationLogPref.value ? '开启' : '关闭'}`);

          // 同步主应用中的偏好与显示状态
          if (window.beelineHelperApp) {
            if (window.beelineHelperApp.userOperationLogPref && typeof window.beelineHelperApp.userOperationLogPref === 'object' && 'value' in window.beelineHelperApp.userOperationLogPref) {
              window.beelineHelperApp.userOperationLogPref.value = userOperationLogPref.value;
            } else {
              window.beelineHelperApp.userOperationLogPref = userOperationLogPref.value;
            }

            // 显示状态完全由用户偏好决定
            operationLogEnabled.value = !!userOperationLogPref.value;

            // 直接更新主应用中的操作日志状态
            if (window.beelineHelperApp.operationLogEnabled && typeof window.beelineHelperApp.operationLogEnabled === 'object' && 'value' in window.beelineHelperApp.operationLogEnabled) {
              window.beelineHelperApp.operationLogEnabled.value = operationLogEnabled.value;
            } else {
              window.beelineHelperApp.operationLogEnabled = operationLogEnabled.value;
            }

            // 使用统一保存函数（如果可用）保证一致性
            if (typeof window.beelineHelperApp.saveFeatureStates === 'function') {
              try {
                await window.beelineHelperApp.saveFeatureStates();
                console.log('操作日志偏好已保存到存储');
              } catch (e) {
                console.warn('saveFeatureStates failed:', e);
              }
            } else {
              console.warn('saveFeatureStates 函数不可用');
            }
          }
        } catch (e) {
          console.warn('handleOperationLogToggle 出错:', e);
        }
      };

      const handleRainbowToggle = async () => {
        rainbowEnabled.value = !rainbowEnabled.value;

        console.log('切换Rainbow状态:', rainbowEnabled.value);

        try {
          console.log(`Rainbow已${rainbowEnabled.value ? '开启' : '关闭'}`, rainbowEnabled.value);

          // 更新主应用中的Rainbow状态（支持 ref 或原始布尔）
          if (window.beelineHelperApp) {
            if (window.beelineHelperApp.rainbowEnabled && typeof window.beelineHelperApp.rainbowEnabled === 'object' && 'value' in window.beelineHelperApp.rainbowEnabled) {
              window.beelineHelperApp.rainbowEnabled.value = rainbowEnabled.value;
            } else {
              window.beelineHelperApp.rainbowEnabled = rainbowEnabled.value;
            }

            // 如果开启Rainbow，应用样式
            if (rainbowEnabled.value) {
              if (window.beelineHelperApp.applyRainbowStyles) {
                setTimeout(() => {
                  window.beelineHelperApp.applyRainbowStyles();
                }, 100);
              }
            } else {
              if (window.beelineHelperApp.removeRainbowStyles) {
                window.beelineHelperApp.removeRainbowStyles();
              }
            }

            // 保存设置
            if (typeof window.beelineHelperApp.saveFeatureStates === 'function') {
              try { window.beelineHelperApp.saveFeatureStates(); } catch (e) { console.warn('saveFeatureStates failed:', e); }
            }
          }
        } catch (e) {
          console.warn('handleRainbowToggle 出错:', e);
        }
      };

      const showRainbowSettings = () => {
        showRainbowModal.value = true;
      };

      const closeRainbowModal = () => {
        showRainbowModal.value = false;
      };

      const triggerFileInput = () => {
        fileInput.value?.click();
      };

      const handleFileUpload = (event) => {
        const file = event.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = (e) => {
            rainbowSettings.value.backgroundUrl = e.target.result;
          };
          reader.readAsDataURL(file);
        }
      };

      const saveRainbowSettings = async () => {
        try {
          console.log('保存Rainbow设置:', rainbowSettings.value);

          // 验证背景URL
          if (!rainbowSettings.value.backgroundUrl) {
            alert('请设置背景图片URL或选择本地图片');
            return
          }

          // 更新主应用中的Rainbow设置
          if (window.beelineHelperApp) {
            if (window.beelineHelperApp.rainbowSettings && typeof window.beelineHelperApp.rainbowSettings === 'object' && 'value' in window.beelineHelperApp.rainbowSettings) {
              window.beelineHelperApp.rainbowSettings.value = { ...rainbowSettings.value };
            } else {
              window.beelineHelperApp.rainbowSettings = { ...rainbowSettings.value };
            }

            console.log('Rainbow设置已保存');
            closeRainbowModal();

            // 如果Rainbow已开启，重新应用样式
            if (rainbowEnabled.value) {
              if (window.beelineHelperApp.applyRainbowStyles) {
                setTimeout(() => {
                  window.beelineHelperApp.applyRainbowStyles();
                }, 100);
              }
            }

            // 保存设置
            if (typeof window.beelineHelperApp.saveFeatureStates === 'function') {
              try { window.beelineHelperApp.saveFeatureStates(); } catch (e) { console.warn('saveFeatureStates failed:', e); }
            }
          }
        } catch (error) {
          console.error('保存Rainbow设置失败:', error);

          if (error.name === 'QuotaExceededError') {
            alert('存储空间不足，无法保存设置。请选择较小的背景图片或使用URL链接。');
          } else {
            alert('保存设置失败，请重试。');
          }
        }
      };

      return (_ctx, _cache) => {
        return (openBlock(), createElementBlock("div", null, [
          _cache[15] || (_cache[15] = createBaseVNode("h3", null, "高级设置", -1)),
          createBaseVNode("div", _hoisted_1$2, [
            createBaseVNode("div", _hoisted_2$2, [
              _cache[6] || (_cache[6] = createBaseVNode("span", { class: "toggle-label" }, "操作日志", -1)),
              createBaseVNode("label", _hoisted_3$2, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: operationLogEnabled.value,
                  onChange: handleOperationLogToggle
                }, null, 40, _hoisted_4$2),
                _cache[5] || (_cache[5] = createBaseVNode("span", { class: "toggle-slider" }, null, -1))
              ])
            ]),
            createBaseVNode("div", _hoisted_5$2, [
              createBaseVNode("div", { class: "toggle-label-container" }, [
                _cache[8] || (_cache[8] = createBaseVNode("span", { class: "toggle-label" }, "?Rainbow", -1)),
                createBaseVNode("button", {
                  class: "settings-icon",
                  onClick: showRainbowSettings,
                  title: "Rainbow设置"
                }, [...(_cache[7] || (_cache[7] = [
                  createBaseVNode("svg", {
                    width: "16",
                    height: "16",
                    viewBox: "0 0 24 24",
                    fill: "none",
                    stroke: "currentColor",
                    "stroke-width": "2"
                  }, [
                    createBaseVNode("path", { d: "M12 15a3 3 0 1 0 0-6 3 3 0 0 0 0 6Z" }),
                    createBaseVNode("path", { d: "M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1Z" })
                  ], -1)
                ]))])
              ]),
              createBaseVNode("label", _hoisted_6$1, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: rainbowEnabled.value,
                  onChange: handleRainbowToggle
                }, null, 40, _hoisted_7$1),
                _cache[9] || (_cache[9] = createBaseVNode("span", { class: "toggle-slider rainbow-toggle" }, null, -1))
              ])
            ])
          ]),
          (showRainbowModal.value)
            ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: "modal-overlay",
                onClick: closeRainbowModal
              }, [
                createBaseVNode("div", {
                  class: "modal-content",
                  onClick: _cache[3] || (_cache[3] = withModifiers(() => {}, ["stop"]))
                }, [
                  createBaseVNode("div", { class: "modal-header" }, [
                    _cache[10] || (_cache[10] = createBaseVNode("h4", null, "Rainbow设置", -1)),
                    createBaseVNode("button", {
                      class: "close-btn",
                      onClick: closeRainbowModal
                    }, "×")
                  ]),
                  createBaseVNode("div", _hoisted_8$1, [
                    createBaseVNode("div", _hoisted_9, [
                      _cache[11] || (_cache[11] = createBaseVNode("label", { class: "setting-label" }, "背景图片", -1)),
                      createBaseVNode("div", _hoisted_10, [
                        withDirectives(createBaseVNode("input", {
                          type: "text",
                          "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => ((rainbowSettings.value.backgroundUrl) = $event)),
                          placeholder: "输入图片URL或选择本地图片",
                          class: "url-input"
                        }, null, 512), [
                          [vModelText, rainbowSettings.value.backgroundUrl]
                        ]),
                        createBaseVNode("input", {
                          type: "file",
                          ref_key: "fileInput",
                          ref: fileInput,
                          accept: "image/*",
                          onChange: handleFileUpload,
                          class: "file-input",
                          style: {"display":"none"}
                        }, null, 544),
                        createBaseVNode("button", {
                          class: "upload-btn",
                          onClick: triggerFileInput
                        }, "选择图片")
                      ])
                    ]),
                    createBaseVNode("div", _hoisted_11, [
                      _cache[12] || (_cache[12] = createBaseVNode("label", { class: "setting-label" }, "背景透明度", -1)),
                      createBaseVNode("div", _hoisted_12, [
                        withDirectives(createBaseVNode("input", {
                          type: "range",
                          "onUpdate:modelValue": _cache[1] || (_cache[1] = $event => ((rainbowSettings.value.backgroundOpacity) = $event)),
                          min: "0.1",
                          max: "1",
                          step: "0.05",
                          class: "slider"
                        }, null, 512), [
                          [vModelText, rainbowSettings.value.backgroundOpacity]
                        ]),
                        createBaseVNode("span", _hoisted_13, toDisplayString((rainbowSettings.value.backgroundOpacity * 100).toFixed(0)) + "%", 1)
                      ])
                    ]),
                    createBaseVNode("div", _hoisted_14, [
                      _cache[13] || (_cache[13] = createBaseVNode("label", { class: "setting-label" }, "毛玻璃效果强度", -1)),
                      createBaseVNode("div", _hoisted_15, [
                        withDirectives(createBaseVNode("input", {
                          type: "range",
                          "onUpdate:modelValue": _cache[2] || (_cache[2] = $event => ((rainbowSettings.value.glassEffectIntensity) = $event)),
                          min: "0",
                          max: "40",
                          step: "1",
                          class: "slider"
                        }, null, 512), [
                          [vModelText, rainbowSettings.value.glassEffectIntensity]
                        ]),
                        createBaseVNode("span", _hoisted_16, toDisplayString(rainbowSettings.value.glassEffectIntensity) + "px", 1)
                      ])
                    ]),
                    createBaseVNode("div", _hoisted_17, [
                      _cache[14] || (_cache[14] = createBaseVNode("h5", null, "预览", -1)),
                      createBaseVNode("div", {
                        class: "preview-box",
                        style: normalizeStyle(previewStyle.value)
                      }, [
                        createBaseVNode("div", {
                          class: "preview-overlay",
                          style: normalizeStyle({ opacity: 1 - rainbowSettings.value.backgroundOpacity })
                        }, null, 4),
                        createBaseVNode("div", {
                          class: "preview-glass",
                          style: normalizeStyle(previewGlassStyle.value)
                        }, " 毛玻璃效果预览 ", 4)
                      ], 4)
                    ])
                  ]),
                  createBaseVNode("div", { class: "modal-footer" }, [
                    createBaseVNode("button", {
                      class: "save-btn",
                      onClick: saveRainbowSettings
                    }, "保存设置"),
                    createBaseVNode("button", {
                      class: "cancel-btn",
                      onClick: closeRainbowModal
                    }, "取消")
                  ])
                ])
              ]))
            : createCommentVNode("", true),
          createBaseVNode("div", _hoisted_18, [
            createBaseVNode("button", {
              class: "back-btn",
              onClick: _cache[4] || (_cache[4] = $event => (_ctx.$emit('navigate', 'main')))
            }, "返回")
          ])
        ]))
      }
      }

      };
      const AdvancedSettingsPage = /*#__PURE__*/_export_sfc(_sfc_main$2, [['__scopeId',"data-v-cd8b7e2c"]]);

      const _imports_0 = "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD/4QAiRXhpZgAATU0AKgAAAAgAAQESAAMAAAABAAEAAAAAAAD/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wAARCAK8A4QDASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwBKKKK5z5cKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigEdtpv8AyDrb/rmv8qtVW03/AJB1t/1zX+VWa6D6aHwoWiiigoKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooo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HnGFFFFAHTeGP+POX/rp/QVtVi+GP+POX/rp/QVtVvHY+hw38KItFFFM3CiiigAooooAKKKKACiiigAooooAKKKKACiiigBKWiigAooooAKKKKACiiigAooooASjFLRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFJS0lAGL4o/wCPOL/rp/Q1zNdN4o/484v+un9DXM1jPc8THfxQoooqUcRWb77fWkpW++31pK+sp/AjrWwUUUVoMKKKKACiiikwO/0v/kG2/wDuCrlU9L/5Btv/ALgq5XzU/iZ7UPhQUUUVJQUUUUAFFFFABRRRQAUUUUAFFFFABRRRQBT1My/ZGWJIXLfKVmfaCD71ymjJepqLZNtL9jzEgkmwEGe3HNdhdWsF3F5dzEkqZztYZGaxNM0GBL29NzYx+X5uYcqCNvtQBN4uz/YMhA6MpI/Gm2+gwXtuk+ptJcTOoOPMKqnsoBrVvbSO8spbWQYSRdvHase2utW0yIWs+nPdiP5UmicfMO2c9KADThJpeutpnnPLbSReZEHOSnOMVr6jn+zbrb18psfkaztLsruXUpNT1BBFIybI4Qc7F9z61c0+e8uTcLe2ggVXKpznetAGFoGlrqelQyXzu8K5WOFWKqAOMnHU1NNbf2BqVmbOST7LcyeW8LMWAPYjNSQJqGhPJDDaNeWTMWTY2Gjz1GO9OS3vtW1GC5vLb7LbW53JEWyzt6mgBbM7fF9+rdWhQj6YrauGC28rN90ISfyrL1axuftcOpaeFa4iG1oyceYvpn1qtc3OrarAbSLT3s1k4kllccDvj1oAn8JAjQos9CzEfTca2qhtLZLS1jt4h8kahRU1AC0UUUAFFFFABRRRQAUUUUAFFFFABRRRQAUlLSUAcz4w+/a/8C/pXN10njD79r/wL+lc3Xu4P+CjysR/EYUUUV1mAUUUUAFFFFABRRRQBaooor484wooooA6bwx/x5y/9dP6CtqsPwu4+zzJ3D5P4j/61blbx2PoML/CQtFJS0zoCiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooASiiigDF8Uf8ecX/XT+hrma6TxQ6i3hTPJfP5D/wCvXN1jPc8PGv8AehRRRUo4ys33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Ub97QmWKgloLql6b+9ebovRB6CqlFFexCKhFRR58m5O7CiiirJCiiigAooooAKKKKALVFFFfHnGFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQgKzffb60lK332+tJX1lP4Eda2CiiitBhRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQBaooor484wooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKEBWb77fWkpW++31pK+sp/AjrWwUUUVoMKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/Z";

      const _hoisted_1$1 = { class: "right-panel" };
      const _hoisted_2$1 = { class: "agree-label" };
      const _hoisted_3$1 = ["disabled"];
      const _hoisted_4$1 = { key: 0 };
      const _hoisted_5$1 = { key: 1 };


      const _sfc_main$1 = {
        __name: 'AboutPage',
        emits: ["close"],
        setup(__props, { emit: __emit }) {

      const agreeChecked = ref(false);
      const countdown = ref(15);
      const countdownActive = ref(true);
      const isClosing = ref(false);

      // 加载/保存同意状态
      const loadAgreeState = async () => {
        const saved = await getStorageValue$1("beelineHelper_agreeState");
        if (saved !== null) agreeChecked.value = saved;
      };

      const saveAgreeState = async () => {
        await setStorageValue("beelineHelper_agreeState", agreeChecked.value);
      };

      // 倒计时逻辑
      const startCountdown = () => {
        // 如果已经同意，直接跳过倒计时
        if (agreeChecked.value) {
          countdownActive.value = false;
          return;
        }

        const timer = setInterval(() => {
          if (countdown.value > 0) {
            countdown.value--;
          } else {
            clearInterval(timer);
            countdownActive.value = false;
          }
        }, 1000);
      };

      // 改为 emit 事件
      const emit = __emit;

      // 关闭页面动画
      const handleClose = () => {
        isClosing.value = true;
        setTimeout(() => {
          emit("close");
        }, 300); // 动画持续时间
      };

      onMounted(async () => {
        await loadAgreeState();
        startCountdown();
      });

      return (_ctx, _cache) => {
        return (openBlock(), createElementBlock("div", {
          class: normalizeClass(["about-page", { 'closing': isClosing.value }])
        }, [
          _cache[3] || (_cache[3] = createStaticVNode("<div class=\"left-panel\" data-v-30e112b7><h2 class=\"title gradient-text\" data-v-30e112b7>💰 支持项目 ¥6.6</h2><div class=\"image-box\" data-v-30e112b7><img src=\"" + _imports_0 + "\" class=\"pay-image\" data-v-30e112b7></div><p class=\"subtitle\" data-v-30e112b7>扫码支付，支持开发 ❤️</p></div>", 1)),
          createBaseVNode("div", _hoisted_1$1, [
            _cache[2] || (_cache[2] = createStaticVNode("<h2 class=\"title main-title\" data-v-30e112b7>无人看守的诚信小卖铺</h2><div class=\"content\" data-v-30e112b7><div class=\"info-block\" data-v-30e112b7><h3 class=\"section-title\" data-v-30e112b7>功能说明</h3><p data-v-30e112b7>视频相关的全部功能———永久免费</p><p data-v-30e112b7>刷题目前已支持主观题，视频内题目和填空题暂不支持！</p><p data-v-30e112b7>考试答题暂未测试，谨慎使用</p><p class=\"highlight\" data-v-30e112b7><b data-v-30e112b7>自动答题 ¥6.6/人 永久使用</b>，感谢支持 😋</p></div><div class=\"info-block\" data-v-30e112b7><h3 class=\"section-title\" data-v-30e112b7>注意事项</h3><p data-v-30e112b7>自动答题请手动开始，避免Token浪费</p><p class=\"warning\" data-v-30e112b7>❗请务必确认答案正确且多选题已选中并正确选中后再提交❗</p><p data-v-30e112b7>题库并非本人维护，请自行判断。AI生成内容务必检查！</p><p class=\"highlight\" data-v-30e112b7><b data-v-30e112b7>本脚本仅供个人学习与测试使用，禁止用于任何商业用途，作者不承担由此产生的任何责任</b></p></div></div><p class=\"feedback\" data-v-30e112b7> 反馈与下载请到 <a href=\"https://scriptcat.org/zh-CN/script-show-page/4463\" target=\"_blank\" data-v-30e112b7>脚本猫</a> 或 <a href=\"https://greasyfork.org/zh-CN/scripts/490485\" target=\"_blank\" data-v-30e112b7>GreasyFork</a> 或 发送邮件到2665002659@qq.com </p>", 3)),
            createBaseVNode("label", _hoisted_2$1, [
              withDirectives(createBaseVNode("input", {
                type: "checkbox",
                "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => ((agreeChecked).value = $event)),
                disabled: countdownActive.value,
                onChange: saveAgreeState
              }, null, 40, _hoisted_3$1), [
                [vModelCheckbox, agreeChecked.value]
              ]),
              (countdownActive.value)
                ? (openBlock(), createElementBlock("span", _hoisted_4$1, " 我已诚信付款并认真阅读上述文字 (" + toDisplayString(countdown.value) + "秒) ", 1))
                : (openBlock(), createElementBlock("span", _hoisted_5$1, [...(_cache[1] || (_cache[1] = [
                    createTextVNode(" 我已诚信付款并认真阅读上述文字 ", -1),
                    createBaseVNode("a", {
                      href: "https://www.yuque.com/u25901777/kb/wc92tttd0f8dw67f?singleDoc#",
                      target: "_blank",
                      class: "guide-link-inline"
                    }, " 📖 使用说明 ", -1)
                  ]))]))
            ]),
            createBaseVNode("button", {
              onClick: handleClose,
              class: "close-btn"
            }, "关闭")
          ])
        ], 2))
      }
      }

      };
      const AboutPage = /*#__PURE__*/_export_sfc(_sfc_main$1, [['__scopeId',"data-v-30e112b7"]]);

      const _hoisted_1 = { class: "beeline-helper" };
      const _hoisted_2 = { class: "page-container" };
      const _hoisted_3 = {
        key: 0,
        class: "page-wrapper"
      };
      const _hoisted_4 = {
        key: 0,
        class: "page-wrapper"
      };
      const _hoisted_5 = {
        key: 0,
        class: "page-wrapper"
      };
      const _hoisted_6 = {
        key: 0,
        class: "page-wrapper"
      };
      const _hoisted_7 = {
        key: 0,
        class: "about-overlay"
      };
      const _hoisted_8 = { class: "about-container" };


      const _sfc_main = {
        __name: 'App',
        setup(__props) {

      const isWindowVisible = ref(false);
      const currentPage = ref('main'); // 当前页面：main, auto-course (操作日志)
      const autoCompleteEnabled = ref(false); // 自动点击完成按钮开关状态
      const autoMuteEnabled = ref(false); // 自动静音开关状态
      const FxxKXinWeiEnabled = ref(false); // FxxKXinWei功能开关状态
      const operationLogEnabled = ref(true); // 操作日志开关状态
      const rainbowEnabled = ref(false); // Rainbow效果开关状态
      const rainbowSettings = ref({
        backgroundUrl: 'https://bing.img.run/rand.php',
        backgroundOpacity: 1.0,
        glassEffectIntensity: 15
      }); // Rainbow设置
      const autoCompleteInterval = ref(null); // 自动检测定时器
      const stateExceptionInterval = ref(null); // 状态异常检测定时器
      const operationHistory = ref([]); // 操作历史记录
      const currentStatus = ref('未启动'); // 当前工作状态
      const isCoursePage = ref(false); // 是否在课程页面
      const showAboutPage = ref(false); // 是否显示关于页面
      const noVideoPlaybackTimer = ref(null); // 无视频播放计时器
      const lastVideoPlaybackTime = ref(null); // 最后视频播放时间戳

      // 计算页面标题
      const pageTitle = computed(() => {
        const titles = {
          'main': 'Beeline Helper',
          'auto-course': '全自动刷课配置',
          'auto-answer': '自动答题',
          'advanced-settings': '高级设置'
        };
        return titles[currentPage.value] || 'Beeline Helper'
      });

      const toggleWindow = () => {
        isWindowVisible.value = !isWindowVisible.value;
      };

      const closeWindow = () => {
        isWindowVisible.value = false;
        // 关闭窗口时回到主页面
        currentPage.value = 'main';
      };

      // 页面导航
      const navigateTo = (page) => {
        currentPage.value = page;
      };

      // 返回上一页
      const goBack = () => {
        currentPage.value = 'main';
      };


      // 存储功能开关状态
      const saveFeatureStates = async () => {
        const states = {
          autoCompleteEnabled: autoCompleteEnabled.value,
          autoMuteEnabled: autoMuteEnabled.value,
          FxxKXinWeiEnabled: FxxKXinWeiEnabled.value,
          operationLogEnabled: operationLogEnabled.value, // This is the state that controls visibility
          rainbowEnabled: rainbowEnabled.value,
          rainbowSettings: rainbowSettings.value
        };
        console.log('保存功能状态到存储:', states);
        await setStorageValue('beelineHelper_featureStates', states);
      };

      // 加载功能开关状态
      const loadFeatureStates = async () => {
        const states = await getStorageValue$1('beelineHelper_featureStates');
        console.log('从存储加载功能状态:', states);
        if (states) {
          try {
            autoCompleteEnabled.value = states.autoCompleteEnabled || false;
            autoMuteEnabled.value = states.autoMuteEnabled || false;
            FxxKXinWeiEnabled.value = states.FxxKXinWeiEnabled || false;
            operationLogEnabled.value = states.operationLogEnabled !== undefined ? states.operationLogEnabled : true; // Explicitly set based on loaded state
            rainbowEnabled.value = states.rainbowEnabled || false;

            // The userOperationLogPref is now a direct reference to operationLogEnabled.
            // So no need to separately load it here.

            // 加载Rainbow设置
            if (states.rainbowSettings) {
              rainbowSettings.value = {
                backgroundUrl: states.rainbowSettings.backgroundUrl || 'https://images.unsplash.com/photo-1593642532973-d31b6557fa68?auto=format&fit=crop&w=1920&q=80',
                backgroundOpacity: states.rainbowSettings.backgroundOpacity || 0.9,
                glassEffectIntensity: states.rainbowSettings.glassEffectIntensity || 15
              };
            }

            // 根据加载的状态启动相应的功能
            if (autoCompleteEnabled.value) {
              startAutoCompleteDetection();
            }
            if (autoMuteEnabled.value) {
              startAutoMute();
            }
            if (FxxKXinWeiEnabled.value) {
              startFxxKXinWei();
            }
            if (rainbowEnabled.value) {
              // 延迟应用Rainbow样式，确保DOM已加载
              setTimeout(() => {
                applyRainbowStyles();
              }, 100);
            }
          } catch (e) {
            console.warn('Failed to load feature states:', e);
          }
        }
        // Removed redundant check for 'beeline-helper-operation-log' as all states are under 'beelineHelper_featureStates'
      };

      // 自动点击完成按钮开关处理
      const handleAutoCompleteToggle = (enabled) => {
        autoCompleteEnabled.value = enabled;
        if (enabled) {
          startAutoCompleteDetection();
        } else {
          stopAutoCompleteDetection();
        }
        saveFeatureStates();
      };

      // 自动静音开关处理
      const handleAutoMuteToggle = (enabled) => {
        autoMuteEnabled.value = enabled;
        if (enabled) {
          startAutoMute();
        } else {
          stopAutoMute();
        }
        saveFeatureStates();
      };

      // FxxKXinWei功能开关处理
      const handleFxxKXinWeiToggle = (enabled) => {
        FxxKXinWeiEnabled.value = enabled;
        console.log('FxxKXinWei功能开关状态:', enabled ? '开启' : '关闭');
        if (enabled) {
          startFxxKXinWei();
        } else {
          stopFxxKXinWei();
        }
        saveFeatureStates();
      };

      // 检查是否在作业页面
      const checkIsHomeworkPage = () => {
        const currentUrl = window.location.href.toLowerCase();

        // 检查是否是题目页面（包含homeworkPaperId）
        const isQuestionPage = currentUrl.includes('homeworkpaperid');

        // 如果是题目页面，自动打开自动答题页面
        if (isQuestionPage && currentPage.value !== 'auto-answer') {
          currentPage.value = 'auto-answer';
          isWindowVisible.value = true;
        }

        return isQuestionPage
      };

      // 检查是否在课程页面
      const checkIsCoursePage = () => {
        const currentUrl = window.location.href.toLowerCase();

        // 检查是否是课程页面（包含/courseInfo/learn/courseWare/和/video/）
        const isCoursePage = currentUrl.includes('/courseinfo/learn/courseware/') && currentUrl.includes('/video/');

        // 检查页面是否包含视频播放器相关元素
        const hasVideoElements = document.querySelectorAll('video').length > 0;
        const hasVideoPlayer = document.querySelector('.video-player, [class*="video"], [class*="player"]');

        return isCoursePage && (hasVideoElements || hasVideoPlayer)
      };

      // 拦截网络请求检测题目页面
      const setupNetworkMonitoring = () => {
        if (window.beelineHelperNetworkMonitoringEnabled) return // 避免重复设置
        window.beelineHelperNetworkMonitoringEnabled = true;

        // 保存原始的fetch函数
        window.originalFetch = window.fetch;

        window.fetch = async function(...args) {
          const url = args[0];

          // 检查是否是题目页面请求
          if (typeof url === 'string' && url.includes('/api/learning-service/admin/studentLearning/getHomeworkPaperDetail/')) {
            console.log('检测到题目页面请求:', url);

            // 如果是题目页面，自动打开自动答题页面并重置位置
            if (currentPage.value !== 'auto-answer') {
              currentPage.value = 'auto-answer';
              isWindowVisible.value = true;

              // 重置浮窗位置到屏幕最左侧
              setTimeout(() => {
                const floatingWindow = document.querySelector('.floating-window');
                if (floatingWindow) {
                  floatingWindow.style.left = '20px';
                  floatingWindow.style.top = '20px';
                }
              }, 100);
            }
          }

          return window.originalFetch(...args)
        };

        // 拦截XMLHttpRequest
        if (!window.originalXMLHttpRequest) {
          window.originalXMLHttpRequest = window.XMLHttpRequest;

          window.XMLHttpRequest = function() {
            const xhr = new window.originalXMLHttpRequest();
            const originalOpen = xhr.open;
            const originalSend = xhr.send;

            xhr.open = function(method, url, ...rest) {
              this._url = url;
              return originalOpen.call(this, method, url, ...rest)
            };

            xhr.send = function(data) {
              // 检查是否是题目页面请求
              if (this._url && this._url.includes('/api/learning-service/admin/studentLearning/getHomeworkPaperDetail/')) {
                console.log('检测到题目页面请求(XHR):', this._url);

                // 如果是题目页面，自动打开自动答题页面并重置位置
                if (currentPage.value !== 'auto-answer') {
                  currentPage.value = 'auto-answer';
                  isWindowVisible.value = true;

                  // 重置浮窗位置到屏幕最左侧
                  setTimeout(() => {
                    const floatingWindow = document.querySelector('.floating-window');
                    if (floatingWindow) {
                      floatingWindow.style.left = '20px';
                      floatingWindow.style.top = '20px';
                    }
                  }, 100);
                }
              }

              return originalSend.call(this, data)
            };

            return xhr
          };
        }
      };

      // 停止网络监控
      const stopNetworkMonitoring = () => {
        if (!window.beelineHelperNetworkMonitoringEnabled) return
        window.beelineHelperNetworkMonitoringEnabled = false;

        // 恢复原始fetch函数
        if (window.originalFetch) {
          window.fetch = window.originalFetch;
          delete window.originalFetch;
        }

        // 恢复原始XMLHttpRequest
        if (window.originalXMLHttpRequest) {
          window.XMLHttpRequest = window.originalXMLHttpRequest;
          delete window.originalXMLHttpRequest;
        }

        console.log('网络监控已停止');
      };

      // 启动自动检测
      const startAutoCompleteDetection = () => {
        currentStatus.value = '检测中...';
        addToHistory('开始自动检测刷课按钮');

        // 每3秒检测一次
        autoCompleteInterval.value = setInterval(autoCompleteCourse, 3000);

        // 立即执行一次检测
        autoCompleteCourse();
      };

      // 停止自动检测
      const stopAutoCompleteDetection = () => {
        if (autoCompleteInterval.value) {
          clearInterval(autoCompleteInterval.value);
          autoCompleteInterval.value = null;
        }
        currentStatus.value = '已停止';
        addToHistory('停止自动检测');
      };

      // 自动刷课功能
      const autoCompleteCourse = () => {
        const buttonSelector = "#videoLayer > div > div > div.button-box > div.left";

        // 检查按钮是否存在
        const button = document.querySelector(buttonSelector);
        if (button) {
          // 显示状态信息
          console.log('检测到刷课按钮，3秒后自动点击...');
          currentStatus.value = '检测到按钮，等待点击...';
          addToHistory('检测到刷课按钮');

          // 延迟3秒后点击
          setTimeout(() => {
            button.click();
            console.log('已自动点击刷课按钮');
            currentStatus.value = '已点击完成按钮';
            addToHistory('已点击刷课按钮');
          }, 3000);
        } else {
          currentStatus.value = '未检测到按钮';
        }
      };

      // 自动静音功能
      const startAutoMute = () => {
        addToHistory('开始自动静音检测');

        // 查找视频元素并静音
        const videoElements = document.querySelectorAll('video');
        if (videoElements.length > 0) {
          videoElements.forEach((video, index) => {
            video.muted = true;
            console.log(`已静音视频 ${index + 1}`);
          });
          addToHistory(`已静音 ${videoElements.length} 个视频`);
        } else {
          addToHistory('未找到视频元素');
        }

        // 监听新视频元素的创建
        const observer = new MutationObserver((mutations) => {
          mutations.forEach((mutation) => {
            mutation.addedNodes.forEach((node) => {
              if (node.nodeType === 1) { // Element node
                // 检查新增节点中的视频元素
                const videos = node.querySelectorAll ? node.querySelectorAll('video') : [];
                videos.forEach((video) => {
                  video.muted = true;
                  console.log('检测到新视频，已自动静音');
                  addToHistory('检测到新视频，已自动静音');
                });

                // 如果节点本身就是视频元素
                if (node.tagName === 'VIDEO') {
                  node.muted = true;
                  console.log('检测到新视频，已自动静音');
                  addToHistory('检测到新视频，已自动静音');
                }
              }
            });
          });
        });

        // 开始观察DOM变化
        observer.observe(document.body, {
          childList: true,
          subtree: true
        });

        // 保存observer以便后续停止
        window.beelineHelperMuteObserver = observer;
      };

      // 停止自动静音
      const stopAutoMute = () => {
        // 停止观察DOM变化
        if (window.beelineHelperMuteObserver) {
          window.beelineHelperMuteObserver.disconnect();
          window.beelineHelperMuteObserver = null;
        }

        // 恢复视频音量
        const videoElements = document.querySelectorAll('video');
        videoElements.forEach((video, index) => {
          video.muted = false;
          console.log(`已恢复视频 ${index + 1} 音量`);
        });

        addToHistory('已停止自动静音');
      };


      // 启动FxxKXinWei功能
      const startFxxKXinWei = () => {
        addToHistory('开始FxxKXinWei功能');
        currentStatus.value = '监控学习状态...';

        // 设置网络请求监控
        setupStateExceptionMonitoring();

        // 启动防挂机守护机制
        startAntiIdleProtection();
      };

      // 停止FxxKXinWei功能
      const stopFxxKXinWei = () => {
        // 停止DOM状态检测定时器
        if (stateExceptionInterval.value) {
          clearInterval(stateExceptionInterval.value);
          stateExceptionInterval.value = null;
        }

        // 停止防挂机守护机制
        stopAntiIdleProtection();

        // 停止课程页面无视频播放检测
        stopCoursePageDetection();

        // 停止状态异常网络监控
        stopStateExceptionMonitoring();

        currentStatus.value = '已停止';
        addToHistory('停止FxxKXinWei功能');
      };

      // 设置状态异常监控（FxxKXinWei功能）
      const setupStateExceptionMonitoring = () => {
        // 每2秒检测一次DOM状态、课程页面视频状态和视频播放错误
        stateExceptionInterval.value = setInterval(() => {
          const messageElement = document.querySelector('.el-message-box__container > div > p');

          if (messageElement) {
            const messageText = messageElement.textContent.trim();

            // 检测状态异常消息
            if (messageText === '当前视频不允许倍速播放' ||
                messageText === '系统检测到你的学习状态异常，请刷新后继续学习' ||
                messageText === '播放位置不合法') {
              console.log(`检测到状态异常消息: "${messageText}"，自动刷新页面...`);
              addToHistory(`检测到状态异常消息: "${messageText}"，自动刷新页面`);

              // 延迟2秒后刷新页面
              setTimeout(() => {
                window.location.reload();
              }, 2000);
            }
          }

          // 延迟检测视频播放错误，避免过早介入
          setTimeout(() => {
            const videoError = checkVideoError();
            if (videoError) {
              console.log(`检测到视频播放错误: "${videoError}"，自动刷新页面...`);
              addToHistory(`检测到视频播放错误: "${videoError}"，自动刷新页面`);

              // 延迟2秒后刷新页面
              setTimeout(() => {
                window.location.reload();
              }, 2000);
            }
          }, 5000); // 延迟5秒检测视频错误

          // 同时检测课程页面无视频播放状态
          checkCoursePageVideoStatus();
        }, 2000);
      };

      // 停止状态异常监控
      const stopStateExceptionMonitoring = () => {
        // 状态异常监控与DOM状态检测使用同一个定时器，已在stopFxxKXinWei中处理
        console.log('状态异常监控已停止');
      };


      // 检测是否有视频正在播放
      const checkVideoPlaying = () => {
        const videoElements = document.querySelectorAll('video');
        let isAnyVideoPlaying = false;

        if (videoElements.length > 0) {
          videoElements.forEach((video) => {
            // 检查视频是否正在播放
            if (video.readyState >= 1 && !video.paused && !video.ended) {
              isAnyVideoPlaying = true;
              lastVideoPlaybackTime.value = Date.now();
            }
          });
        }

        return isAnyVideoPlaying
      };

      // 停止课程页面无视频播放检测
      const stopCoursePageDetection = () => {
        // 清除无视频播放计时器
        if (noVideoPlaybackTimer.value) {
          clearTimeout(noVideoPlaybackTimer.value);
          noVideoPlaybackTimer.value = null;
        }

        // 重置状态
        lastVideoPlaybackTime.value = null;
        isCoursePage.value = false;

        console.log('课程页面无视频播放检测已停止');
      };

      // 检查课程页面视频状态
      const checkCoursePageVideoStatus = () => {
        const wasOnCoursePage = isCoursePage.value;
        isCoursePage.value = checkIsCoursePage();

        if (isCoursePage.value) {
          console.log('检测到课程页面，开始监控视频播放状态');

          const isVideoPlaying = checkVideoPlaying();

          if (isVideoPlaying) {
            // 有视频在播放，重置计时器
            if (noVideoPlaybackTimer.value) {
              clearTimeout(noVideoPlaybackTimer.value);
              noVideoPlaybackTimer.value = null;
              console.log('检测到视频播放，重置无视频播放计时器');
            }
          } else {
            // 没有视频在播放，启动或继续计时
            if (!noVideoPlaybackTimer.value) {
              console.log('检测到无视频播放，启动1分钟计时器');
              noVideoPlaybackTimer.value = setTimeout(() => {
                console.log('课程页面超过1分钟无视频播放，自动刷新页面...');
                addToHistory('课程页面超过1分钟无视频播放，自动刷新页面');

                // 延迟2秒后刷新页面
                setTimeout(() => {
                  window.location.reload();
                }, 2000);
              }, 60000); // 1分钟
            }
          }
        } else {
          // 不在课程页面，清除计时器
          if (noVideoPlaybackTimer.value) {
            clearTimeout(noVideoPlaybackTimer.value);
            noVideoPlaybackTimer.value = null;
            console.log('离开课程页面，清除无视频播放计时器');
          }

          // 如果刚从课程页面离开，记录状态变化
          if (wasOnCoursePage) {
            console.log('离开课程页面');
          }
        }
      };

      // 检测视频播放错误
      const checkVideoError = () => {
        // 检测错误对话框元素是否存在且有实际内容
        const errorDialog = document.querySelector("#videoDomId > div.vjs-error-display.vjs-modal-dialog > div");

        console.log('🔍 视频错误检测 - 选择器结果:', errorDialog);

        if (errorDialog) {
          // 错误对话框本身已经是内容元素，不需要再查询子元素
          const contentText = errorDialog.textContent.trim();

          console.log('🔍 检测到视频错误对话框，内容:', contentText || '(空)');
          console.log('🔍 错误对话框完整HTML:', errorDialog.outerHTML);
          console.log('🔍 错误对话框本身:', errorDialog);

          // 检查所有可能的文本内容
          console.log('🔍 innerText:', errorDialog.innerText);
          console.log('🔍 textContent:', errorDialog.textContent);
          console.log('🔍 innerHTML:', errorDialog.innerHTML);
          console.log('🔍 children:', errorDialog.children);

          if (contentText !== '') {
            console.warn('❌ 检测到视频播放错误对话框，内容:', contentText);
            return '视频播放错误'
          } else {
            console.log('✅ 错误对话框内容为空，跳过');
          }
        } else {
          console.log('✅ 未检测到视频错误对话框');

          // 调试：检查是否存在其他可能的错误元素
          const allErrorDialogs = document.querySelectorAll('div.vjs-error-display');
          console.log('🔍 所有可能的错误对话框:', allErrorDialogs.length);
          allErrorDialogs.forEach((dialog, index) => {
            console.log(`🔍 错误对话框 ${index + 1}:`, dialog);
            console.log(`🔍 错误对话框 ${index + 1} 父级:`, dialog.parentElement);
          });
        }
        return null
      };

      // 防挂机守护机制
      const startAntiIdleProtection = () => {
        addToHistory('启动防挂机守护机制');
        console.log('⚡ 芯位蜜线防挂机守护已加载完毕');

        /*****************************************************
         * 🎬 自动播放守护机制
         *****************************************************/
        const tryPlayAll = () => {
          const videos = document.querySelectorAll('video');
          if (videos.length === 0) return;
          videos.forEach(v => {
            if (v.paused || v.readyState < 2) {
              v.muted = true;
              const playPromise = v.play();
              if (playPromise) {
                playPromise.catch(err => console.warn('⚠️ 自动播放失败:', err));
              }
            }
          });
        };

        // 定时器防守循环（防止脚本强制暂停）
        const antiIdleInterval = setInterval(tryPlayAll, 3000);

        /*****************************************************
         * 👁️ DOM 监控机制
         * 检测页面中 video 元素变化，自动重新挂载播放守护
         *****************************************************/
        const observer = new MutationObserver(mutations => {
          for (const m of mutations) {
            if (m.addedNodes.length) {
              for (const node of m.addedNodes) {
                if (node.tagName === 'VIDEO' || (node.querySelector && node.querySelector('video'))) {
                  console.log('🎥 检测到新视频节点，自动播放守护启动');
                  tryPlayAll();
                }
              }
            }
          }
        });

        const domObserver = new MutationObserver(() => {
          if (document.readyState === 'complete') {
            observer.observe(document.body, { childList: true, subtree: true });
            tryPlayAll();
          }
        }).observe(document.documentElement, { childList: true, subtree: true });

        // 立即启动一次
        tryPlayAll();
        // 多重重试确保成功
        setTimeout(tryPlayAll, 1000);
        setTimeout(tryPlayAll, 3000);

        // 保存定时器和观察器以便后续停止
        window.beelineHelperAntiIdleInterval = antiIdleInterval;
        window.beelineHelperAntiIdleObserver = observer;
        window.beelineHelperAntiIdleDomObserver = domObserver;

        console.log('✅ 防挂机守护机制完全启动');
      };

      // 停止防挂机守护机制
      const stopAntiIdleProtection = () => {
        // 清除定时器
        if (window.beelineHelperAntiIdleInterval) {
          clearInterval(window.beelineHelperAntiIdleInterval);
          window.beelineHelperAntiIdleInterval = null;
        }

        // 停止观察器
        if (window.beelineHelperAntiIdleObserver) {
          window.beelineHelperAntiIdleObserver.disconnect();
          window.beelineHelperAntiIdleObserver = null;
        }

        if (window.beelineHelperAntiIdleDomObserver) {
          window.beelineHelperAntiIdleDomObserver.disconnect();
          window.beelineHelperAntiIdleDomObserver = null;
        }

        console.log('🔍 防挂机守护机制已完全停止');
        addToHistory('停止防挂机守护机制');
      };

      // 添加操作历史
      const addToHistory = (message) => {
        if (!operationLogEnabled.value) return

        const timestamp = new Date().toLocaleTimeString();
        operationHistory.value.unshift({
          time: timestamp,
          message: message
        });

        // 只保留最近10条记录
        if (operationHistory.value.length > 10) {
          operationHistory.value = operationHistory.value.slice(0, 10);
        }
      };

      // 监听页面变化
      const handlePageChange = () => {
        checkIsHomeworkPage();

        // 如果启用了FxxKXinWei功能，检查课程页面视频状态
        if (FxxKXinWeiEnabled.value) {
          checkCoursePageVideoStatus();
        }
      };

      // 应用Rainbow样式
      const applyRainbowStyles = () => {
        console.log('应用Rainbow样式', rainbowSettings.value);

        // 创建或更新背景层
        let bgLayer = document.getElementById('beeline-bg-layer');
        if (!bgLayer) {
          bgLayer = document.createElement('div');
          bgLayer.id = 'beeline-bg-layer';
          Object.assign(bgLayer.style, {
            position: 'fixed',
            top: 0,
            left: 0,
            width: '100vw',
            height: '100vh',
            zIndex: '-1',
            pointerEvents: 'none',
            backgroundSize: 'cover',
            backgroundPosition: 'center',
            filter: 'brightness(0.95)',
            transition: 'opacity 0.5s ease-in-out',
            opacity: '0' // 初始透明
          });
          document.body.appendChild(bgLayer);
        }

        // 创建或更新黑色叠加层
        let overlayLayer = document.getElementById('beeline-overlay-layer');
        if (!overlayLayer) {
          overlayLayer = document.createElement('div');
          overlayLayer.id = 'beeline-overlay-layer';
          Object.assign(overlayLayer.style, {
            position: 'fixed',
            top: 0,
            left: 0,
            width: '100vw',
            height: '100vh',
            zIndex: '-1',
            pointerEvents: 'none',
            backgroundColor: 'rgba(0, 0, 0, 0.5)',
            transition: 'opacity 0.5s ease-in-out',
            opacity: '0' // 初始透明
          });
          document.body.appendChild(overlayLayer);
        }

        // 立即设置背景图片（即使还没加载完成）
        bgLayer.style.backgroundImage = `url(${rainbowSettings.value.backgroundUrl})`;

        // 添加加载指示器
        const removeLoader = addLoadingEffect();

        // 预加载背景图片
        preloadBackgroundImage(rainbowSettings.value.backgroundUrl)
          .then(() => {
            // 图片加载完成后淡入背景
            setTimeout(() => {
              // 设置背景层完全不透明，黑色叠加层使用用户设置的透明度
              bgLayer.style.opacity = '1';
              overlayLayer.style.opacity = (1 - rainbowSettings.value.backgroundOpacity).toString();

              // 设置页面背景为透明
              document.documentElement.style.setProperty('background-color', 'transparent', 'important');
              document.body.style.setProperty('background-color', 'transparent', 'important');

              // 应用毛玻璃效果到特定元素
              applyGlassEffects();

              // 设置透明层
              applyTransparentLayers();

              // 启动DOM观察器来处理动态内容
              startDOMObserver();

              // 移除加载指示器
              setTimeout(removeLoader, 500);

              // 初始删除已存在的元素
              setTimeout(() => {
                removeCourseIntroduceTabElements();
              }, 200);
            }, 100);
          })
          .catch((error) => {
            console.error('背景图片加载失败:', error);
            // 即使图片加载失败，仍然应用其他样式
            setTimeout(() => {
              // 设置背景层完全不透明，黑色叠加层使用用户设置的透明度
              bgLayer.style.opacity = '1';
              overlayLayer.style.opacity = (1 - rainbowSettings.value.backgroundOpacity).toString();

              document.documentElement.style.setProperty('background-color', 'transparent', 'important');
              document.body.style.setProperty('background-color', 'transparent', 'important');
              applyGlassEffects();
              applyTransparentLayers();
              startDOMObserver();

              // 移除加载指示器
              setTimeout(removeLoader, 500);

              // 初始删除已存在的元素
              setTimeout(() => {
                removeCourseIntroduceTabElements();
              }, 200);
            }, 100);
          });
      };

      // 应用毛玻璃效果
      const applyGlassEffects = () => {
        const glassConfigs = [
          {
            selectors: [
              ".el-header",
              ".card",
              ".popup",
              "#chatLayout > div.chatIndex-sidebar.noCollapsed",
              "#chatLayout > div.chatIndex-sidebar.collapsed",
              "#LayoutTeaching > main > div > div"
            ],
            config: {
              bgColor: 'rgba(255, 255, 255, 0.18)',
              blur: `${rainbowSettings.value.glassEffectIntensity}px`,
              radius: '12px',
              exclude: ['.el-menu', '.el-menu-item', '.el-sub-menu']
            }
          },
          {
            selectors: [
              "#chatLayout > main > div > div.chat-content-inner.chat-content-inner--full > div.teacher-bank-main > ul > li",
              ".el-menu-item",
              ".el-sub-menu"
            ],
            config: {
              bgColor: 'rgba(255, 255, 255, 0.12)',
              blur: `${Math.max(rainbowSettings.value.glassEffectIntensity - 4, 0)}px`,
              radius: '10px'
            }
          },
          {
            selectors: [
              "#LayoutTeaching > main > div > div > div.tabs",
              "#LayoutTeaching > main > div > div > div.tab-pane > div:nth-child(1) > div.header",
              ".homework-list[data-v-b27e416b]"
            ],
            config: {
              bgColor: 'rgba(255, 255, 255, 0.1)',
              blur: `${Math.max(rainbowSettings.value.glassEffectIntensity - 2, 0)}px`,
              radius: '12px',
              border: '1px solid rgba(255,255,255,0.1)'
            }
          }
        ];

        glassConfigs.forEach(effect => {
          effect.selectors.forEach(selector => {
            try {
              const elements = document.querySelectorAll(selector);
              elements.forEach(el => {
                if (effect.config.exclude && effect.config.exclude.some(ex => el.matches(ex))) return

                el.style.setProperty('background-color', effect.config.bgColor, 'important');
                el.style.setProperty('backdrop-filter', `blur(${effect.config.blur})`, 'important');
                el.style.setProperty('border-radius', effect.config.radius, 'important');
                el.style.setProperty('transition', 'all 0.3s ease', 'important');

                if (effect.config.border) {
                  el.style.setProperty('border', effect.config.border, 'important');
                }

                el.style.backgroundImage = 'none';
              });
            } catch (e) {
              console.error(`Invalid selector: ${selector}`, e);
            }
          });
        });
      };

      // 应用透明层
      const applyTransparentLayers = () => {
        const transparentSelectors = [
          "#LayoutTeaching > main > div",
          "#LayoutTeaching > main > div > div > div.tab-pane > div:nth-child(1) > div.loading-container > div",
          "#chatLayout > main > div > div:nth-child(2) > div:nth-child(2) > ul",
          "#app",
          ".el-main[data-v-6b17b855]",
          "#LayoutTeaching > main > div > div > div.course-introduce-tab",
          "#LayoutTeaching > main > div > div > div.course-courseWare__body"
        ];

        transparentSelectors.forEach(selector => {
          try {
            const elements = document.querySelectorAll(selector);
            elements.forEach(el => {
              el.style.setProperty('background-color', 'transparent', 'important');
              el.style.backgroundImage = 'none';
            });
          } catch (e) {
            console.error(`Invalid selector: ${selector}`, e);
          }
        });
      };

      // 移除Rainbow样式
      const removeRainbowStyles = () => {
        console.log('移除Rainbow样式');

        // 移除背景层
        const bgLayer = document.getElementById('beeline-bg-layer');
        if (bgLayer) {
          bgLayer.remove();
        }

        // 移除黑色叠加层
        const overlayLayer = document.getElementById('beeline-overlay-layer');
        if (overlayLayer) {
          overlayLayer.remove();
        }

        // 恢复页面背景
        document.documentElement.style.removeProperty('background-color');
        document.body.style.removeProperty('background-color');

        // 移除所有毛玻璃效果
        const elementsWithGlass = document.querySelectorAll('[style*="backdrop-filter"]');
        elementsWithGlass.forEach(el => {
          el.style.removeProperty('backdrop-filter');
          el.style.removeProperty('background-color');
          el.style.removeProperty('border-radius');
          el.style.removeProperty('border');
          el.style.removeProperty('transition');
        });

        // 恢复透明层
        const transparentSelectors = [
          "#LayoutTeaching > main > div",
          "#LayoutTeaching > main > div > div > div.tab-pane > div:nth-child(1) > div.loading-container > div",
          "#chatLayout > main > div > div:nth-child(2) > div:nth-child(2) > ul",
          "#app",
          ".el-main[data-v-6b17b855]",
          "#LayoutTeaching > main > div > div > div.course-introduce-tab"
        ];

        transparentSelectors.forEach(selector => {
          try {
            const elements = document.querySelectorAll(selector);
            elements.forEach(el => {
              el.style.removeProperty('background-color');
              el.style.removeProperty('background-image');
            });
          } catch (e) {
            console.error(`Invalid selector: ${selector}`, e);
          }
        });

        // 停止DOM观察器
        stopDOMObserver();
      };

      // DOM观察器处理动态内容
      let mutationObserver = null;

      const startDOMObserver = () => {
        if (mutationObserver) {
          return // 观察器已经在运行
        }

        mutationObserver = new MutationObserver((mutations) => {
          let shouldReapply = false;
          let shouldRemoveElements = false;

          mutations.forEach(mutation => {
            if (mutation.addedNodes.length > 0) {
              shouldReapply = true;

              // 检查新增节点中是否包含需要删除的元素
              mutation.addedNodes.forEach(node => {
                if (node.nodeType === 1) { // Element node
                  if (node.classList && node.classList.contains('course-introduce-tab__content')) {
                    shouldRemoveElements = true;
                  }
                  // 检查子元素
                  if (node.querySelectorAll) {
                    const contentElements = node.querySelectorAll('.course-introduce-tab__content');
                    const tabElement = node.querySelector("#LayoutTeaching > main > div > div > div.course-introduce-tab");
                    if (contentElements.length > 0 || tabElement) {
                      shouldRemoveElements = true;
                    }
                  }
                }
              });
            }
          });

          if (shouldRemoveElements) {
            // 延迟删除，确保元素已完全加载
            setTimeout(() => {
              removeCourseIntroduceTabElements();
            }, 50);
          }

          if (shouldReapply) {
            // 延迟重新应用样式，确保新元素已完全加载
            setTimeout(() => {
              applyGlassEffects();
              applyTransparentLayers();
            }, 100);
          }
        });

        // 开始观察DOM变化
        mutationObserver.observe(document.body, {
          childList: true,
          subtree: true,
          attributes: true
        });

        console.log('DOM观察器已启动');
      };

      const stopDOMObserver = () => {
        if (mutationObserver) {
          mutationObserver.disconnect();
          mutationObserver = null;
          console.log('DOM观察器已停止');
        }
      };

      // 预加载背景图片
      const preloadBackgroundImage = (url) => {
        return new Promise((resolve, reject) => {
          // 如果是data URL，直接解析
          if (url.startsWith('data:')) {
            resolve();
            return
          }

          const img = new Image();

          img.onload = () => {
            console.log('背景图片预加载成功');
            resolve();
          };

          img.onerror = () => {
            console.warn('背景图片预加载失败，将使用异步加载');
            reject(new Error('图片加载失败'));
          };

          // 设置超时时间
          const timeout = setTimeout(() => {
            console.warn('背景图片加载超时，将使用异步加载');
            reject(new Error('图片加载超时'));
          }, 3000); // 3秒超时

          img.onload = () => {
            clearTimeout(timeout);
            console.log('背景图片预加载成功');
            resolve();
          };

          img.onerror = () => {
            clearTimeout(timeout);
            console.warn('背景图片预加载失败，将使用异步加载');
            reject(new Error('图片加载失败'));
          };

          img.src = url;
        })
      };

      // 删除 course-introduce-tab 相关元素
      const removeCourseIntroduceTabElements = () => {
        // 删除 class="course-introduce-tab__content" 的元素
        const contentElements = document.querySelectorAll('.course-introduce-tab__content');
        contentElements.forEach(element => {
          element.remove();
          console.log('已删除 course-introduce-tab__content 元素');
        });

        // 删除特定路径的 course-introduce-tab 元素
        const tabElement = document.querySelector("#LayoutTeaching > main > div > div > div.course-introduce-tab");
        if (tabElement) {
          tabElement.remove();
          console.log('已删除特定 course-introduce-tab 元素');
        }

        if (contentElements.length > 0 || tabElement) {
          console.log(`已删除 ${contentElements.length} 个 course-introduce-tab__content 元素和 ${tabElement ? 1 : 0} 个特定 course-introduce-tab 元素`);
        }
      };

      // 添加渐进式加载效果
      const addLoadingEffect = (bgLayer) => {
        // 创建加载指示器
        const loader = document.createElement('div');
        loader.id = 'beeline-bg-loader';
        Object.assign(loader.style, {
          position: 'fixed',
          top: '50%',
          left: '50%',
          transform: 'translate(-50%, -50%)',
          width: '40px',
          height: '40px',
          border: '3px solid rgba(255,255,255,0.3)',
          borderTop: '3px solid #667eea',
          borderRadius: '50%',
          animation: 'spin 1s linear infinite',
          zIndex: '9999',
          pointerEvents: 'none'
        });

        // 添加旋转动画
        const style = document.createElement('style');
        style.textContent = `
    @keyframes spin {
      0% { transform: translate(-50%, -50%) rotate(0deg); }
      100% { transform: translate(-50%, -50%) rotate(360deg); }
    }
  `;
        document.head.appendChild(style);

        document.body.appendChild(loader);

        // 返回移除函数
        return () => {
          if (loader.parentNode) {
            loader.remove();
          }
          if (style.parentNode) {
            style.remove();
          }
        }
      };

      // 添加事件监听器
      onMounted(async () => {
        // 监听页面变化
        window.addEventListener('popstate', handlePageChange);
        window.addEventListener('hashchange', handlePageChange);

        // 设置网络请求监控
        setupNetworkMonitoring();

        // 加载存储的功能开关状态
        await loadFeatureStates();

        // 暴露应用实例以便其他组件访问
        window.beelineHelperApp = {
          operationLogEnabled,
          userOperationLogPref: operationLogEnabled, // 将 operationLogEnabled 直接暴露为用户操作日志偏好
          rainbowEnabled,
          rainbowSettings,
          applyRainbowStyles,
          removeRainbowStyles,
          saveFeatureStates,
          checkIsHomeworkPage
        };


      });

      onUnmounted(() => {
        // 移除页面变化监听器
        window.removeEventListener('popstate', handlePageChange);
        window.removeEventListener('hashchange', handlePageChange);

        // 停止所有正在运行的功能
        stopAutoCompleteDetection();
        stopAutoMute();
        stopFxxKXinWei();
        stopNetworkMonitoring();
      });

      return (_ctx, _cache) => {
        return (openBlock(), createElementBlock("div", _hoisted_1, [
          createVNode(FloatingWindow, {
            "is-visible": isWindowVisible.value,
            title: pageTitle.value,
            "show-back-button": currentPage.value !== 'main',
            "auto-answer-mode": currentPage.value === 'auto-answer',
            onClose: closeWindow,
            onBack: goBack
          }, {
            default: withCtx(() => [
              createBaseVNode("div", _hoisted_2, [
                createVNode(Transition, {
                  name: "page-fade",
                  mode: "out-in"
                }, {
                  default: withCtx(() => [
                    (currentPage.value === 'main')
                      ? (openBlock(), createElementBlock("div", _hoisted_3, [
                          createVNode(MainPage, {
                            onNavigate: navigateTo,
                            onOpenAbout: _cache[0] || (_cache[0] = $event => (showAboutPage.value = true))
                          })
                        ]))
                      : createCommentVNode("", true)
                  ]),
                  _: 1
                }),
                createVNode(Transition, {
                  name: "page-fade",
                  mode: "out-in"
                }, {
                  default: withCtx(() => [
                    (currentPage.value === 'auto-course')
                      ? (openBlock(), createElementBlock("div", _hoisted_4, [
                          createVNode(AutoCoursePage, {
                            "auto-complete-enabled": autoCompleteEnabled.value,
                            "auto-mute-enabled": autoMuteEnabled.value,
                            "FxxK-xin-wei-enabled": FxxKXinWeiEnabled.value,
                            onToggleAutoComplete: handleAutoCompleteToggle,
                            onToggleAutoMute: handleAutoMuteToggle,
                            onToggleFxxKXinWei: handleFxxKXinWeiToggle
                          }, null, 8, ["auto-complete-enabled", "auto-mute-enabled", "FxxK-xin-wei-enabled"])
                        ]))
                      : createCommentVNode("", true)
                  ]),
                  _: 1
                }),
                createVNode(Transition, {
                  name: "page-fade",
                  mode: "out-in"
                }, {
                  default: withCtx(() => [
                    (currentPage.value === 'auto-answer')
                      ? (openBlock(), createElementBlock("div", _hoisted_5, [
                          createVNode(AutoAnswerPage)
                        ]))
                      : createCommentVNode("", true)
                  ]),
                  _: 1
                }),
                createVNode(Transition, {
                  name: "page-fade",
                  mode: "out-in"
                }, {
                  default: withCtx(() => [
                    (currentPage.value === 'advanced-settings')
                      ? (openBlock(), createElementBlock("div", _hoisted_6, [
                          createVNode(AdvancedSettingsPage, { onNavigate: navigateTo })
                        ]))
                      : createCommentVNode("", true)
                  ]),
                  _: 1
                })
              ])
            ]),
            _: 1
          }, 8, ["is-visible", "title", "show-back-button", "auto-answer-mode"]),
          createVNode(Transition, { name: "status-fade-slide" }, {
            default: withCtx(() => [
              (operationLogEnabled.value && currentPage.value !== 'auto-answer')
                ? (openBlock(), createBlock(StatusWindow, {
                    key: 0,
                    "current-status": currentStatus.value,
                    "operation-history": operationHistory.value
                  }, null, 8, ["current-status", "operation-history"]))
                : createCommentVNode("", true)
            ]),
            _: 1
          }),
          createVNode(ControlButton, {
            "is-window-visible": isWindowVisible.value,
            onClick: toggleWindow
          }, null, 8, ["is-window-visible"]),
          createVNode(Transition, { name: "about-fade-scale" }, {
            default: withCtx(() => [
              (showAboutPage.value)
                ? (openBlock(), createElementBlock("div", _hoisted_7, [
                    createBaseVNode("div", _hoisted_8, [
                      createVNode(AboutPage, {
                        onClose: _cache[1] || (_cache[1] = $event => (showAboutPage.value = false))
                      })
                    ])
                  ]))
                : createCommentVNode("", true)
            ]),
            _: 1
          })
        ]))
      }
      }

      };
      const App = /*#__PURE__*/_export_sfc(_sfc_main, [['__scopeId',"data-v-5fcc6ae2"]]);

      // 创建并挂载Vue应用到页面
      function initApp() {
        // 检查是否已经存在我们的应用
        if (document.getElementById('beeline-helper-app')) {
          return
        }

        // 创建应用容器
        const appContainer = document.createElement('div');
        appContainer.id = 'beeline-helper-app';
        appContainer.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    pointer-events: none;
    z-index: 9999;
  `;

        document.body.appendChild(appContainer);

        // 创建Vue应用
        createApp(App).mount(appContainer);
      }

      // 等待页面加载完成后初始化应用
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initApp);
      } else {
        initApp();
      }

    })
  };
}));

System.register("./completionAnswer-YNeMB8H5-CWESuEKv.js", ['./__monkey.entry-C36_3piD.js'], (function (exports, module) {
  'use strict';
  var extractQuestionContent, queryAnswer, parseAnswer;
  return {
    setters: [module => {
      extractQuestionContent = module.e;
      queryAnswer = module.q;
      parseAnswer = module.p;
    }],
    execute: (function () {

      exports("autoAnswerCompletionQuestion", autoAnswerCompletionQuestion);

      /**
       * 填空题回答工具类
       * 处理填空题的检测和回答逻辑
       */

      /**
       * 查找填空题输入框
       * @returns {HTMLElement[]} 输入框元素数组
       */
      function findCompletionInputs() {
        // 查找填空题输入框 - 尝试多种选择器
        const inputs = [];

        // 查找所有可能的输入框
        const possibleSelectors = [
          'input[type="text"]',
          'input[placeholder*="填空"]',
          'input[placeholder*="答案"]',
          '.el-input__inner',
          '.el-input input'
        ];

        possibleSelectors.forEach(selector => {
          const elements = document.querySelectorAll(selector);
          elements.forEach(element => {
            // 检查元素是否在填空题区域
            const questionContainer = element.closest("div[class*='homework-']");
            if (questionContainer) {
              const typeElement = questionContainer.querySelector('span.tag.el-tooltip__trigger');
              if (typeElement && typeElement.textContent.trim() === '填空题') {
                inputs.push(element);
              }
            }
          });
        });

        return inputs;
      }

      /**
       * 检查输入框是否已有内容
       * @param {HTMLElement} input 输入框元素
       * @returns {boolean} 是否已有内容
       */
      function hasExistingContent(input) {
        if (input.tagName === 'INPUT' || input.tagName === 'TEXTAREA') {
          return input.value.trim().length > 0;
        } else {
          return input.textContent.trim().length > 0;
        }
      }

      /**
       * 自动回答填空题
       * @param {string} token API token
       * @returns {Promise<object>} 答题结果
       */
      async function autoAnswerCompletionQuestion(token = '') {
        try {
          const inputs = findCompletionInputs();

          if (inputs.length === 0) {
            return {
              success: false,
              message: '未找到填空题输入框'
            };
          }

          console.log(`找到 ${inputs.length} 个填空题输入框`);

          // 检查是否有输入框已有内容
          const filledInputs = inputs.filter(input => hasExistingContent(input));
          if (filledInputs.length > 0) {
            console.log(`发现 ${filledInputs.length} 个输入框已有内容，跳过自动答题`);
            return {
              success: false,
              message: `发现 ${filledInputs.length} 个输入框已有内容，跳过自动答题`
            };
          }

          // 提取题目内容
          const { question } = extractQuestionContent('completion');

          if (!question) {
            return {
              success: false,
              message: '无法提取填空题题目内容'
            };
          }

          console.log('检测到填空题:', question);

          // 查询题库
          const apiResult = await queryAnswer(question, [], 'completion', token);

          if (!apiResult.success) {
            return {
              success: false,
              message: apiResult.message,
              question: question,
              answer: apiResult.answer
            };
          }

          console.log('题库查询结果:', apiResult);

          // 解析答案
          const answer = parseAnswer(apiResult.answer, 'completion', []);

          if (!answer) {
            return {
              success: false,
              message: '无法解析答案',
              question: apiResult.question,
              answer: apiResult.answer
            };
          }

          console.log('解析后的答案:', answer);

          // 将答案填充到第一个输入框
          if (inputs.length > 0) {
            const firstInput = inputs[0];

            // 聚焦并清空输入框
            firstInput.focus();
            firstInput.value = '';

            // 输入答案
            firstInput.value = answer;

            // 触发输入事件
            const inputEvent = new Event('input', { bubbles: true });
            firstInput.dispatchEvent(inputEvent);

            const changeEvent = new Event('change', { bubbles: true });
            firstInput.dispatchEvent(changeEvent);

            console.log('填空题答案已填充');

            return {
              success: true,
              message: '填空题答案已填充',
              question: apiResult.question,
              answer: apiResult.answer,
              times: apiResult.times
            };
          }

          return {
            success: false,
            message: '无法填充答案'
          };

        } catch (error) {
          console.error('填空题回答失败:', error);
          return {
            success: false,
            message: `填空题回答失败: ${error.message}`
          };
        }
      }

    })
  };
}));

System.register("./subjectiveAnswer-YKVl7e_4-DPJa3JEe.js", ['./__monkey.entry-C36_3piD.js'], (function (exports, module) {
  'use strict';
  var getStorageValue$1;
  return {
    setters: [module => {
      getStorageValue$1 = module.g;
    }],
    execute: (function () {

      exports({
        checkSubjectiveAnswerConfig: checkSubjectiveAnswerConfig,
        streamAnswerSubjectiveQuestion: streamAnswerSubjectiveQuestion
      });

      function isElementType(element, tag, props) {
          if (element.namespaceURI && element.namespaceURI !== 'http://www.w3.org/1999/xhtml') {
              return false;
          }
          tag = Array.isArray(tag) ? tag : [
              tag
          ];
          // tagName is uppercase in HTMLDocument and lowercase in XMLDocument
          if (!tag.includes(element.tagName.toLowerCase())) {
              return false;
          }
          if (props) {
              return Object.entries(props).every(([k, v])=>element[k] === v);
          }
          return true;
      }

      function getWindow(node) {
          var _node_ownerDocument;
          if (isDocument$1(node) && node.defaultView) {
              return node.defaultView;
          } else if ((_node_ownerDocument = node.ownerDocument) === null || _node_ownerDocument === undefined ? undefined : _node_ownerDocument.defaultView) {
              return node.ownerDocument.defaultView;
          }
          throw new Error(`Could not determine window of node. Node was ${describe(node)}`);
      }
      function isDocument$1(node) {
          return node.nodeType === 9;
      }
      function describe(val) {
          return typeof val === 'function' ? `function ${val.name}` : val === null ? 'null' : String(val);
      }

      // jsdom does not implement Blob.text()
      function readBlobText(blob, FileReader) {
          return new Promise((res, rej)=>{
              const fr = new FileReader();
              fr.onerror = rej;
              fr.onabort = rej;
              fr.onload = ()=>{
                  res(String(fr.result));
              };
              fr.readAsText(blob);
          });
      }

      // FileList can not be created per constructor.
      function createFileList(window, files) {
          const list = {
              ...files,
              length: files.length,
              item: (index)=>list[index],
              [Symbol.iterator]: function* nextFile() {
                  for(let i = 0; i < list.length; i++){
                      yield list[i];
                  }
              }
          };
          list.constructor = window.FileList;
          // guard for environments without FileList
          /* istanbul ignore else */ if (window.FileList) {
              Object.setPrototypeOf(list, window.FileList.prototype);
          }
          Object.freeze(list);
          return list;
      }

      function _define_property$8(obj, key, value) {
          if (key in obj) {
              Object.defineProperty(obj, key, {
                  value: value,
                  enumerable: true,
                  configurable: true,
                  writable: true
              });
          } else {
              obj[key] = value;
          }
          return obj;
      }
      // DataTransfer is not implemented in jsdom.
      // DataTransfer with FileList is being created by the browser on certain events.
      class DataTransferItemStub {
          getAsFile() {
              return this.file;
          }
          getAsString(callback) {
              if (typeof this.data === 'string') {
                  callback(this.data);
              }
          }
          /* istanbul ignore next */ webkitGetAsEntry() {
              throw new Error('not implemented');
          }
          constructor(dataOrFile, type){
              _define_property$8(this, "kind", undefined);
              _define_property$8(this, "type", undefined);
              _define_property$8(this, "file", null);
              _define_property$8(this, "data", undefined);
              if (typeof dataOrFile === 'string') {
                  this.kind = 'string';
                  this.type = String(type);
                  this.data = dataOrFile;
              } else {
                  this.kind = 'file';
                  this.type = dataOrFile.type;
                  this.file = dataOrFile;
              }
          }
      }
      class DataTransferItemListStub extends Array {
          add(...args) {
              const item = new DataTransferItemStub(args[0], args[1]);
              this.push(item);
              return item;
          }
          clear() {
              this.splice(0, this.length);
          }
          remove(index) {
              this.splice(index, 1);
          }
      }
      function getTypeMatcher(type, exact) {
          const [group, sub] = type.split('/');
          const isGroup = !sub || sub === '*';
          return (item)=>{
              return exact ? item.type === (isGroup ? group : type) : isGroup ? item.type.startsWith(`${group}/`) : item.type === group;
          };
      }
      function createDataTransferStub(window) {
          return new class DataTransferStub {
              getData(format) {
                  var _this_items_find;
                  const match = (_this_items_find = this.items.find(getTypeMatcher(format, true))) !== null && _this_items_find !== undefined ? _this_items_find : this.items.find(getTypeMatcher(format, false));
                  let text = '';
                  match === null || match === undefined ? undefined : match.getAsString((t)=>{
                      text = t;
                  });
                  return text;
              }
              setData(format, data) {
                  const matchIndex = this.items.findIndex(getTypeMatcher(format, true));
                  const item = new DataTransferItemStub(data, format);
                  if (matchIndex >= 0) {
                      this.items.splice(matchIndex, 1, item);
                  } else {
                      this.items.push(item);
                  }
              }
              clearData(format) {
                  if (format) {
                      const matchIndex = this.items.findIndex(getTypeMatcher(format, true));
                      if (matchIndex >= 0) {
                          this.items.remove(matchIndex);
                      }
                  } else {
                      this.items.clear();
                  }
              }
              get types() {
                  const t = [];
                  if (this.files.length) {
                      t.push('Files');
                  }
                  this.items.forEach((i)=>t.push(i.type));
                  Object.freeze(t);
                  return t;
              }
              /* istanbul ignore next */ setDragImage() {}
              constructor(){
                  _define_property$8(this, "dropEffect", 'none');
                  _define_property$8(this, "effectAllowed", 'uninitialized');
                  _define_property$8(this, "items", new DataTransferItemListStub());
                  _define_property$8(this, "files", createFileList(window, []));
              }
          }();
      }
      function createDataTransfer(window, files = []) {
          // Use real DataTransfer if available
          const dt = typeof window.DataTransfer === 'undefined' ? createDataTransferStub(window) : /* istanbul ignore next */ new window.DataTransfer();
          Object.defineProperty(dt, 'files', {
              get: ()=>createFileList(window, files)
          });
          return dt;
      }
      async function getBlobFromDataTransferItem(window, item) {
          if (item.kind === 'file') {
              return item.getAsFile();
          }
          return new window.Blob([
              await new Promise((r)=>item.getAsString(r))
          ], {
              type: item.type
          });
      }

      // Clipboard is not available in jsdom
      function _define_property$7(obj, key, value) {
          if (key in obj) {
              Object.defineProperty(obj, key, {
                  value: value,
                  enumerable: true,
                  configurable: true,
                  writable: true
              });
          } else {
              obj[key] = value;
          }
          return obj;
      }
      // MDN lists string|Blob|Promise<Blob|string> as possible types in ClipboardItemData
      // lib.dom.d.ts lists only Promise<Blob|string>
      // https://developer.mozilla.org/en-US/docs/Web/API/ClipboardItem/ClipboardItem#syntax
      function createClipboardItem(window, ...blobs) {
          const dataMap = Object.fromEntries(blobs.map((b)=>[
                  typeof b === 'string' ? 'text/plain' : b.type,
                  Promise.resolve(b)
              ]));
          // use real ClipboardItem if available
          /* istanbul ignore if */ if (typeof window.ClipboardItem !== 'undefined') {
              return new window.ClipboardItem(dataMap);
          }
          return new class ClipboardItem {
              get types() {
                  return Array.from(Object.keys(this.data));
              }
              async getType(type) {
                  const value = await this.data[type];
                  if (!value) {
                      throw new Error(`${type} is not one of the available MIME types on this item.`);
                  }
                  return value instanceof window.Blob ? value : new window.Blob([
                      value
                  ], {
                      type
                  });
              }
              constructor(d){
                  _define_property$7(this, "data", undefined);
                  this.data = d;
              }
          }(dataMap);
      }
      const ClipboardStubControl = Symbol('Manage ClipboardSub');
      function createClipboardStub(window, control) {
          return Object.assign(new class Clipboard extends window.EventTarget {
              async read() {
                  return Array.from(this.items);
              }
              async readText() {
                  let text = '';
                  for (const item of this.items){
                      const type = item.types.includes('text/plain') ? 'text/plain' : item.types.find((t)=>t.startsWith('text/'));
                      if (type) {
                          text += await item.getType(type).then((b)=>readBlobText(b, window.FileReader));
                      }
                  }
                  return text;
              }
              async write(data) {
                  this.items = data;
              }
              async writeText(text) {
                  this.items = [
                      createClipboardItem(window, text)
                  ];
              }
              constructor(...args){
                  super(...args), _define_property$7(this, "items", []);
              }
          }(), {
              [ClipboardStubControl]: control
          });
      }
      function isClipboardStub(clipboard) {
          return !!(clipboard === null || clipboard === undefined ? undefined : clipboard[ClipboardStubControl]);
      }
      function attachClipboardStubToView(window) {
          if (isClipboardStub(window.navigator.clipboard)) {
              return window.navigator.clipboard[ClipboardStubControl];
          }
          const realClipboard = Object.getOwnPropertyDescriptor(window.navigator, 'clipboard');
          let stub;
          const control = {
              resetClipboardStub: ()=>{
                  stub = createClipboardStub(window, control);
              },
              detachClipboardStub: ()=>{
                  /* istanbul ignore if */ if (realClipboard) {
                      Object.defineProperty(window.navigator, 'clipboard', realClipboard);
                  } else {
                      Object.defineProperty(window.navigator, 'clipboard', {
                          value: undefined,
                          configurable: true
                      });
                  }
              }
          };
          stub = createClipboardStub(window, control);
          Object.defineProperty(window.navigator, 'clipboard', {
              get: ()=>stub,
              configurable: true
          });
          return stub[ClipboardStubControl];
      }
      function resetClipboardStubOnView(window) {
          if (isClipboardStub(window.navigator.clipboard)) {
              window.navigator.clipboard[ClipboardStubControl].resetClipboardStub();
          }
      }
      function detachClipboardStubFromView(window) {
          if (isClipboardStub(window.navigator.clipboard)) {
              window.navigator.clipboard[ClipboardStubControl].detachClipboardStub();
          }
      }
      async function readDataTransferFromClipboard(document) {
          const window = document.defaultView;
          const clipboard = window === null || window === undefined ? undefined : window.navigator.clipboard;
          const items = clipboard && await clipboard.read();
          if (!items) {
              throw new Error('The Clipboard API is unavailable.');
          }
          const dt = createDataTransfer(window);
          for (const item of items){
              for (const type of item.types){
                  dt.setData(type, await item.getType(type).then((b)=>readBlobText(b, window.FileReader)));
              }
          }
          return dt;
      }
      async function writeDataTransferToClipboard(document, clipboardData) {
          const window = getWindow(document);
          const clipboard = window.navigator.clipboard;
          const items = [];
          for(let i = 0; i < clipboardData.items.length; i++){
              const dtItem = clipboardData.items[i];
              const blob = await getBlobFromDataTransferItem(window, dtItem);
              items.push(createClipboardItem(window, blob));
          }
          const written = clipboard && await clipboard.write(items).then(()=>true, // Can happen with other implementations that e.g. require permissions
          /* istanbul ignore next */ ()=>false);
          if (!written) {
              throw new Error('The Clipboard API is unavailable.');
          }
      }
      const g$1 = globalThis;
      /* istanbul ignore else */ if (typeof g$1.afterEach === 'function') {
          g$1.afterEach(()=>resetClipboardStubOnView(globalThis.window));
      }
      /* istanbul ignore else */ if (typeof g$1.afterAll === 'function') {
          g$1.afterAll(()=>detachClipboardStubFromView(globalThis.window));
      }

      const FOCUSABLE_SELECTOR = [
          'input:not([type=hidden]):not([disabled])',
          'button:not([disabled])',
          'select:not([disabled])',
          'textarea:not([disabled])',
          '[contenteditable=""]',
          '[contenteditable="true"]',
          'a[href]',
          '[tabindex]:not([disabled])'
      ].join(', ');

      function isFocusable(element) {
          return element.matches(FOCUSABLE_SELECTOR);
      }

      function cloneEvent(event) {
          return new event.constructor(event.type, event);
      }

      // This should probably just rely on the :disabled pseudo-class, but JSDOM doesn't implement it properly.
      function isDisabled(element) {
          for(let el = element; el; el = el.parentElement){
              if (isElementType(el, [
                  'button',
                  'input',
                  'select',
                  'textarea',
                  'optgroup',
                  'option'
              ])) {
                  if (el.hasAttribute('disabled')) {
                      return true;
                  }
              } else if (isElementType(el, 'fieldset')) {
                  var _el_querySelector;
                  if (el.hasAttribute('disabled') && !((_el_querySelector = el.querySelector(':scope > legend')) === null || _el_querySelector === undefined ? undefined : _el_querySelector.contains(element))) {
                      return true;
                  }
              } else if (el.tagName.includes('-')) {
                  if (el.constructor.formAssociated && el.hasAttribute('disabled')) {
                      return true;
                  }
              }
          }
          return false;
      }

      function getActiveElement(document) {
          const activeElement = document.activeElement;
          if (activeElement === null || activeElement === undefined ? undefined : activeElement.shadowRoot) {
              return getActiveElement(activeElement.shadowRoot);
          } else {
              // Browser does not yield disabled elements as document.activeElement - jsdom does
              if (isDisabled(activeElement)) {
                  return document.ownerDocument ? /* istanbul ignore next */ document.ownerDocument.body : document.body;
              }
              return activeElement;
          }
      }
      function getActiveElementOrBody(document) {
          var _getActiveElement;
          return (_getActiveElement = getActiveElement(document)) !== null && _getActiveElement !== undefined ? _getActiveElement : /* istanbul ignore next */ document.body;
      }

      function findClosest(element, callback) {
          let el = element;
          do {
              if (callback(el)) {
                  return el;
              }
              el = el.parentElement;
          }while (el && el !== element.ownerDocument.body)
          return undefined;
      }

      //jsdom is not supporting isContentEditable
      function isContentEditable(element) {
          return element.hasAttribute('contenteditable') && (element.getAttribute('contenteditable') == 'true' || element.getAttribute('contenteditable') == '');
      }
      /**
       * If a node is a contenteditable or inside one, return that element.
       */ function getContentEditable(node) {
          const element = getElement$1(node);
          return element && (element.closest('[contenteditable=""]') || element.closest('[contenteditable="true"]'));
      }
      function getElement$1(node) {
          return node.nodeType === 1 ? node : node.parentElement;
      }

      var clickableInputTypes = /*#__PURE__*/ function(clickableInputTypes) {
          clickableInputTypes["button"] = "button";
          clickableInputTypes["color"] = "color";
          clickableInputTypes["file"] = "file";
          clickableInputTypes["image"] = "image";
          clickableInputTypes["reset"] = "reset";
          clickableInputTypes["submit"] = "submit";
          clickableInputTypes["checkbox"] = "checkbox";
          clickableInputTypes["radio"] = "radio";
          return clickableInputTypes;
      }(clickableInputTypes || {});
      function isClickableInput(element) {
          return isElementType(element, 'button') || isElementType(element, 'input') && element.type in clickableInputTypes;
      }

      function isEditable(element) {
          return isEditableInputOrTextArea(element) && !element.readOnly || isContentEditable(element);
      }
      var editableInputTypes = /*#__PURE__*/ function(editableInputTypes) {
          editableInputTypes["text"] = "text";
          editableInputTypes["date"] = "date";
          editableInputTypes["datetime-local"] = "datetime-local";
          editableInputTypes["email"] = "email";
          editableInputTypes["month"] = "month";
          editableInputTypes["number"] = "number";
          editableInputTypes["password"] = "password";
          editableInputTypes["search"] = "search";
          editableInputTypes["tel"] = "tel";
          editableInputTypes["time"] = "time";
          editableInputTypes["url"] = "url";
          editableInputTypes["week"] = "week";
          return editableInputTypes;
      }(editableInputTypes || {});
      function isEditableInputOrTextArea(element) {
          return isElementType(element, 'textarea') || isElementType(element, 'input') && element.type in editableInputTypes;
      }

      /**
       * Determine if the element has its own selection implementation
       * and does not interact with the Document Selection API.
       */ function hasOwnSelection(node) {
          return isElement$2(node) && isEditableInputOrTextArea(node);
      }
      function hasNoSelection(node) {
          return isElement$2(node) && isClickableInput(node);
      }
      function isElement$2(node) {
          return node.nodeType === 1;
      }

      // The browser implementation seems to have changed.
      // When focus is inside <input type="text"/>,
      // Chrome updates Selection to be collapsed at the position of the input element.
      // TODO: update implementation to match that of current browsers
      /**
       * Reset the Document Selection when moving focus into an element
       * with own selection implementation.
       */ function updateSelectionOnFocus(element) {
          const selection = element.ownerDocument.getSelection();
          /* istanbul ignore if */ if (!(selection === null || selection === undefined ? undefined : selection.focusNode)) {
              return;
          }
          // If the focus moves inside an element with own selection implementation,
          // the document selection will be this element.
          // But if the focused element is inside a contenteditable,
          // 1) a collapsed selection will be retained.
          // 2) other selections will be replaced by a cursor
          //  2.a) at the start of the first child if it is a text node
          //  2.b) at the start of the contenteditable.
          if (hasOwnSelection(element)) {
              const contenteditable = getContentEditable(selection.focusNode);
              if (contenteditable) {
                  if (!selection.isCollapsed) {
                      var _contenteditable_firstChild;
                      const focusNode = ((_contenteditable_firstChild = contenteditable.firstChild) === null || _contenteditable_firstChild === undefined ? undefined : _contenteditable_firstChild.nodeType) === 3 ? contenteditable.firstChild : contenteditable;
                      selection.setBaseAndExtent(focusNode, 0, focusNode, 0);
                  }
              } else {
                  selection.setBaseAndExtent(element, 0, element, 0);
              }
          }
      }

      function getDefaultExportFromCjs (x) {
      	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
      }

      var build$1 = {};

      var ansiStyles = {exports: {}};

      ansiStyles.exports;

      (function (module) {

      	const ANSI_BACKGROUND_OFFSET = 10;

      	const wrapAnsi256 = (offset = 0) => code => `\u001B[${38 + offset};5;${code}m`;

      	const wrapAnsi16m = (offset = 0) => (red, green, blue) => `\u001B[${38 + offset};2;${red};${green};${blue}m`;

      	function assembleStyles() {
      		const codes = new Map();
      		const styles = {
      			modifier: {
      				reset: [0, 0],
      				// 21 isn't widely supported and 22 does the same thing
      				bold: [1, 22],
      				dim: [2, 22],
      				italic: [3, 23],
      				underline: [4, 24],
      				overline: [53, 55],
      				inverse: [7, 27],
      				hidden: [8, 28],
      				strikethrough: [9, 29]
      			},
      			color: {
      				black: [30, 39],
      				red: [31, 39],
      				green: [32, 39],
      				yellow: [33, 39],
      				blue: [34, 39],
      				magenta: [35, 39],
      				cyan: [36, 39],
      				white: [37, 39],

      				// Bright color
      				blackBright: [90, 39],
      				redBright: [91, 39],
      				greenBright: [92, 39],
      				yellowBright: [93, 39],
      				blueBright: [94, 39],
      				magentaBright: [95, 39],
      				cyanBright: [96, 39],
      				whiteBright: [97, 39]
      			},
      			bgColor: {
      				bgBlack: [40, 49],
      				bgRed: [41, 49],
      				bgGreen: [42, 49],
      				bgYellow: [43, 49],
      				bgBlue: [44, 49],
      				bgMagenta: [45, 49],
      				bgCyan: [46, 49],
      				bgWhite: [47, 49],

      				// Bright color
      				bgBlackBright: [100, 49],
      				bgRedBright: [101, 49],
      				bgGreenBright: [102, 49],
      				bgYellowBright: [103, 49],
      				bgBlueBright: [104, 49],
      				bgMagentaBright: [105, 49],
      				bgCyanBright: [106, 49],
      				bgWhiteBright: [107, 49]
      			}
      		};

      		// Alias bright black as gray (and grey)
      		styles.color.gray = styles.color.blackBright;
      		styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
      		styles.color.grey = styles.color.blackBright;
      		styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;

      		for (const [groupName, group] of Object.entries(styles)) {
      			for (const [styleName, style] of Object.entries(group)) {
      				styles[styleName] = {
      					open: `\u001B[${style[0]}m`,
      					close: `\u001B[${style[1]}m`
      				};

      				group[styleName] = styles[styleName];

      				codes.set(style[0], style[1]);
      			}

      			Object.defineProperty(styles, groupName, {
      				value: group,
      				enumerable: false
      			});
      		}

      		Object.defineProperty(styles, 'codes', {
      			value: codes,
      			enumerable: false
      		});

      		styles.color.close = '\u001B[39m';
      		styles.bgColor.close = '\u001B[49m';

      		styles.color.ansi256 = wrapAnsi256();
      		styles.color.ansi16m = wrapAnsi16m();
      		styles.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
      		styles.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);

      		// From https://github.com/Qix-/color-convert/blob/3f0e0d4e92e235796ccb17f6e85c72094a651f49/conversions.js
      		Object.defineProperties(styles, {
      			rgbToAnsi256: {
      				value: (red, green, blue) => {
      					// We use the extended greyscale palette here, with the exception of
      					// black and white. normal palette only has 4 greyscale shades.
      					if (red === green && green === blue) {
      						if (red < 8) {
      							return 16;
      						}

      						if (red > 248) {
      							return 231;
      						}

      						return Math.round(((red - 8) / 247) * 24) + 232;
      					}

      					return 16 +
      						(36 * Math.round(red / 255 * 5)) +
      						(6 * Math.round(green / 255 * 5)) +
      						Math.round(blue / 255 * 5);
      				},
      				enumerable: false
      			},
      			hexToRgb: {
      				value: hex => {
      					const matches = /(?<colorString>[a-f\d]{6}|[a-f\d]{3})/i.exec(hex.toString(16));
      					if (!matches) {
      						return [0, 0, 0];
      					}

      					let {colorString} = matches.groups;

      					if (colorString.length === 3) {
      						colorString = colorString.split('').map(character => character + character).join('');
      					}

      					const integer = Number.parseInt(colorString, 16);

      					return [
      						(integer >> 16) & 0xFF,
      						(integer >> 8) & 0xFF,
      						integer & 0xFF
      					];
      				},
      				enumerable: false
      			},
      			hexToAnsi256: {
      				value: hex => styles.rgbToAnsi256(...styles.hexToRgb(hex)),
      				enumerable: false
      			}
      		});

      		return styles;
      	}

      	// Make the export immutable
      	Object.defineProperty(module, 'exports', {
      		enumerable: true,
      		get: assembleStyles
      	}); 
      } (ansiStyles));

      var ansiStylesExports = ansiStyles.exports;

      var collections = {};

      Object.defineProperty(collections, '__esModule', {
        value: true
      });
      collections.printIteratorEntries = printIteratorEntries;
      collections.printIteratorValues = printIteratorValues;
      collections.printListItems = printListItems;
      collections.printObjectProperties = printObjectProperties;

      /**
       * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
       *
       * This source code is licensed under the MIT license found in the
       * LICENSE file in the root directory of this source tree.
       *
       */
      const getKeysOfEnumerableProperties = (object, compareKeys) => {
        const keys = Object.keys(object).sort(compareKeys);

        if (Object.getOwnPropertySymbols) {
          Object.getOwnPropertySymbols(object).forEach(symbol => {
            if (Object.getOwnPropertyDescriptor(object, symbol).enumerable) {
              keys.push(symbol);
            }
          });
        }

        return keys;
      };
      /**
       * Return entries (for example, of a map)
       * with spacing, indentation, and comma
       * without surrounding punctuation (for example, braces)
       */

      function printIteratorEntries(
        iterator,
        config,
        indentation,
        depth,
        refs,
        printer, // Too bad, so sad that separator for ECMAScript Map has been ' => '
        // What a distracting diff if you change a data structure to/from
        // ECMAScript Object or Immutable.Map/OrderedMap which use the default.
        separator = ': '
      ) {
        let result = '';
        let current = iterator.next();

        if (!current.done) {
          result += config.spacingOuter;
          const indentationNext = indentation + config.indent;

          while (!current.done) {
            const name = printer(
              current.value[0],
              config,
              indentationNext,
              depth,
              refs
            );
            const value = printer(
              current.value[1],
              config,
              indentationNext,
              depth,
              refs
            );
            result += indentationNext + name + separator + value;
            current = iterator.next();

            if (!current.done) {
              result += ',' + config.spacingInner;
            } else if (!config.min) {
              result += ',';
            }
          }

          result += config.spacingOuter + indentation;
        }

        return result;
      }
      /**
       * Return values (for example, of a set)
       * with spacing, indentation, and comma
       * without surrounding punctuation (braces or brackets)
       */

      function printIteratorValues(
        iterator,
        config,
        indentation,
        depth,
        refs,
        printer
      ) {
        let result = '';
        let current = iterator.next();

        if (!current.done) {
          result += config.spacingOuter;
          const indentationNext = indentation + config.indent;

          while (!current.done) {
            result +=
              indentationNext +
              printer(current.value, config, indentationNext, depth, refs);
            current = iterator.next();

            if (!current.done) {
              result += ',' + config.spacingInner;
            } else if (!config.min) {
              result += ',';
            }
          }

          result += config.spacingOuter + indentation;
        }

        return result;
      }
      /**
       * Return items (for example, of an array)
       * with spacing, indentation, and comma
       * without surrounding punctuation (for example, brackets)
       **/

      function printListItems(list, config, indentation, depth, refs, printer) {
        let result = '';

        if (list.length) {
          result += config.spacingOuter;
          const indentationNext = indentation + config.indent;

          for (let i = 0; i < list.length; i++) {
            result += indentationNext;

            if (i in list) {
              result += printer(list[i], config, indentationNext, depth, refs);
            }

            if (i < list.length - 1) {
              result += ',' + config.spacingInner;
            } else if (!config.min) {
              result += ',';
            }
          }

          result += config.spacingOuter + indentation;
        }

        return result;
      }
      /**
       * Return properties of an object
       * with spacing, indentation, and comma
       * without surrounding punctuation (for example, braces)
       */

      function printObjectProperties(val, config, indentation, depth, refs, printer) {
        let result = '';
        const keys = getKeysOfEnumerableProperties(val, config.compareKeys);

        if (keys.length) {
          result += config.spacingOuter;
          const indentationNext = indentation + config.indent;

          for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            const name = printer(key, config, indentationNext, depth, refs);
            const value = printer(val[key], config, indentationNext, depth, refs);
            result += indentationNext + name + ': ' + value;

            if (i < keys.length - 1) {
              result += ',' + config.spacingInner;
            } else if (!config.min) {
              result += ',';
            }
          }

          result += config.spacingOuter + indentation;
        }

        return result;
      }

      var AsymmetricMatcher = {};

      Object.defineProperty(AsymmetricMatcher, '__esModule', {
        value: true
      });
      AsymmetricMatcher.test = AsymmetricMatcher.serialize = AsymmetricMatcher.default = void 0;

      var _collections$3 = collections;

      var global$2 = (function () {
        if (typeof globalThis !== 'undefined') {
          return globalThis;
        } else if (typeof global$2 !== 'undefined') {
          return global$2;
        } else if (typeof self !== 'undefined') {
          return self;
        } else if (typeof window !== 'undefined') {
          return window;
        } else {
          return Function('return this')();
        }
      })();

      var Symbol$2 = global$2['jest-symbol-do-not-touch'] || global$2.Symbol;
      const asymmetricMatcher =
        typeof Symbol$2 === 'function' && Symbol$2.for
          ? Symbol$2.for('jest.asymmetricMatcher')
          : 0x1357a5;
      const SPACE$2 = ' ';

      const serialize$6 = (val, config, indentation, depth, refs, printer) => {
        const stringedValue = val.toString();

        if (
          stringedValue === 'ArrayContaining' ||
          stringedValue === 'ArrayNotContaining'
        ) {
          if (++depth > config.maxDepth) {
            return '[' + stringedValue + ']';
          }

          return (
            stringedValue +
            SPACE$2 +
            '[' +
            (0, _collections$3.printListItems)(
              val.sample,
              config,
              indentation,
              depth,
              refs,
              printer
            ) +
            ']'
          );
        }

        if (
          stringedValue === 'ObjectContaining' ||
          stringedValue === 'ObjectNotContaining'
        ) {
          if (++depth > config.maxDepth) {
            return '[' + stringedValue + ']';
          }

          return (
            stringedValue +
            SPACE$2 +
            '{' +
            (0, _collections$3.printObjectProperties)(
              val.sample,
              config,
              indentation,
              depth,
              refs,
              printer
            ) +
            '}'
          );
        }

        if (
          stringedValue === 'StringMatching' ||
          stringedValue === 'StringNotMatching'
        ) {
          return (
            stringedValue +
            SPACE$2 +
            printer(val.sample, config, indentation, depth, refs)
          );
        }

        if (
          stringedValue === 'StringContaining' ||
          stringedValue === 'StringNotContaining'
        ) {
          return (
            stringedValue +
            SPACE$2 +
            printer(val.sample, config, indentation, depth, refs)
          );
        }

        return val.toAsymmetricMatcher();
      };

      AsymmetricMatcher.serialize = serialize$6;

      const test$6 = val => val && val.$$typeof === asymmetricMatcher;

      AsymmetricMatcher.test = test$6;
      const plugin$6 = {
        serialize: serialize$6,
        test: test$6
      };
      var _default$2q = plugin$6;
      AsymmetricMatcher.default = _default$2q;

      var ConvertAnsi = {};

      var ansiRegex = ({onlyFirst = false} = {}) => {
      	const pattern = [
      		'[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)',
      		'(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))'
      	].join('|');

      	return new RegExp(pattern, onlyFirst ? undefined : 'g');
      };

      Object.defineProperty(ConvertAnsi, '__esModule', {
        value: true
      });
      ConvertAnsi.test = ConvertAnsi.serialize = ConvertAnsi.default = void 0;

      var _ansiRegex = _interopRequireDefault$d(ansiRegex);

      var _ansiStyles$1 = _interopRequireDefault$d(ansiStylesExports);

      function _interopRequireDefault$d(obj) {
        return obj && obj.__esModule ? obj : {default: obj};
      }

      /**
       * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
       *
       * This source code is licensed under the MIT license found in the
       * LICENSE file in the root directory of this source tree.
       */
      const toHumanReadableAnsi = text =>
        text.replace((0, _ansiRegex.default)(), match => {
          switch (match) {
            case _ansiStyles$1.default.red.close:
            case _ansiStyles$1.default.green.close:
            case _ansiStyles$1.default.cyan.close:
            case _ansiStyles$1.default.gray.close:
            case _ansiStyles$1.default.white.close:
            case _ansiStyles$1.default.yellow.close:
            case _ansiStyles$1.default.bgRed.close:
            case _ansiStyles$1.default.bgGreen.close:
            case _ansiStyles$1.default.bgYellow.close:
            case _ansiStyles$1.default.inverse.close:
            case _ansiStyles$1.default.dim.close:
            case _ansiStyles$1.default.bold.close:
            case _ansiStyles$1.default.reset.open:
            case _ansiStyles$1.default.reset.close:
              return '</>';

            case _ansiStyles$1.default.red.open:
              return '<red>';

            case _ansiStyles$1.default.green.open:
              return '<green>';

            case _ansiStyles$1.default.cyan.open:
              return '<cyan>';

            case _ansiStyles$1.default.gray.open:
              return '<gray>';

            case _ansiStyles$1.default.white.open:
              return '<white>';

            case _ansiStyles$1.default.yellow.open:
              return '<yellow>';

            case _ansiStyles$1.default.bgRed.open:
              return '<bgRed>';

            case _ansiStyles$1.default.bgGreen.open:
              return '<bgGreen>';

            case _ansiStyles$1.default.bgYellow.open:
              return '<bgYellow>';

            case _ansiStyles$1.default.inverse.open:
              return '<inverse>';

            case _ansiStyles$1.default.dim.open:
              return '<dim>';

            case _ansiStyles$1.default.bold.open:
              return '<bold>';

            default:
              return '';
          }
        });

      const test$5 = val =>
        typeof val === 'string' && !!val.match((0, _ansiRegex.default)());

      ConvertAnsi.test = test$5;

      const serialize$5 = (val, config, indentation, depth, refs, printer) =>
        printer(toHumanReadableAnsi(val), config, indentation, depth, refs);

      ConvertAnsi.serialize = serialize$5;
      const plugin$5 = {
        serialize: serialize$5,
        test: test$5
      };
      var _default$2p = plugin$5;
      ConvertAnsi.default = _default$2p;

      var DOMCollection$1 = {};

      Object.defineProperty(DOMCollection$1, '__esModule', {
        value: true
      });
      DOMCollection$1.test = DOMCollection$1.serialize = DOMCollection$1.default = void 0;

      var _collections$2 = collections;

      /**
       * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
       *
       * This source code is licensed under the MIT license found in the
       * LICENSE file in the root directory of this source tree.
       */

      /* eslint-disable local/ban-types-eventually */
      const SPACE$1 = ' ';
      const OBJECT_NAMES = ['DOMStringMap', 'NamedNodeMap'];
      const ARRAY_REGEXP = /^(HTML\w*Collection|NodeList)$/;

      const testName = name =>
        OBJECT_NAMES.indexOf(name) !== -1 || ARRAY_REGEXP.test(name);

      const test$4 = val =>
        val &&
        val.constructor &&
        !!val.constructor.name &&
        testName(val.constructor.name);

      DOMCollection$1.test = test$4;

      const isNamedNodeMap = collection =>
        collection.constructor.name === 'NamedNodeMap';

      const serialize$4 = (collection, config, indentation, depth, refs, printer) => {
        const name = collection.constructor.name;

        if (++depth > config.maxDepth) {
          return '[' + name + ']';
        }

        return (
          (config.min ? '' : name + SPACE$1) +
          (OBJECT_NAMES.indexOf(name) !== -1
            ? '{' +
              (0, _collections$2.printObjectProperties)(
                isNamedNodeMap(collection)
                  ? Array.from(collection).reduce((props, attribute) => {
                      props[attribute.name] = attribute.value;
                      return props;
                    }, {})
                  : {...collection},
                config,
                indentation,
                depth,
                refs,
                printer
              ) +
              '}'
            : '[' +
              (0, _collections$2.printListItems)(
                Array.from(collection),
                config,
                indentation,
                depth,
                refs,
                printer
              ) +
              ']')
        );
      };

      DOMCollection$1.serialize = serialize$4;
      const plugin$4 = {
        serialize: serialize$4,
        test: test$4
      };
      var _default$2o = plugin$4;
      DOMCollection$1.default = _default$2o;

      var DOMElement = {};

      var markup = {};

      var escapeHTML$2 = {};

      Object.defineProperty(escapeHTML$2, '__esModule', {
        value: true
      });
      escapeHTML$2.default = escapeHTML$1;

      /**
       * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
       *
       * This source code is licensed under the MIT license found in the
       * LICENSE file in the root directory of this source tree.
       */
      function escapeHTML$1(str) {
        return str.replace(/</g, '&lt;').replace(/>/g, '&gt;');
      }

      Object.defineProperty(markup, '__esModule', {
        value: true
      });
      markup.printText =
        markup.printProps =
        markup.printElementAsLeaf =
        markup.printElement =
        markup.printComment =
        markup.printChildren =
          void 0;

      var _escapeHTML = _interopRequireDefault$c(escapeHTML$2);

      function _interopRequireDefault$c(obj) {
        return obj && obj.__esModule ? obj : {default: obj};
      }

      /**
       * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
       *
       * This source code is licensed under the MIT license found in the
       * LICENSE file in the root directory of this source tree.
       */
      // Return empty string if keys is empty.
      const printProps$1 = (keys, props, config, indentation, depth, refs, printer) => {
        const indentationNext = indentation + config.indent;
        const colors = config.colors;
        return keys
          .map(key => {
            const value = props[key];
            let printed = printer(value, config, indentationNext, depth, refs);

            if (typeof value !== 'string') {
              if (printed.indexOf('\n') !== -1) {
                printed =
                  config.spacingOuter +
                  indentationNext +
                  printed +
                  config.spacingOuter +
                  indentation;
              }

              printed = '{' + printed + '}';
            }

            return (
              config.spacingInner +
              indentation +
              colors.prop.open +
              key +
              colors.prop.close +
              '=' +
              colors.value.open +
              printed +
              colors.value.close
            );
          })
          .join('');
      }; // Return empty string if children is empty.

      markup.printProps = printProps$1;

      const printChildren$1 = (children, config, indentation, depth, refs, printer) =>
        children
          .map(
            child =>
              config.spacingOuter +
              indentation +
              (typeof child === 'string'
                ? printText$1(child, config)
                : printer(child, config, indentation, depth, refs))
          )
          .join('');

      markup.printChildren = printChildren$1;

      const printText$1 = (text, config) => {
        const contentColor = config.colors.content;
        return (
          contentColor.open + (0, _escapeHTML.default)(text) + contentColor.close
        );
      };

      markup.printText = printText$1;

      const printComment$1 = (comment, config) => {
        const commentColor = config.colors.comment;
        return (
          commentColor.open +
          '<!--' +
          (0, _escapeHTML.default)(comment) +
          '-->' +
          commentColor.close
        );
      }; // Separate the functions to format props, children, and element,
      // so a plugin could override a particular function, if needed.
      // Too bad, so sad: the traditional (but unnecessary) space
      // in a self-closing tagColor requires a second test of printedProps.

      markup.printComment = printComment$1;

      const printElement$1 = (
        type,
        printedProps,
        printedChildren,
        config,
        indentation
      ) => {
        const tagColor = config.colors.tag;
        return (
          tagColor.open +
          '<' +
          type +
          (printedProps &&
            tagColor.close +
              printedProps +
              config.spacingOuter +
              indentation +
              tagColor.open) +
          (printedChildren
            ? '>' +
              tagColor.close +
              printedChildren +
              config.spacingOuter +
              indentation +
              tagColor.open +
              '</' +
              type
            : (printedProps && !config.min ? '' : ' ') + '/') +
          '>' +
          tagColor.close
        );
      };

      markup.printElement = printElement$1;

      const printElementAsLeaf$1 = (type, config) => {
        const tagColor = config.colors.tag;
        return (
          tagColor.open +
          '<' +
          type +
          tagColor.close +
          ' …' +
          tagColor.open +
          ' />' +
          tagColor.close
        );
      };

      markup.printElementAsLeaf = printElementAsLeaf$1;

      Object.defineProperty(DOMElement, '__esModule', {
        value: true
      });
      DOMElement.test = DOMElement.serialize = DOMElement.default = void 0;

      var _markup$2 = markup;

      /**
       * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
       *
       * This source code is licensed under the MIT license found in the
       * LICENSE file in the root directory of this source tree.
       */
      const ELEMENT_NODE$2 = 1;
      const TEXT_NODE$2 = 3;
      const COMMENT_NODE$2 = 8;
      const FRAGMENT_NODE$1 = 11;
      const ELEMENT_REGEXP$1 = /^((HTML|SVG)\w*)?Element$/;

      const testHasAttribute = val => {
        try {
          return typeof val.hasAttribute === 'function' && val.hasAttribute('is');
        } catch {
          return false;
        }
      };

      const testNode$1 = val => {
        const constructorName = val.constructor.name;
        const {nodeType, tagName} = val;
        const isCustomElement =
          (typeof tagName === 'string' && tagName.includes('-')) ||
          testHasAttribute(val);
        return (
          (nodeType === ELEMENT_NODE$2 &&
            (ELEMENT_REGEXP$1.test(constructorName) || isCustomElement)) ||
          (nodeType === TEXT_NODE$2 && constructorName === 'Text') ||
          (nodeType === COMMENT_NODE$2 && constructorName === 'Comment') ||
          (nodeType === FRAGMENT_NODE$1 && constructorName === 'DocumentFragment')
        );
      };

      const test$3 = val => {
        var _val$constructor;

        return (
          (val === null || val === void 0
            ? void 0
            : (_val$constructor = val.constructor) === null ||
              _val$constructor === void 0
            ? void 0
            : _val$constructor.name) && testNode$1(val)
        );
      };

      DOMElement.test = test$3;

      function nodeIsText$1(node) {
        return node.nodeType === TEXT_NODE$2;
      }

      function nodeIsComment$1(node) {
        return node.nodeType === COMMENT_NODE$2;
      }

      function nodeIsFragment$1(node) {
        return node.nodeType === FRAGMENT_NODE$1;
      }

      const serialize$3 = (node, config, indentation, depth, refs, printer) => {
        if (nodeIsText$1(node)) {
          return (0, _markup$2.printText)(node.data, config);
        }

        if (nodeIsComment$1(node)) {
          return (0, _markup$2.printComment)(node.data, config);
        }

        const type = nodeIsFragment$1(node)
          ? 'DocumentFragment'
          : node.tagName.toLowerCase();

        if (++depth > config.maxDepth) {
          return (0, _markup$2.printElementAsLeaf)(type, config);
        }

        return (0, _markup$2.printElement)(
          type,
          (0, _markup$2.printProps)(
            nodeIsFragment$1(node)
              ? []
              : Array.from(node.attributes)
                  .map(attr => attr.name)
                  .sort(),
            nodeIsFragment$1(node)
              ? {}
              : Array.from(node.attributes).reduce((props, attribute) => {
                  props[attribute.name] = attribute.value;
                  return props;
                }, {}),
            config,
            indentation + config.indent,
            depth,
            refs,
            printer
          ),
          (0, _markup$2.printChildren)(
            Array.prototype.slice.call(node.childNodes || node.children),
            config,
            indentation + config.indent,
            depth,
            refs,
            printer
          ),
          config,
          indentation
        );
      };

      DOMElement.serialize = serialize$3;
      const plugin$3 = {
        serialize: serialize$3,
        test: test$3
      };
      var _default$2n = plugin$3;
      DOMElement.default = _default$2n;

      var Immutable = {};

      Object.defineProperty(Immutable, '__esModule', {
        value: true
      });
      Immutable.test = Immutable.serialize = Immutable.default = void 0;

      var _collections$1 = collections;

      /**
       * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
       *
       * This source code is licensed under the MIT license found in the
       * LICENSE file in the root directory of this source tree.
       */
      // SENTINEL constants are from https://github.com/facebook/immutable-js
      const IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
      const IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';
      const IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
      const IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';
      const IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';
      const IS_RECORD_SENTINEL = '@@__IMMUTABLE_RECORD__@@'; // immutable v4

      const IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';
      const IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';
      const IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';

      const getImmutableName = name => 'Immutable.' + name;

      const printAsLeaf = name => '[' + name + ']';

      const SPACE = ' ';
      const LAZY = '…'; // Seq is lazy if it calls a method like filter

      const printImmutableEntries = (
        val,
        config,
        indentation,
        depth,
        refs,
        printer,
        type
      ) =>
        ++depth > config.maxDepth
          ? printAsLeaf(getImmutableName(type))
          : getImmutableName(type) +
            SPACE +
            '{' +
            (0, _collections$1.printIteratorEntries)(
              val.entries(),
              config,
              indentation,
              depth,
              refs,
              printer
            ) +
            '}'; // Record has an entries method because it is a collection in immutable v3.
      // Return an iterator for Immutable Record from version v3 or v4.

      function getRecordEntries(val) {
        let i = 0;
        return {
          next() {
            if (i < val._keys.length) {
              const key = val._keys[i++];
              return {
                done: false,
                value: [key, val.get(key)]
              };
            }

            return {
              done: true,
              value: undefined
            };
          }
        };
      }

      const printImmutableRecord = (
        val,
        config,
        indentation,
        depth,
        refs,
        printer
      ) => {
        // _name property is defined only for an Immutable Record instance
        // which was constructed with a second optional descriptive name arg
        const name = getImmutableName(val._name || 'Record');
        return ++depth > config.maxDepth
          ? printAsLeaf(name)
          : name +
              SPACE +
              '{' +
              (0, _collections$1.printIteratorEntries)(
                getRecordEntries(val),
                config,
                indentation,
                depth,
                refs,
                printer
              ) +
              '}';
      };

      const printImmutableSeq = (val, config, indentation, depth, refs, printer) => {
        const name = getImmutableName('Seq');

        if (++depth > config.maxDepth) {
          return printAsLeaf(name);
        }

        if (val[IS_KEYED_SENTINEL]) {
          return (
            name +
            SPACE +
            '{' + // from Immutable collection of entries or from ECMAScript object
            (val._iter || val._object
              ? (0, _collections$1.printIteratorEntries)(
                  val.entries(),
                  config,
                  indentation,
                  depth,
                  refs,
                  printer
                )
              : LAZY) +
            '}'
          );
        }

        return (
          name +
          SPACE +
          '[' +
          (val._iter || // from Immutable collection of values
          val._array || // from ECMAScript array
          val._collection || // from ECMAScript collection in immutable v4
          val._iterable // from ECMAScript collection in immutable v3
            ? (0, _collections$1.printIteratorValues)(
                val.values(),
                config,
                indentation,
                depth,
                refs,
                printer
              )
            : LAZY) +
          ']'
        );
      };

      const printImmutableValues = (
        val,
        config,
        indentation,
        depth,
        refs,
        printer,
        type
      ) =>
        ++depth > config.maxDepth
          ? printAsLeaf(getImmutableName(type))
          : getImmutableName(type) +
            SPACE +
            '[' +
            (0, _collections$1.printIteratorValues)(
              val.values(),
              config,
              indentation,
              depth,
              refs,
              printer
            ) +
            ']';

      const serialize$2 = (val, config, indentation, depth, refs, printer) => {
        if (val[IS_MAP_SENTINEL]) {
          return printImmutableEntries(
            val,
            config,
            indentation,
            depth,
            refs,
            printer,
            val[IS_ORDERED_SENTINEL] ? 'OrderedMap' : 'Map'
          );
        }

        if (val[IS_LIST_SENTINEL]) {
          return printImmutableValues(
            val,
            config,
            indentation,
            depth,
            refs,
            printer,
            'List'
          );
        }

        if (val[IS_SET_SENTINEL]) {
          return printImmutableValues(
            val,
            config,
            indentation,
            depth,
            refs,
            printer,
            val[IS_ORDERED_SENTINEL] ? 'OrderedSet' : 'Set'
          );
        }

        if (val[IS_STACK_SENTINEL]) {
          return printImmutableValues(
            val,
            config,
            indentation,
            depth,
            refs,
            printer,
            'Stack'
          );
        }

        if (val[IS_SEQ_SENTINEL]) {
          return printImmutableSeq(val, config, indentation, depth, refs, printer);
        } // For compatibility with immutable v3 and v4, let record be the default.

        return printImmutableRecord(val, config, indentation, depth, refs, printer);
      }; // Explicitly comparing sentinel properties to true avoids false positive
      // when mock identity-obj-proxy returns the key as the value for any key.

      Immutable.serialize = serialize$2;

      const test$2 = val =>
        val &&
        (val[IS_ITERABLE_SENTINEL] === true || val[IS_RECORD_SENTINEL] === true);

      Immutable.test = test$2;
      const plugin$2 = {
        serialize: serialize$2,
        test: test$2
      };
      var _default$2m = plugin$2;
      Immutable.default = _default$2m;

      var ReactElement = {};

      var reactIs = {exports: {}};

      var reactIs_production_min = {};

      /** @license React v17.0.2
       * react-is.production.min.js
       *
       * Copyright (c) Facebook, Inc. and its affiliates.
       *
       * This source code is licensed under the MIT license found in the
       * LICENSE file in the root directory of this source tree.
       */
      var b=60103,c=60106,d=60107,e=60108,f=60114,g=60109,h=60110,k$2=60112,l=60113,m=60120,n=60115,p=60116,q=60121,r=60122,u=60117,v=60129,w=60131;
      if("function"===typeof Symbol&&Symbol.for){var x=Symbol.for;b=x("react.element");c=x("react.portal");d=x("react.fragment");e=x("react.strict_mode");f=x("react.profiler");g=x("react.provider");h=x("react.context");k$2=x("react.forward_ref");l=x("react.suspense");m=x("react.suspense_list");n=x("react.memo");p=x("react.lazy");q=x("react.block");r=x("react.server.block");u=x("react.fundamental");v=x("react.debug_trace_mode");w=x("react.legacy_hidden");}
      function y(a){if("object"===typeof a&&null!==a){var t=a.$$typeof;switch(t){case b:switch(a=a.type,a){case d:case f:case e:case l:case m:return a;default:switch(a=a&&a.$$typeof,a){case h:case k$2:case p:case n:case g:return a;default:return t}}case c:return t}}}var z=g,A=b,B=k$2,C=d,D=p,E=n,F=c,G=f,H=e,I=l;reactIs_production_min.ContextConsumer=h;reactIs_production_min.ContextProvider=z;reactIs_production_min.Element=A;reactIs_production_min.ForwardRef=B;reactIs_production_min.Fragment=C;reactIs_production_min.Lazy=D;reactIs_production_min.Memo=E;reactIs_production_min.Portal=F;reactIs_production_min.Profiler=G;reactIs_production_min.StrictMode=H;
      reactIs_production_min.Suspense=I;reactIs_production_min.isAsyncMode=function(){return  false};reactIs_production_min.isConcurrentMode=function(){return  false};reactIs_production_min.isContextConsumer=function(a){return y(a)===h};reactIs_production_min.isContextProvider=function(a){return y(a)===g};reactIs_production_min.isElement=function(a){return "object"===typeof a&&null!==a&&a.$$typeof===b};reactIs_production_min.isForwardRef=function(a){return y(a)===k$2};reactIs_production_min.isFragment=function(a){return y(a)===d};reactIs_production_min.isLazy=function(a){return y(a)===p};reactIs_production_min.isMemo=function(a){return y(a)===n};
      reactIs_production_min.isPortal=function(a){return y(a)===c};reactIs_production_min.isProfiler=function(a){return y(a)===f};reactIs_production_min.isStrictMode=function(a){return y(a)===e};reactIs_production_min.isSuspense=function(a){return y(a)===l};reactIs_production_min.isValidElementType=function(a){return "string"===typeof a||"function"===typeof a||a===d||a===f||a===v||a===e||a===l||a===m||a===w||"object"===typeof a&&null!==a&&(a.$$typeof===p||a.$$typeof===n||a.$$typeof===g||a.$$typeof===h||a.$$typeof===k$2||a.$$typeof===u||a.$$typeof===q||a[0]===r)?true:false};
      reactIs_production_min.typeOf=y;

      {
        reactIs.exports = reactIs_production_min;
      }

      var reactIsExports = reactIs.exports;

      Object.defineProperty(ReactElement, '__esModule', {
        value: true
      });
      ReactElement.test = ReactElement.serialize = ReactElement.default = void 0;

      var ReactIs = _interopRequireWildcard(reactIsExports);

      var _markup$1 = markup;

      function _getRequireWildcardCache(nodeInterop) {
        if (typeof WeakMap !== 'function') return null;
        var cacheBabelInterop = new WeakMap();
        var cacheNodeInterop = new WeakMap();
        return (_getRequireWildcardCache = function (nodeInterop) {
          return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
      }

      function _interopRequireWildcard(obj, nodeInterop) {
        if (obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
          return {default: obj};
        }
        var cache = _getRequireWildcardCache(nodeInterop);
        if (cache && cache.has(obj)) {
          return cache.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor =
          Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (key !== 'default' && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor
              ? Object.getOwnPropertyDescriptor(obj, key)
              : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj.default = obj;
        if (cache) {
          cache.set(obj, newObj);
        }
        return newObj;
      }

      /**
       * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
       *
       * This source code is licensed under the MIT license found in the
       * LICENSE file in the root directory of this source tree.
       */
      // Given element.props.children, or subtree during recursive traversal,
      // return flattened array of children.
      const getChildren = (arg, children = []) => {
        if (Array.isArray(arg)) {
          arg.forEach(item => {
            getChildren(item, children);
          });
        } else if (arg != null && arg !== false) {
          children.push(arg);
        }

        return children;
      };

      const getType = element => {
        const type = element.type;

        if (typeof type === 'string') {
          return type;
        }

        if (typeof type === 'function') {
          return type.displayName || type.name || 'Unknown';
        }

        if (ReactIs.isFragment(element)) {
          return 'React.Fragment';
        }

        if (ReactIs.isSuspense(element)) {
          return 'React.Suspense';
        }

        if (typeof type === 'object' && type !== null) {
          if (ReactIs.isContextProvider(element)) {
            return 'Context.Provider';
          }

          if (ReactIs.isContextConsumer(element)) {
            return 'Context.Consumer';
          }

          if (ReactIs.isForwardRef(element)) {
            if (type.displayName) {
              return type.displayName;
            }

            const functionName = type.render.displayName || type.render.name || '';
            return functionName !== ''
              ? 'ForwardRef(' + functionName + ')'
              : 'ForwardRef';
          }

          if (ReactIs.isMemo(element)) {
            const functionName =
              type.displayName || type.type.displayName || type.type.name || '';
            return functionName !== '' ? 'Memo(' + functionName + ')' : 'Memo';
          }
        }

        return 'UNDEFINED';
      };

      const getPropKeys$1 = element => {
        const {props} = element;
        return Object.keys(props)
          .filter(key => key !== 'children' && props[key] !== undefined)
          .sort();
      };

      const serialize$1 = (element, config, indentation, depth, refs, printer) =>
        ++depth > config.maxDepth
          ? (0, _markup$1.printElementAsLeaf)(getType(element), config)
          : (0, _markup$1.printElement)(
              getType(element),
              (0, _markup$1.printProps)(
                getPropKeys$1(element),
                element.props,
                config,
                indentation + config.indent,
                depth,
                refs,
                printer
              ),
              (0, _markup$1.printChildren)(
                getChildren(element.props.children),
                config,
                indentation + config.indent,
                depth,
                refs,
                printer
              ),
              config,
              indentation
            );

      ReactElement.serialize = serialize$1;

      const test$1 = val => val != null && ReactIs.isElement(val);

      ReactElement.test = test$1;
      const plugin$1 = {
        serialize: serialize$1,
        test: test$1
      };
      var _default$2l = plugin$1;
      ReactElement.default = _default$2l;

      var ReactTestComponent = {};

      Object.defineProperty(ReactTestComponent, '__esModule', {
        value: true
      });
      ReactTestComponent.test = ReactTestComponent.serialize = ReactTestComponent.default = void 0;

      var _markup = markup;

      var global$1 = (function () {
        if (typeof globalThis !== 'undefined') {
          return globalThis;
        } else if (typeof global$1 !== 'undefined') {
          return global$1;
        } else if (typeof self !== 'undefined') {
          return self;
        } else if (typeof window !== 'undefined') {
          return window;
        } else {
          return Function('return this')();
        }
      })();

      var Symbol$1 = global$1['jest-symbol-do-not-touch'] || global$1.Symbol;
      const testSymbol =
        typeof Symbol$1 === 'function' && Symbol$1.for
          ? Symbol$1.for('react.test.json')
          : 0xea71357;

      const getPropKeys = object => {
        const {props} = object;
        return props
          ? Object.keys(props)
              .filter(key => props[key] !== undefined)
              .sort()
          : [];
      };

      const serialize = (object, config, indentation, depth, refs, printer) =>
        ++depth > config.maxDepth
          ? (0, _markup.printElementAsLeaf)(object.type, config)
          : (0, _markup.printElement)(
              object.type,
              object.props
                ? (0, _markup.printProps)(
                    getPropKeys(object),
                    object.props,
                    config,
                    indentation + config.indent,
                    depth,
                    refs,
                    printer
                  )
                : '',
              object.children
                ? (0, _markup.printChildren)(
                    object.children,
                    config,
                    indentation + config.indent,
                    depth,
                    refs,
                    printer
                  )
                : '',
              config,
              indentation
            );

      ReactTestComponent.serialize = serialize;

      const test = val => val && val.$$typeof === testSymbol;

      ReactTestComponent.test = test;
      const plugin = {
        serialize,
        test
      };
      var _default$2k = plugin;
      ReactTestComponent.default = _default$2k;

      Object.defineProperty(build$1, '__esModule', {
        value: true
      });
      build$1.default = build$1.DEFAULT_OPTIONS = void 0;
      var format_1 = build$1.format = format;
      var plugins_1 = build$1.plugins = void 0;

      var _ansiStyles = _interopRequireDefault$b(ansiStylesExports);

      var _collections = collections;

      var _AsymmetricMatcher = _interopRequireDefault$b(
        AsymmetricMatcher
      );

      var _ConvertAnsi = _interopRequireDefault$b(ConvertAnsi);

      var _DOMCollection = _interopRequireDefault$b(DOMCollection$1);

      var _DOMElement = _interopRequireDefault$b(DOMElement);

      var _Immutable = _interopRequireDefault$b(Immutable);

      var _ReactElement = _interopRequireDefault$b(ReactElement);

      var _ReactTestComponent = _interopRequireDefault$b(
        ReactTestComponent
      );

      function _interopRequireDefault$b(obj) {
        return obj && obj.__esModule ? obj : {default: obj};
      }

      /**
       * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
       *
       * This source code is licensed under the MIT license found in the
       * LICENSE file in the root directory of this source tree.
       */

      /* eslint-disable local/ban-types-eventually */
      const toString = Object.prototype.toString;
      const toISOString = Date.prototype.toISOString;
      const errorToString = Error.prototype.toString;
      const regExpToString = RegExp.prototype.toString;
      /**
       * Explicitly comparing typeof constructor to function avoids undefined as name
       * when mock identity-obj-proxy returns the key as the value for any key.
       */

      const getConstructorName = val =>
        (typeof val.constructor === 'function' && val.constructor.name) || 'Object';
      /* global window */

      /** Is val is equal to global window object? Works even if it does not exist :) */

      const isWindow = val => typeof window !== 'undefined' && val === window;

      const SYMBOL_REGEXP = /^Symbol\((.*)\)(.*)$/;
      const NEWLINE_REGEXP = /\n/gi;

      class PrettyFormatPluginError extends Error {
        constructor(message, stack) {
          super(message);
          this.stack = stack;
          this.name = this.constructor.name;
        }
      }

      function isToStringedArrayType(toStringed) {
        return (
          toStringed === '[object Array]' ||
          toStringed === '[object ArrayBuffer]' ||
          toStringed === '[object DataView]' ||
          toStringed === '[object Float32Array]' ||
          toStringed === '[object Float64Array]' ||
          toStringed === '[object Int8Array]' ||
          toStringed === '[object Int16Array]' ||
          toStringed === '[object Int32Array]' ||
          toStringed === '[object Uint8Array]' ||
          toStringed === '[object Uint8ClampedArray]' ||
          toStringed === '[object Uint16Array]' ||
          toStringed === '[object Uint32Array]'
        );
      }

      function printNumber(val) {
        return Object.is(val, -0) ? '-0' : String(val);
      }

      function printBigInt(val) {
        return String(`${val}n`);
      }

      function printFunction(val, printFunctionName) {
        if (!printFunctionName) {
          return '[Function]';
        }

        return '[Function ' + (val.name || 'anonymous') + ']';
      }

      function printSymbol(val) {
        return String(val).replace(SYMBOL_REGEXP, 'Symbol($1)');
      }

      function printError(val) {
        return '[' + errorToString.call(val) + ']';
      }
      /**
       * The first port of call for printing an object, handles most of the
       * data-types in JS.
       */

      function printBasicValue(val, printFunctionName, escapeRegex, escapeString) {
        if (val === true || val === false) {
          return '' + val;
        }

        if (val === undefined) {
          return 'undefined';
        }

        if (val === null) {
          return 'null';
        }

        const typeOf = typeof val;

        if (typeOf === 'number') {
          return printNumber(val);
        }

        if (typeOf === 'bigint') {
          return printBigInt(val);
        }

        if (typeOf === 'string') {
          if (escapeString) {
            return '"' + val.replace(/"|\\/g, '\\$&') + '"';
          }

          return '"' + val + '"';
        }

        if (typeOf === 'function') {
          return printFunction(val, printFunctionName);
        }

        if (typeOf === 'symbol') {
          return printSymbol(val);
        }

        const toStringed = toString.call(val);

        if (toStringed === '[object WeakMap]') {
          return 'WeakMap {}';
        }

        if (toStringed === '[object WeakSet]') {
          return 'WeakSet {}';
        }

        if (
          toStringed === '[object Function]' ||
          toStringed === '[object GeneratorFunction]'
        ) {
          return printFunction(val, printFunctionName);
        }

        if (toStringed === '[object Symbol]') {
          return printSymbol(val);
        }

        if (toStringed === '[object Date]') {
          return isNaN(+val) ? 'Date { NaN }' : toISOString.call(val);
        }

        if (toStringed === '[object Error]') {
          return printError(val);
        }

        if (toStringed === '[object RegExp]') {
          if (escapeRegex) {
            // https://github.com/benjamingr/RegExp.escape/blob/main/polyfill.js
            return regExpToString.call(val).replace(/[\\^$*+?.()|[\]{}]/g, '\\$&');
          }

          return regExpToString.call(val);
        }

        if (val instanceof Error) {
          return printError(val);
        }

        return null;
      }
      /**
       * Handles more complex objects ( such as objects with circular references.
       * maps and sets etc )
       */

      function printComplexValue(
        val,
        config,
        indentation,
        depth,
        refs,
        hasCalledToJSON
      ) {
        if (refs.indexOf(val) !== -1) {
          return '[Circular]';
        }

        refs = refs.slice();
        refs.push(val);
        const hitMaxDepth = ++depth > config.maxDepth;
        const min = config.min;

        if (
          config.callToJSON &&
          !hitMaxDepth &&
          val.toJSON &&
          typeof val.toJSON === 'function' &&
          !hasCalledToJSON
        ) {
          return printer(val.toJSON(), config, indentation, depth, refs, true);
        }

        const toStringed = toString.call(val);

        if (toStringed === '[object Arguments]') {
          return hitMaxDepth
            ? '[Arguments]'
            : (min ? '' : 'Arguments ') +
                '[' +
                (0, _collections.printListItems)(
                  val,
                  config,
                  indentation,
                  depth,
                  refs,
                  printer
                ) +
                ']';
        }

        if (isToStringedArrayType(toStringed)) {
          return hitMaxDepth
            ? '[' + val.constructor.name + ']'
            : (min
                ? ''
                : !config.printBasicPrototype && val.constructor.name === 'Array'
                ? ''
                : val.constructor.name + ' ') +
                '[' +
                (0, _collections.printListItems)(
                  val,
                  config,
                  indentation,
                  depth,
                  refs,
                  printer
                ) +
                ']';
        }

        if (toStringed === '[object Map]') {
          return hitMaxDepth
            ? '[Map]'
            : 'Map {' +
                (0, _collections.printIteratorEntries)(
                  val.entries(),
                  config,
                  indentation,
                  depth,
                  refs,
                  printer,
                  ' => '
                ) +
                '}';
        }

        if (toStringed === '[object Set]') {
          return hitMaxDepth
            ? '[Set]'
            : 'Set {' +
                (0, _collections.printIteratorValues)(
                  val.values(),
                  config,
                  indentation,
                  depth,
                  refs,
                  printer
                ) +
                '}';
        } // Avoid failure to serialize global window object in jsdom test environment.
        // For example, not even relevant if window is prop of React element.

        return hitMaxDepth || isWindow(val)
          ? '[' + getConstructorName(val) + ']'
          : (min
              ? ''
              : !config.printBasicPrototype && getConstructorName(val) === 'Object'
              ? ''
              : getConstructorName(val) + ' ') +
              '{' +
              (0, _collections.printObjectProperties)(
                val,
                config,
                indentation,
                depth,
                refs,
                printer
              ) +
              '}';
      }

      function isNewPlugin(plugin) {
        return plugin.serialize != null;
      }

      function printPlugin(plugin, val, config, indentation, depth, refs) {
        let printed;

        try {
          printed = isNewPlugin(plugin)
            ? plugin.serialize(val, config, indentation, depth, refs, printer)
            : plugin.print(
                val,
                valChild => printer(valChild, config, indentation, depth, refs),
                str => {
                  const indentationNext = indentation + config.indent;
                  return (
                    indentationNext +
                    str.replace(NEWLINE_REGEXP, '\n' + indentationNext)
                  );
                },
                {
                  edgeSpacing: config.spacingOuter,
                  min: config.min,
                  spacing: config.spacingInner
                },
                config.colors
              );
        } catch (error) {
          throw new PrettyFormatPluginError(error.message, error.stack);
        }

        if (typeof printed !== 'string') {
          throw new Error(
            `pretty-format: Plugin must return type "string" but instead returned "${typeof printed}".`
          );
        }

        return printed;
      }

      function findPlugin(plugins, val) {
        for (let p = 0; p < plugins.length; p++) {
          try {
            if (plugins[p].test(val)) {
              return plugins[p];
            }
          } catch (error) {
            throw new PrettyFormatPluginError(error.message, error.stack);
          }
        }

        return null;
      }

      function printer(val, config, indentation, depth, refs, hasCalledToJSON) {
        const plugin = findPlugin(config.plugins, val);

        if (plugin !== null) {
          return printPlugin(plugin, val, config, indentation, depth, refs);
        }

        const basicResult = printBasicValue(
          val,
          config.printFunctionName,
          config.escapeRegex,
          config.escapeString
        );

        if (basicResult !== null) {
          return basicResult;
        }

        return printComplexValue(
          val,
          config,
          indentation,
          depth,
          refs,
          hasCalledToJSON
        );
      }

      const DEFAULT_THEME = {
        comment: 'gray',
        content: 'reset',
        prop: 'yellow',
        tag: 'cyan',
        value: 'green'
      };
      const DEFAULT_THEME_KEYS = Object.keys(DEFAULT_THEME);
      const DEFAULT_OPTIONS = {
        callToJSON: true,
        compareKeys: undefined,
        escapeRegex: false,
        escapeString: true,
        highlight: false,
        indent: 2,
        maxDepth: Infinity,
        min: false,
        plugins: [],
        printBasicPrototype: true,
        printFunctionName: true,
        theme: DEFAULT_THEME
      };
      build$1.DEFAULT_OPTIONS = DEFAULT_OPTIONS;

      function validateOptions(options) {
        Object.keys(options).forEach(key => {
          if (!DEFAULT_OPTIONS.hasOwnProperty(key)) {
            throw new Error(`pretty-format: Unknown option "${key}".`);
          }
        });

        if (options.min && options.indent !== undefined && options.indent !== 0) {
          throw new Error(
            'pretty-format: Options "min" and "indent" cannot be used together.'
          );
        }

        if (options.theme !== undefined) {
          if (options.theme === null) {
            throw new Error('pretty-format: Option "theme" must not be null.');
          }

          if (typeof options.theme !== 'object') {
            throw new Error(
              `pretty-format: Option "theme" must be of type "object" but instead received "${typeof options.theme}".`
            );
          }
        }
      }

      const getColorsHighlight = options =>
        DEFAULT_THEME_KEYS.reduce((colors, key) => {
          const value =
            options.theme && options.theme[key] !== undefined
              ? options.theme[key]
              : DEFAULT_THEME[key];
          const color = value && _ansiStyles.default[value];

          if (
            color &&
            typeof color.close === 'string' &&
            typeof color.open === 'string'
          ) {
            colors[key] = color;
          } else {
            throw new Error(
              `pretty-format: Option "theme" has a key "${key}" whose value "${value}" is undefined in ansi-styles.`
            );
          }

          return colors;
        }, Object.create(null));

      const getColorsEmpty = () =>
        DEFAULT_THEME_KEYS.reduce((colors, key) => {
          colors[key] = {
            close: '',
            open: ''
          };
          return colors;
        }, Object.create(null));

      const getPrintFunctionName = options =>
        options && options.printFunctionName !== undefined
          ? options.printFunctionName
          : DEFAULT_OPTIONS.printFunctionName;

      const getEscapeRegex = options =>
        options && options.escapeRegex !== undefined
          ? options.escapeRegex
          : DEFAULT_OPTIONS.escapeRegex;

      const getEscapeString = options =>
        options && options.escapeString !== undefined
          ? options.escapeString
          : DEFAULT_OPTIONS.escapeString;

      const getConfig$1 = options => {
        var _options$printBasicPr;

        return {
          callToJSON:
            options && options.callToJSON !== undefined
              ? options.callToJSON
              : DEFAULT_OPTIONS.callToJSON,
          colors:
            options && options.highlight
              ? getColorsHighlight(options)
              : getColorsEmpty(),
          compareKeys:
            options && typeof options.compareKeys === 'function'
              ? options.compareKeys
              : DEFAULT_OPTIONS.compareKeys,
          escapeRegex: getEscapeRegex(options),
          escapeString: getEscapeString(options),
          indent:
            options && options.min
              ? ''
              : createIndent(
                  options && options.indent !== undefined
                    ? options.indent
                    : DEFAULT_OPTIONS.indent
                ),
          maxDepth:
            options && options.maxDepth !== undefined
              ? options.maxDepth
              : DEFAULT_OPTIONS.maxDepth,
          min:
            options && options.min !== undefined ? options.min : DEFAULT_OPTIONS.min,
          plugins:
            options && options.plugins !== undefined
              ? options.plugins
              : DEFAULT_OPTIONS.plugins,
          printBasicPrototype:
            (_options$printBasicPr =
              options === null || options === void 0
                ? void 0
                : options.printBasicPrototype) !== null &&
            _options$printBasicPr !== void 0
              ? _options$printBasicPr
              : true,
          printFunctionName: getPrintFunctionName(options),
          spacingInner: options && options.min ? ' ' : '\n',
          spacingOuter: options && options.min ? '' : '\n'
        };
      };

      function createIndent(indent) {
        return new Array(indent + 1).join(' ');
      }
      /**
       * Returns a presentation string of your `val` object
       * @param val any potential JavaScript object
       * @param options Custom settings
       */

      function format(val, options) {
        if (options) {
          validateOptions(options);

          if (options.plugins) {
            const plugin = findPlugin(options.plugins, val);

            if (plugin !== null) {
              return printPlugin(plugin, val, getConfig$1(options), '', 0, []);
            }
          }
        }

        const basicResult = printBasicValue(
          val,
          getPrintFunctionName(options),
          getEscapeRegex(options),
          getEscapeString(options)
        );

        if (basicResult !== null) {
          return basicResult;
        }

        return printComplexValue(val, getConfig$1(options), '', 0, []);
      }

      const plugins = {
        AsymmetricMatcher: _AsymmetricMatcher.default,
        ConvertAnsi: _ConvertAnsi.default,
        DOMCollection: _DOMCollection.default,
        DOMElement: _DOMElement.default,
        Immutable: _Immutable.default,
        ReactElement: _ReactElement.default,
        ReactTestComponent: _ReactTestComponent.default
      };
      plugins_1 = build$1.plugins = plugins;
      var _default$2j = format;
      build$1.default = _default$2j;

      /**
       * @source {https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from#Polyfill}
       * but without thisArg (too hard to type, no need to `this`)
       */
      var toStr = Object.prototype.toString;
      function isCallable(fn) {
        return typeof fn === "function" || toStr.call(fn) === "[object Function]";
      }
      function toInteger(value) {
        var number = Number(value);
        if (isNaN(number)) {
          return 0;
        }
        if (number === 0 || !isFinite(number)) {
          return number;
        }
        return (number > 0 ? 1 : -1) * Math.floor(Math.abs(number));
      }
      var maxSafeInteger = Math.pow(2, 53) - 1;
      function toLength(value) {
        var len = toInteger(value);
        return Math.min(Math.max(len, 0), maxSafeInteger);
      }
      /**
       * Creates an array from an iterable object.
       * @param iterable An iterable object to convert to an array.
       */

      /**
       * Creates an array from an iterable object.
       * @param iterable An iterable object to convert to an array.
       * @param mapfn A mapping function to call on every element of the array.
       * @param thisArg Value of 'this' used to invoke the mapfn.
       */
      function arrayFrom(arrayLike, mapFn) {
        // 1. Let C be the this value.
        // edit(@eps1lon): we're not calling it as Array.from
        var C = Array;

        // 2. Let items be ToObject(arrayLike).
        var items = Object(arrayLike);

        // 3. ReturnIfAbrupt(items).
        if (arrayLike == null) {
          throw new TypeError("Array.from requires an array-like object - not null or undefined");
        }

        // 10. Let lenValue be Get(items, "length").
        // 11. Let len be ToLength(lenValue).
        var len = toLength(items.length);

        // 13. If IsConstructor(C) is true, then
        // 13. a. Let A be the result of calling the [[Construct]] internal method
        // of C with an argument list containing the single item len.
        // 14. a. Else, Let A be ArrayCreate(len).
        var A = isCallable(C) ? Object(new C(len)) : new Array(len);

        // 16. Let k be 0.
        var k = 0;
        // 17. Repeat, while k < len… (also steps a - h)
        var kValue;
        while (k < len) {
          kValue = items[k];
          {
            A[k] = kValue;
          }
          k += 1;
        }
        // 18. Let putStatus be Put(A, "length", len, true).
        A.length = len;
        // 20. Return A.
        return A;
      }

      function _typeof$2(obj) { "@babel/helpers - typeof"; return _typeof$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof$2(obj); }
      function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
      function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey$1(descriptor.key), descriptor); } }
      function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
      function _defineProperty$2(obj, key, value) { key = _toPropertyKey$1(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
      function _toPropertyKey$1(arg) { var key = _toPrimitive$1(arg, "string"); return _typeof$2(key) === "symbol" ? key : String(key); }
      function _toPrimitive$1(input, hint) { if (_typeof$2(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint); if (_typeof$2(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
      // for environments without Set we fallback to arrays with unique members
      var SetLike = /*#__PURE__*/function () {
        function SetLike() {
          var items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
          _classCallCheck(this, SetLike);
          _defineProperty$2(this, "items", void 0);
          this.items = items;
        }
        _createClass(SetLike, [{
          key: "add",
          value: function add(value) {
            if (this.has(value) === false) {
              this.items.push(value);
            }
            return this;
          }
        }, {
          key: "clear",
          value: function clear() {
            this.items = [];
          }
        }, {
          key: "delete",
          value: function _delete(value) {
            var previousLength = this.items.length;
            this.items = this.items.filter(function (item) {
              return item !== value;
            });
            return previousLength !== this.items.length;
          }
        }, {
          key: "forEach",
          value: function forEach(callbackfn) {
            var _this = this;
            this.items.forEach(function (item) {
              callbackfn(item, item, _this);
            });
          }
        }, {
          key: "has",
          value: function has(value) {
            return this.items.indexOf(value) !== -1;
          }
        }, {
          key: "size",
          get: function get() {
            return this.items.length;
          }
        }]);
        return SetLike;
      }();
      const SetLike$1 = typeof Set === "undefined" ? Set : SetLike;

      // https://w3c.github.io/html-aria/#document-conformance-requirements-for-use-of-aria-attributes-in-html

      /**
       * Safe Element.localName for all supported environments
       * @param element
       */
      function getLocalName(element) {
        var _element$localName;
        return (// eslint-disable-next-line no-restricted-properties -- actual guard for environments without localName
          (_element$localName = element.localName) !== null && _element$localName !== void 0 ? _element$localName :
          // eslint-disable-next-line no-restricted-properties -- required for the fallback
          element.tagName.toLowerCase()
        );
      }
      var localNameToRoleMappings = {
        article: "article",
        aside: "complementary",
        button: "button",
        datalist: "listbox",
        dd: "definition",
        details: "group",
        dialog: "dialog",
        dt: "term",
        fieldset: "group",
        figure: "figure",
        // WARNING: Only with an accessible name
        form: "form",
        footer: "contentinfo",
        h1: "heading",
        h2: "heading",
        h3: "heading",
        h4: "heading",
        h5: "heading",
        h6: "heading",
        header: "banner",
        hr: "separator",
        html: "document",
        legend: "legend",
        li: "listitem",
        math: "math",
        main: "main",
        menu: "list",
        nav: "navigation",
        ol: "list",
        optgroup: "group",
        // WARNING: Only in certain context
        option: "option",
        output: "status",
        progress: "progressbar",
        // WARNING: Only with an accessible name
        section: "region",
        summary: "button",
        table: "table",
        tbody: "rowgroup",
        textarea: "textbox",
        tfoot: "rowgroup",
        // WARNING: Only in certain context
        td: "cell",
        th: "columnheader",
        thead: "rowgroup",
        tr: "row",
        ul: "list"
      };
      var prohibitedAttributes = {
        caption: new Set(["aria-label", "aria-labelledby"]),
        code: new Set(["aria-label", "aria-labelledby"]),
        deletion: new Set(["aria-label", "aria-labelledby"]),
        emphasis: new Set(["aria-label", "aria-labelledby"]),
        generic: new Set(["aria-label", "aria-labelledby", "aria-roledescription"]),
        insertion: new Set(["aria-label", "aria-labelledby"]),
        paragraph: new Set(["aria-label", "aria-labelledby"]),
        presentation: new Set(["aria-label", "aria-labelledby"]),
        strong: new Set(["aria-label", "aria-labelledby"]),
        subscript: new Set(["aria-label", "aria-labelledby"]),
        superscript: new Set(["aria-label", "aria-labelledby"])
      };

      /**
       *
       * @param element
       * @param role The role used for this element. This is specified to control whether you want to use the implicit or explicit role.
       */
      function hasGlobalAriaAttributes(element, role) {
        // https://rawgit.com/w3c/aria/stable/#global_states
        // commented attributes are deprecated
        return ["aria-atomic", "aria-busy", "aria-controls", "aria-current", "aria-describedby", "aria-details",
        // "disabled",
        "aria-dropeffect",
        // "errormessage",
        "aria-flowto", "aria-grabbed",
        // "haspopup",
        "aria-hidden",
        // "invalid",
        "aria-keyshortcuts", "aria-label", "aria-labelledby", "aria-live", "aria-owns", "aria-relevant", "aria-roledescription"].some(function (attributeName) {
          var _prohibitedAttributes;
          return element.hasAttribute(attributeName) && !((_prohibitedAttributes = prohibitedAttributes[role]) !== null && _prohibitedAttributes !== void 0 && _prohibitedAttributes.has(attributeName));
        });
      }
      function ignorePresentationalRole(element, implicitRole) {
        // https://rawgit.com/w3c/aria/stable/#conflict_resolution_presentation_none
        return hasGlobalAriaAttributes(element, implicitRole);
      }
      function getRole(element) {
        var explicitRole = getExplicitRole(element);
        if (explicitRole === null || explicitRole === "presentation") {
          var implicitRole = getImplicitRole(element);
          if (explicitRole !== "presentation" || ignorePresentationalRole(element, implicitRole || "")) {
            return implicitRole;
          }
        }
        return explicitRole;
      }
      function getImplicitRole(element) {
        var mappedByTag = localNameToRoleMappings[getLocalName(element)];
        if (mappedByTag !== undefined) {
          return mappedByTag;
        }
        switch (getLocalName(element)) {
          case "a":
          case "area":
          case "link":
            if (element.hasAttribute("href")) {
              return "link";
            }
            break;
          case "img":
            if (element.getAttribute("alt") === "" && !ignorePresentationalRole(element, "img")) {
              return "presentation";
            }
            return "img";
          case "input":
            {
              var _ref = element,
                type = _ref.type;
              switch (type) {
                case "button":
                case "image":
                case "reset":
                case "submit":
                  return "button";
                case "checkbox":
                case "radio":
                  return type;
                case "range":
                  return "slider";
                case "email":
                case "tel":
                case "text":
                case "url":
                  if (element.hasAttribute("list")) {
                    return "combobox";
                  }
                  return "textbox";
                case "search":
                  if (element.hasAttribute("list")) {
                    return "combobox";
                  }
                  return "searchbox";
                case "number":
                  return "spinbutton";
                default:
                  return null;
              }
            }
          case "select":
            if (element.hasAttribute("multiple") || element.size > 1) {
              return "listbox";
            }
            return "combobox";
        }
        return null;
      }
      function getExplicitRole(element) {
        var role = element.getAttribute("role");
        if (role !== null) {
          var explicitRole = role.trim().split(" ")[0];
          // String.prototype.split(sep, limit) will always return an array with at least one member
          // as long as limit is either undefined or > 0
          if (explicitRole.length > 0) {
            return explicitRole;
          }
        }
        return null;
      }

      function isElement$1(node) {
        return node !== null && node.nodeType === node.ELEMENT_NODE;
      }
      function isHTMLTableCaptionElement(node) {
        return isElement$1(node) && getLocalName(node) === "caption";
      }
      function isHTMLInputElement(node) {
        return isElement$1(node) && getLocalName(node) === "input";
      }
      function isHTMLOptGroupElement(node) {
        return isElement$1(node) && getLocalName(node) === "optgroup";
      }
      function isHTMLSelectElement(node) {
        return isElement$1(node) && getLocalName(node) === "select";
      }
      function isHTMLTableElement(node) {
        return isElement$1(node) && getLocalName(node) === "table";
      }
      function isHTMLTextAreaElement(node) {
        return isElement$1(node) && getLocalName(node) === "textarea";
      }
      function safeWindow(node) {
        var _ref = node.ownerDocument === null ? node : node.ownerDocument,
          defaultView = _ref.defaultView;
        if (defaultView === null) {
          throw new TypeError("no window available");
        }
        return defaultView;
      }
      function isHTMLFieldSetElement(node) {
        return isElement$1(node) && getLocalName(node) === "fieldset";
      }
      function isHTMLLegendElement(node) {
        return isElement$1(node) && getLocalName(node) === "legend";
      }
      function isHTMLSlotElement(node) {
        return isElement$1(node) && getLocalName(node) === "slot";
      }
      function isSVGElement(node) {
        return isElement$1(node) && node.ownerSVGElement !== undefined;
      }
      function isSVGSVGElement(node) {
        return isElement$1(node) && getLocalName(node) === "svg";
      }
      function isSVGTitleElement(node) {
        return isSVGElement(node) && getLocalName(node) === "title";
      }

      /**
       *
       * @param {Node} node -
       * @param {string} attributeName -
       * @returns {Element[]} -
       */
      function queryIdRefs(node, attributeName) {
        if (isElement$1(node) && node.hasAttribute(attributeName)) {
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- safe due to hasAttribute check
          var ids = node.getAttribute(attributeName).split(" ");

          // Browsers that don't support shadow DOM won't have getRootNode
          var root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
          return ids.map(function (id) {
            return root.getElementById(id);
          }).filter(function (element) {
            return element !== null;
          }
          // TODO: why does this not narrow?
          );
        }

        return [];
      }
      function hasAnyConcreteRoles(node, roles) {
        if (isElement$1(node)) {
          return roles.indexOf(getRole(node)) !== -1;
        }
        return false;
      }

      /**
       * implements https://w3c.github.io/accname/
       */

      /**
       *  A string of characters where all carriage returns, newlines, tabs, and form-feeds are replaced with a single space, and multiple spaces are reduced to a single space. The string contains only character data; it does not contain any markup.
       */

      /**
       *
       * @param {string} string -
       * @returns {FlatString} -
       */
      function asFlatString(s) {
        return s.trim().replace(/\s\s+/g, " ");
      }

      /**
       *
       * @param node -
       * @param options - These are not optional to prevent accidentally calling it without options in `computeAccessibleName`
       * @returns {boolean} -
       */
      function isHidden(node, getComputedStyleImplementation) {
        if (!isElement$1(node)) {
          return false;
        }
        if (node.hasAttribute("hidden") || node.getAttribute("aria-hidden") === "true") {
          return true;
        }
        var style = getComputedStyleImplementation(node);
        return style.getPropertyValue("display") === "none" || style.getPropertyValue("visibility") === "hidden";
      }

      /**
       * @param {Node} node -
       * @returns {boolean} - As defined in step 2E of https://w3c.github.io/accname/#mapping_additional_nd_te
       */
      function isControl(node) {
        return hasAnyConcreteRoles(node, ["button", "combobox", "listbox", "textbox"]) || hasAbstractRole(node, "range");
      }
      function hasAbstractRole(node, role) {
        if (!isElement$1(node)) {
          return false;
        }
        switch (role) {
          case "range":
            return hasAnyConcreteRoles(node, ["meter", "progressbar", "scrollbar", "slider", "spinbutton"]);
          default:
            throw new TypeError("No knowledge about abstract role '".concat(role, "'. This is likely a bug :("));
        }
      }

      /**
       * element.querySelectorAll but also considers owned tree
       * @param element
       * @param selectors
       */
      function querySelectorAllSubtree(element, selectors) {
        var elements = arrayFrom(element.querySelectorAll(selectors));
        queryIdRefs(element, "aria-owns").forEach(function (root) {
          // babel transpiles this assuming an iterator
          elements.push.apply(elements, arrayFrom(root.querySelectorAll(selectors)));
        });
        return elements;
      }
      function querySelectedOptions(listbox) {
        if (isHTMLSelectElement(listbox)) {
          // IE11 polyfill
          return listbox.selectedOptions || querySelectorAllSubtree(listbox, "[selected]");
        }
        return querySelectorAllSubtree(listbox, '[aria-selected="true"]');
      }
      function isMarkedPresentational(node) {
        return hasAnyConcreteRoles(node, ["none", "presentation"]);
      }

      /**
       * Elements specifically listed in html-aam
       *
       * We don't need this for `label` or `legend` elements.
       * Their implicit roles already allow "naming from content".
       *
       * sources:
       *
       * - https://w3c.github.io/html-aam/#table-element
       */
      function isNativeHostLanguageTextAlternativeElement(node) {
        return isHTMLTableCaptionElement(node);
      }

      /**
       * https://w3c.github.io/aria/#namefromcontent
       */
      function allowsNameFromContent(node) {
        return hasAnyConcreteRoles(node, ["button", "cell", "checkbox", "columnheader", "gridcell", "heading", "label", "legend", "link", "menuitem", "menuitemcheckbox", "menuitemradio", "option", "radio", "row", "rowheader", "switch", "tab", "tooltip", "treeitem"]);
      }

      /**
       * TODO https://github.com/eps1lon/dom-accessibility-api/issues/100
       */
      function isDescendantOfNativeHostLanguageTextAlternativeElement(
      // eslint-disable-next-line @typescript-eslint/no-unused-vars -- not implemented yet
      node) {
        return false;
      }
      function getValueOfTextbox(element) {
        if (isHTMLInputElement(element) || isHTMLTextAreaElement(element)) {
          return element.value;
        }
        // https://github.com/eps1lon/dom-accessibility-api/issues/4
        return element.textContent || "";
      }
      function getTextualContent(declaration) {
        var content = declaration.getPropertyValue("content");
        if (/^["'].*["']$/.test(content)) {
          return content.slice(1, -1);
        }
        return "";
      }

      /**
       * https://html.spec.whatwg.org/multipage/forms.html#category-label
       * TODO: form-associated custom elements
       * @param element
       */
      function isLabelableElement(element) {
        var localName = getLocalName(element);
        return localName === "button" || localName === "input" && element.getAttribute("type") !== "hidden" || localName === "meter" || localName === "output" || localName === "progress" || localName === "select" || localName === "textarea";
      }

      /**
       * > [...], then the first such descendant in tree order is the label element's labeled control.
       * -- https://html.spec.whatwg.org/multipage/forms.html#labeled-control
       * @param element
       */
      function findLabelableElement(element) {
        if (isLabelableElement(element)) {
          return element;
        }
        var labelableElement = null;
        element.childNodes.forEach(function (childNode) {
          if (labelableElement === null && isElement$1(childNode)) {
            var descendantLabelableElement = findLabelableElement(childNode);
            if (descendantLabelableElement !== null) {
              labelableElement = descendantLabelableElement;
            }
          }
        });
        return labelableElement;
      }

      /**
       * Polyfill of HTMLLabelElement.control
       * https://html.spec.whatwg.org/multipage/forms.html#labeled-control
       * @param label
       */
      function getControlOfLabel(label) {
        if (label.control !== undefined) {
          return label.control;
        }
        var htmlFor = label.getAttribute("for");
        if (htmlFor !== null) {
          return label.ownerDocument.getElementById(htmlFor);
        }
        return findLabelableElement(label);
      }

      /**
       * Polyfill of HTMLInputElement.labels
       * https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement/labels
       * @param element
       */
      function getLabels$1(element) {
        var labelsProperty = element.labels;
        if (labelsProperty === null) {
          return labelsProperty;
        }
        if (labelsProperty !== undefined) {
          return arrayFrom(labelsProperty);
        }

        // polyfill
        if (!isLabelableElement(element)) {
          return null;
        }
        var document = element.ownerDocument;
        return arrayFrom(document.querySelectorAll("label")).filter(function (label) {
          return getControlOfLabel(label) === element;
        });
      }

      /**
       * Gets the contents of a slot used for computing the accname
       * @param slot
       */
      function getSlotContents(slot) {
        // Computing the accessible name for elements containing slots is not
        // currently defined in the spec. This implementation reflects the
        // behavior of NVDA 2020.2/Firefox 81 and iOS VoiceOver/Safari 13.6.
        var assignedNodes = slot.assignedNodes();
        if (assignedNodes.length === 0) {
          // if no nodes are assigned to the slot, it displays the default content
          return arrayFrom(slot.childNodes);
        }
        return assignedNodes;
      }

      /**
       * implements https://w3c.github.io/accname/#mapping_additional_nd_te
       * @param root
       * @param options
       * @returns
       */
      function computeTextAlternative(root) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var consultedNodes = new SetLike$1();
        var window = safeWindow(root);
        var _options$compute = options.compute,
          compute = _options$compute === void 0 ? "name" : _options$compute,
          _options$computedStyl = options.computedStyleSupportsPseudoElements,
          computedStyleSupportsPseudoElements = _options$computedStyl === void 0 ? options.getComputedStyle !== undefined : _options$computedStyl,
          _options$getComputedS = options.getComputedStyle,
          getComputedStyle = _options$getComputedS === void 0 ? window.getComputedStyle.bind(window) : _options$getComputedS,
          _options$hidden = options.hidden,
          hidden = _options$hidden === void 0 ? false : _options$hidden;

        // 2F.i
        function computeMiscTextAlternative(node, context) {
          var accumulatedText = "";
          if (isElement$1(node) && computedStyleSupportsPseudoElements) {
            var pseudoBefore = getComputedStyle(node, "::before");
            var beforeContent = getTextualContent(pseudoBefore);
            accumulatedText = "".concat(beforeContent, " ").concat(accumulatedText);
          }

          // FIXME: Including aria-owns is not defined in the spec
          // But it is required in the web-platform-test
          var childNodes = isHTMLSlotElement(node) ? getSlotContents(node) : arrayFrom(node.childNodes).concat(queryIdRefs(node, "aria-owns"));
          childNodes.forEach(function (child) {
            var result = computeTextAlternative(child, {
              isEmbeddedInLabel: context.isEmbeddedInLabel,
              isReferenced: false,
              recursion: true
            });
            // TODO: Unclear why display affects delimiter
            // see https://github.com/w3c/accname/issues/3
            var display = isElement$1(child) ? getComputedStyle(child).getPropertyValue("display") : "inline";
            var separator = display !== "inline" ? " " : "";
            // trailing separator for wpt tests
            accumulatedText += "".concat(separator).concat(result).concat(separator);
          });
          if (isElement$1(node) && computedStyleSupportsPseudoElements) {
            var pseudoAfter = getComputedStyle(node, "::after");
            var afterContent = getTextualContent(pseudoAfter);
            accumulatedText = "".concat(accumulatedText, " ").concat(afterContent);
          }
          return accumulatedText.trim();
        }

        /**
         *
         * @param element
         * @param attributeName
         * @returns A string non-empty string or `null`
         */
        function useAttribute(element, attributeName) {
          var attribute = element.getAttributeNode(attributeName);
          if (attribute !== null && !consultedNodes.has(attribute) && attribute.value.trim() !== "") {
            consultedNodes.add(attribute);
            return attribute.value;
          }
          return null;
        }
        function computeTooltipAttributeValue(node) {
          if (!isElement$1(node)) {
            return null;
          }
          return useAttribute(node, "title");
        }
        function computeElementTextAlternative(node) {
          if (!isElement$1(node)) {
            return null;
          }

          // https://w3c.github.io/html-aam/#fieldset-and-legend-elements
          if (isHTMLFieldSetElement(node)) {
            consultedNodes.add(node);
            var children = arrayFrom(node.childNodes);
            for (var i = 0; i < children.length; i += 1) {
              var child = children[i];
              if (isHTMLLegendElement(child)) {
                return computeTextAlternative(child, {
                  isEmbeddedInLabel: false,
                  isReferenced: false,
                  recursion: false
                });
              }
            }
          } else if (isHTMLTableElement(node)) {
            // https://w3c.github.io/html-aam/#table-element
            consultedNodes.add(node);
            var _children = arrayFrom(node.childNodes);
            for (var _i = 0; _i < _children.length; _i += 1) {
              var _child = _children[_i];
              if (isHTMLTableCaptionElement(_child)) {
                return computeTextAlternative(_child, {
                  isEmbeddedInLabel: false,
                  isReferenced: false,
                  recursion: false
                });
              }
            }
          } else if (isSVGSVGElement(node)) {
            // https://www.w3.org/TR/svg-aam-1.0/
            consultedNodes.add(node);
            var _children2 = arrayFrom(node.childNodes);
            for (var _i2 = 0; _i2 < _children2.length; _i2 += 1) {
              var _child2 = _children2[_i2];
              if (isSVGTitleElement(_child2)) {
                return _child2.textContent;
              }
            }
            return null;
          } else if (getLocalName(node) === "img" || getLocalName(node) === "area") {
            // https://w3c.github.io/html-aam/#area-element
            // https://w3c.github.io/html-aam/#img-element
            var nameFromAlt = useAttribute(node, "alt");
            if (nameFromAlt !== null) {
              return nameFromAlt;
            }
          } else if (isHTMLOptGroupElement(node)) {
            var nameFromLabel = useAttribute(node, "label");
            if (nameFromLabel !== null) {
              return nameFromLabel;
            }
          }
          if (isHTMLInputElement(node) && (node.type === "button" || node.type === "submit" || node.type === "reset")) {
            // https://w3c.github.io/html-aam/#input-type-text-input-type-password-input-type-search-input-type-tel-input-type-email-input-type-url-and-textarea-element-accessible-description-computation
            var nameFromValue = useAttribute(node, "value");
            if (nameFromValue !== null) {
              return nameFromValue;
            }

            // TODO: l10n
            if (node.type === "submit") {
              return "Submit";
            }
            // TODO: l10n
            if (node.type === "reset") {
              return "Reset";
            }
          }
          var labels = getLabels$1(node);
          if (labels !== null && labels.length !== 0) {
            consultedNodes.add(node);
            return arrayFrom(labels).map(function (element) {
              return computeTextAlternative(element, {
                isEmbeddedInLabel: true,
                isReferenced: false,
                recursion: true
              });
            }).filter(function (label) {
              return label.length > 0;
            }).join(" ");
          }

          // https://w3c.github.io/html-aam/#input-type-image-accessible-name-computation
          // TODO: wpt test consider label elements but html-aam does not mention them
          // We follow existing implementations over spec
          if (isHTMLInputElement(node) && node.type === "image") {
            var _nameFromAlt = useAttribute(node, "alt");
            if (_nameFromAlt !== null) {
              return _nameFromAlt;
            }
            var nameFromTitle = useAttribute(node, "title");
            if (nameFromTitle !== null) {
              return nameFromTitle;
            }

            // TODO: l10n
            return "Submit Query";
          }
          if (hasAnyConcreteRoles(node, ["button"])) {
            // https://www.w3.org/TR/html-aam-1.0/#button-element
            var nameFromSubTree = computeMiscTextAlternative(node, {
              isEmbeddedInLabel: false});
            if (nameFromSubTree !== "") {
              return nameFromSubTree;
            }
          }
          return null;
        }
        function computeTextAlternative(current, context) {
          if (consultedNodes.has(current)) {
            return "";
          }

          // 2A
          if (!hidden && isHidden(current, getComputedStyle) && !context.isReferenced) {
            consultedNodes.add(current);
            return "";
          }

          // 2B
          var labelAttributeNode = isElement$1(current) ? current.getAttributeNode("aria-labelledby") : null;
          // TODO: Do we generally need to block query IdRefs of attributes we have already consulted?
          var labelElements = labelAttributeNode !== null && !consultedNodes.has(labelAttributeNode) ? queryIdRefs(current, "aria-labelledby") : [];
          if (compute === "name" && !context.isReferenced && labelElements.length > 0) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- Can't be null here otherwise labelElements would be empty
            consultedNodes.add(labelAttributeNode);
            return labelElements.map(function (element) {
              // TODO: Chrome will consider repeated values i.e. use a node multiple times while we'll bail out in computeTextAlternative.
              return computeTextAlternative(element, {
                isEmbeddedInLabel: context.isEmbeddedInLabel,
                isReferenced: true,
                // this isn't recursion as specified, otherwise we would skip
                // `aria-label` in
                // <input id="myself" aria-label="foo" aria-labelledby="myself"
                recursion: false
              });
            }).join(" ");
          }

          // 2C
          // Changed from the spec in anticipation of https://github.com/w3c/accname/issues/64
          // spec says we should only consider skipping if we have a non-empty label
          var skipToStep2E = context.recursion && isControl(current) && compute === "name";
          if (!skipToStep2E) {
            var ariaLabel = (isElement$1(current) && current.getAttribute("aria-label") || "").trim();
            if (ariaLabel !== "" && compute === "name") {
              consultedNodes.add(current);
              return ariaLabel;
            }

            // 2D
            if (!isMarkedPresentational(current)) {
              var elementTextAlternative = computeElementTextAlternative(current);
              if (elementTextAlternative !== null) {
                consultedNodes.add(current);
                return elementTextAlternative;
              }
            }
          }

          // special casing, cheating to make tests pass
          // https://github.com/w3c/accname/issues/67
          if (hasAnyConcreteRoles(current, ["menu"])) {
            consultedNodes.add(current);
            return "";
          }

          // 2E
          if (skipToStep2E || context.isEmbeddedInLabel || context.isReferenced) {
            if (hasAnyConcreteRoles(current, ["combobox", "listbox"])) {
              consultedNodes.add(current);
              var selectedOptions = querySelectedOptions(current);
              if (selectedOptions.length === 0) {
                // defined per test `name_heading_combobox`
                return isHTMLInputElement(current) ? current.value : "";
              }
              return arrayFrom(selectedOptions).map(function (selectedOption) {
                return computeTextAlternative(selectedOption, {
                  isEmbeddedInLabel: context.isEmbeddedInLabel,
                  isReferenced: false,
                  recursion: true
                });
              }).join(" ");
            }
            if (hasAbstractRole(current, "range")) {
              consultedNodes.add(current);
              if (current.hasAttribute("aria-valuetext")) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- safe due to hasAttribute guard
                return current.getAttribute("aria-valuetext");
              }
              if (current.hasAttribute("aria-valuenow")) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- safe due to hasAttribute guard
                return current.getAttribute("aria-valuenow");
              }
              // Otherwise, use the value as specified by a host language attribute.
              return current.getAttribute("value") || "";
            }
            if (hasAnyConcreteRoles(current, ["textbox"])) {
              consultedNodes.add(current);
              return getValueOfTextbox(current);
            }
          }

          // 2F: https://w3c.github.io/accname/#step2F
          if (allowsNameFromContent(current) || isElement$1(current) && context.isReferenced || isNativeHostLanguageTextAlternativeElement(current) || isDescendantOfNativeHostLanguageTextAlternativeElement()) {
            var accumulatedText2F = computeMiscTextAlternative(current, {
              isEmbeddedInLabel: context.isEmbeddedInLabel});
            if (accumulatedText2F !== "") {
              consultedNodes.add(current);
              return accumulatedText2F;
            }
          }
          if (current.nodeType === current.TEXT_NODE) {
            consultedNodes.add(current);
            return current.textContent || "";
          }
          if (context.recursion) {
            consultedNodes.add(current);
            return computeMiscTextAlternative(current, {
              isEmbeddedInLabel: context.isEmbeddedInLabel});
          }
          var tooltipAttributeValue = computeTooltipAttributeValue(current);
          if (tooltipAttributeValue !== null) {
            consultedNodes.add(current);
            return tooltipAttributeValue;
          }

          // TODO should this be reachable?
          consultedNodes.add(current);
          return "";
        }
        return asFlatString(computeTextAlternative(root, {
          isEmbeddedInLabel: false,
          // by spec computeAccessibleDescription starts with the referenced elements as roots
          isReferenced: compute === "description",
          recursion: false
        }));
      }

      function _typeof$1(obj) { "@babel/helpers - typeof"; return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof$1(obj); }
      function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
      function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
      function _defineProperty$1(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
      function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof$1(key) === "symbol" ? key : String(key); }
      function _toPrimitive(input, hint) { if (_typeof$1(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint); if (_typeof$1(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }

      /**
       * @param root
       * @param options
       * @returns
       */
      function computeAccessibleDescription(root) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var description = queryIdRefs(root, "aria-describedby").map(function (element) {
          return computeTextAlternative(element, _objectSpread(_objectSpread({}, options), {}, {
            compute: "description"
          }));
        }).join(" ");

        // TODO: Technically we need to make sure that node wasn't used for the accessible name
        //       This causes `description_1.0_combobox-focusable-manual` to fail
        //
        // https://www.w3.org/TR/html-aam-1.0/#accessible-name-and-description-computation
        // says for so many elements to use the `title` that we assume all elements are considered
        if (description === "") {
          var title = root.getAttribute("title");
          description = title === null ? "" : title;
        }
        return description;
      }

      /**
       * https://w3c.github.io/aria/#namefromprohibited
       */
      function prohibitsNaming(node) {
        return hasAnyConcreteRoles(node, ["caption", "code", "deletion", "emphasis", "generic", "insertion", "paragraph", "presentation", "strong", "subscript", "superscript"]);
      }

      /**
       * implements https://w3c.github.io/accname/#mapping_additional_nd_name
       * @param root
       * @param options
       * @returns
       */
      function computeAccessibleName(root) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        if (prohibitsNaming(root)) {
          return "";
        }
        return computeTextAlternative(root, options);
      }

      var lib = {};

      var ariaPropsMap$1 = {};

      var iterationDecorator$1 = {};

      var iteratorProxy$1 = {};

      Object.defineProperty(iteratorProxy$1, "__esModule", {
        value: true
      });
      iteratorProxy$1.default = void 0;

      // eslint-disable-next-line no-unused-vars
      function iteratorProxy() {
        var values = this;
        var index = 0;
        var iter = {
          '@@iterator': function iterator() {
            return iter;
          },
          next: function next() {
            if (index < values.length) {
              var value = values[index];
              index = index + 1;
              return {
                done: false,
                value: value
              };
            } else {
              return {
                done: true
              };
            }
          }
        };
        return iter;
      }
      var _default$2i = iteratorProxy;
      iteratorProxy$1.default = _default$2i;

      Object.defineProperty(iterationDecorator$1, "__esModule", {
        value: true
      });
      iterationDecorator$1.default = iterationDecorator;
      var _iteratorProxy = _interopRequireDefault$a(iteratorProxy$1);
      function _interopRequireDefault$a(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
      function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
      function iterationDecorator(collection, entries) {
        if (typeof Symbol === 'function' && _typeof(Symbol.iterator) === 'symbol') {
          Object.defineProperty(collection, Symbol.iterator, {
            value: _iteratorProxy.default.bind(entries)
          });
        }
        return collection;
      }

      Object.defineProperty(ariaPropsMap$1, "__esModule", {
        value: true
      });
      ariaPropsMap$1.default = void 0;
      var _iterationDecorator$4 = _interopRequireDefault$9(iterationDecorator$1);
      function _interopRequireDefault$9(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
      function _slicedToArray$4(arr, i) { return _arrayWithHoles$4(arr) || _iterableToArrayLimit$4(arr, i) || _unsupportedIterableToArray$4(arr, i) || _nonIterableRest$4(); }
      function _nonIterableRest$4() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
      function _iterableToArrayLimit$4(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }
      function _arrayWithHoles$4(arr) { if (Array.isArray(arr)) return arr; }
      function _createForOfIteratorHelper$4(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$4(o)) || allowArrayLike) { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
      function _unsupportedIterableToArray$4(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$4(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$4(o, minLen); }
      function _arrayLikeToArray$4(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
      var properties = [['aria-activedescendant', {
        'type': 'id'
      }], ['aria-atomic', {
        'type': 'boolean'
      }], ['aria-autocomplete', {
        'type': 'token',
        'values': ['inline', 'list', 'both', 'none']
      }], ['aria-braillelabel', {
        'type': 'string'
      }], ['aria-brailleroledescription', {
        'type': 'string'
      }], ['aria-busy', {
        'type': 'boolean'
      }], ['aria-checked', {
        'type': 'tristate'
      }], ['aria-colcount', {
        type: 'integer'
      }], ['aria-colindex', {
        type: 'integer'
      }], ['aria-colspan', {
        type: 'integer'
      }], ['aria-controls', {
        'type': 'idlist'
      }], ['aria-current', {
        type: 'token',
        values: ['page', 'step', 'location', 'date', 'time', true, false]
      }], ['aria-describedby', {
        'type': 'idlist'
      }], ['aria-description', {
        'type': 'string'
      }], ['aria-details', {
        'type': 'id'
      }], ['aria-disabled', {
        'type': 'boolean'
      }], ['aria-dropeffect', {
        'type': 'tokenlist',
        'values': ['copy', 'execute', 'link', 'move', 'none', 'popup']
      }], ['aria-errormessage', {
        'type': 'id'
      }], ['aria-expanded', {
        'type': 'boolean',
        'allowundefined': true
      }], ['aria-flowto', {
        'type': 'idlist'
      }], ['aria-grabbed', {
        'type': 'boolean',
        'allowundefined': true
      }], ['aria-haspopup', {
        'type': 'token',
        'values': [false, true, 'menu', 'listbox', 'tree', 'grid', 'dialog']
      }], ['aria-hidden', {
        'type': 'boolean',
        'allowundefined': true
      }], ['aria-invalid', {
        'type': 'token',
        'values': ['grammar', false, 'spelling', true]
      }], ['aria-keyshortcuts', {
        type: 'string'
      }], ['aria-label', {
        'type': 'string'
      }], ['aria-labelledby', {
        'type': 'idlist'
      }], ['aria-level', {
        'type': 'integer'
      }], ['aria-live', {
        'type': 'token',
        'values': ['assertive', 'off', 'polite']
      }], ['aria-modal', {
        type: 'boolean'
      }], ['aria-multiline', {
        'type': 'boolean'
      }], ['aria-multiselectable', {
        'type': 'boolean'
      }], ['aria-orientation', {
        'type': 'token',
        'values': ['vertical', 'undefined', 'horizontal']
      }], ['aria-owns', {
        'type': 'idlist'
      }], ['aria-placeholder', {
        type: 'string'
      }], ['aria-posinset', {
        'type': 'integer'
      }], ['aria-pressed', {
        'type': 'tristate'
      }], ['aria-readonly', {
        'type': 'boolean'
      }], ['aria-relevant', {
        'type': 'tokenlist',
        'values': ['additions', 'all', 'removals', 'text']
      }], ['aria-required', {
        'type': 'boolean'
      }], ['aria-roledescription', {
        type: 'string'
      }], ['aria-rowcount', {
        type: 'integer'
      }], ['aria-rowindex', {
        type: 'integer'
      }], ['aria-rowspan', {
        type: 'integer'
      }], ['aria-selected', {
        'type': 'boolean',
        'allowundefined': true
      }], ['aria-setsize', {
        'type': 'integer'
      }], ['aria-sort', {
        'type': 'token',
        'values': ['ascending', 'descending', 'none', 'other']
      }], ['aria-valuemax', {
        'type': 'number'
      }], ['aria-valuemin', {
        'type': 'number'
      }], ['aria-valuenow', {
        'type': 'number'
      }], ['aria-valuetext', {
        'type': 'string'
      }]];
      var ariaPropsMap = {
        entries: function entries() {
          return properties;
        },
        forEach: function forEach(fn) {
          var thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          var _iterator = _createForOfIteratorHelper$4(properties),
            _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var _step$value = _slicedToArray$4(_step.value, 2),
                key = _step$value[0],
                values = _step$value[1];
              fn.call(thisArg, values, key, properties);
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        },
        get: function get(key) {
          var item = properties.find(function (tuple) {
            return tuple[0] === key ? true : false;
          });
          return item && item[1];
        },
        has: function has(key) {
          return !!ariaPropsMap.get(key);
        },
        keys: function keys() {
          return properties.map(function (_ref) {
            var _ref2 = _slicedToArray$4(_ref, 1),
              key = _ref2[0];
            return key;
          });
        },
        values: function values() {
          return properties.map(function (_ref3) {
            var _ref4 = _slicedToArray$4(_ref3, 2),
              values = _ref4[1];
            return values;
          });
        }
      };
      var _default$2h = (0, _iterationDecorator$4.default)(ariaPropsMap, ariaPropsMap.entries());
      ariaPropsMap$1.default = _default$2h;

      var domMap$1 = {};

      Object.defineProperty(domMap$1, "__esModule", {
        value: true
      });
      domMap$1.default = void 0;
      var _iterationDecorator$3 = _interopRequireDefault$8(iterationDecorator$1);
      function _interopRequireDefault$8(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
      function _slicedToArray$3(arr, i) { return _arrayWithHoles$3(arr) || _iterableToArrayLimit$3(arr, i) || _unsupportedIterableToArray$3(arr, i) || _nonIterableRest$3(); }
      function _nonIterableRest$3() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
      function _iterableToArrayLimit$3(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }
      function _arrayWithHoles$3(arr) { if (Array.isArray(arr)) return arr; }
      function _createForOfIteratorHelper$3(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$3(o)) || allowArrayLike) { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
      function _unsupportedIterableToArray$3(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$3(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$3(o, minLen); }
      function _arrayLikeToArray$3(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
      var dom$1 = [['a', {
        reserved: false
      }], ['abbr', {
        reserved: false
      }], ['acronym', {
        reserved: false
      }], ['address', {
        reserved: false
      }], ['applet', {
        reserved: false
      }], ['area', {
        reserved: false
      }], ['article', {
        reserved: false
      }], ['aside', {
        reserved: false
      }], ['audio', {
        reserved: false
      }], ['b', {
        reserved: false
      }], ['base', {
        reserved: true
      }], ['bdi', {
        reserved: false
      }], ['bdo', {
        reserved: false
      }], ['big', {
        reserved: false
      }], ['blink', {
        reserved: false
      }], ['blockquote', {
        reserved: false
      }], ['body', {
        reserved: false
      }], ['br', {
        reserved: false
      }], ['button', {
        reserved: false
      }], ['canvas', {
        reserved: false
      }], ['caption', {
        reserved: false
      }], ['center', {
        reserved: false
      }], ['cite', {
        reserved: false
      }], ['code', {
        reserved: false
      }], ['col', {
        reserved: true
      }], ['colgroup', {
        reserved: true
      }], ['content', {
        reserved: false
      }], ['data', {
        reserved: false
      }], ['datalist', {
        reserved: false
      }], ['dd', {
        reserved: false
      }], ['del', {
        reserved: false
      }], ['details', {
        reserved: false
      }], ['dfn', {
        reserved: false
      }], ['dialog', {
        reserved: false
      }], ['dir', {
        reserved: false
      }], ['div', {
        reserved: false
      }], ['dl', {
        reserved: false
      }], ['dt', {
        reserved: false
      }], ['em', {
        reserved: false
      }], ['embed', {
        reserved: false
      }], ['fieldset', {
        reserved: false
      }], ['figcaption', {
        reserved: false
      }], ['figure', {
        reserved: false
      }], ['font', {
        reserved: false
      }], ['footer', {
        reserved: false
      }], ['form', {
        reserved: false
      }], ['frame', {
        reserved: false
      }], ['frameset', {
        reserved: false
      }], ['h1', {
        reserved: false
      }], ['h2', {
        reserved: false
      }], ['h3', {
        reserved: false
      }], ['h4', {
        reserved: false
      }], ['h5', {
        reserved: false
      }], ['h6', {
        reserved: false
      }], ['head', {
        reserved: true
      }], ['header', {
        reserved: false
      }], ['hgroup', {
        reserved: false
      }], ['hr', {
        reserved: false
      }], ['html', {
        reserved: true
      }], ['i', {
        reserved: false
      }], ['iframe', {
        reserved: false
      }], ['img', {
        reserved: false
      }], ['input', {
        reserved: false
      }], ['ins', {
        reserved: false
      }], ['kbd', {
        reserved: false
      }], ['keygen', {
        reserved: false
      }], ['label', {
        reserved: false
      }], ['legend', {
        reserved: false
      }], ['li', {
        reserved: false
      }], ['link', {
        reserved: true
      }], ['main', {
        reserved: false
      }], ['map', {
        reserved: false
      }], ['mark', {
        reserved: false
      }], ['marquee', {
        reserved: false
      }], ['menu', {
        reserved: false
      }], ['menuitem', {
        reserved: false
      }], ['meta', {
        reserved: true
      }], ['meter', {
        reserved: false
      }], ['nav', {
        reserved: false
      }], ['noembed', {
        reserved: true
      }], ['noscript', {
        reserved: true
      }], ['object', {
        reserved: false
      }], ['ol', {
        reserved: false
      }], ['optgroup', {
        reserved: false
      }], ['option', {
        reserved: false
      }], ['output', {
        reserved: false
      }], ['p', {
        reserved: false
      }], ['param', {
        reserved: true
      }], ['picture', {
        reserved: true
      }], ['pre', {
        reserved: false
      }], ['progress', {
        reserved: false
      }], ['q', {
        reserved: false
      }], ['rp', {
        reserved: false
      }], ['rt', {
        reserved: false
      }], ['rtc', {
        reserved: false
      }], ['ruby', {
        reserved: false
      }], ['s', {
        reserved: false
      }], ['samp', {
        reserved: false
      }], ['script', {
        reserved: true
      }], ['section', {
        reserved: false
      }], ['select', {
        reserved: false
      }], ['small', {
        reserved: false
      }], ['source', {
        reserved: true
      }], ['spacer', {
        reserved: false
      }], ['span', {
        reserved: false
      }], ['strike', {
        reserved: false
      }], ['strong', {
        reserved: false
      }], ['style', {
        reserved: true
      }], ['sub', {
        reserved: false
      }], ['summary', {
        reserved: false
      }], ['sup', {
        reserved: false
      }], ['table', {
        reserved: false
      }], ['tbody', {
        reserved: false
      }], ['td', {
        reserved: false
      }], ['textarea', {
        reserved: false
      }], ['tfoot', {
        reserved: false
      }], ['th', {
        reserved: false
      }], ['thead', {
        reserved: false
      }], ['time', {
        reserved: false
      }], ['title', {
        reserved: true
      }], ['tr', {
        reserved: false
      }], ['track', {
        reserved: true
      }], ['tt', {
        reserved: false
      }], ['u', {
        reserved: false
      }], ['ul', {
        reserved: false
      }], ['var', {
        reserved: false
      }], ['video', {
        reserved: false
      }], ['wbr', {
        reserved: false
      }], ['xmp', {
        reserved: false
      }]];
      var domMap = {
        entries: function entries() {
          return dom$1;
        },
        forEach: function forEach(fn) {
          var thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          var _iterator = _createForOfIteratorHelper$3(dom$1),
            _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var _step$value = _slicedToArray$3(_step.value, 2),
                key = _step$value[0],
                values = _step$value[1];
              fn.call(thisArg, values, key, dom$1);
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        },
        get: function get(key) {
          var item = dom$1.find(function (tuple) {
            return tuple[0] === key ? true : false;
          });
          return item && item[1];
        },
        has: function has(key) {
          return !!domMap.get(key);
        },
        keys: function keys() {
          return dom$1.map(function (_ref) {
            var _ref2 = _slicedToArray$3(_ref, 1),
              key = _ref2[0];
            return key;
          });
        },
        values: function values() {
          return dom$1.map(function (_ref3) {
            var _ref4 = _slicedToArray$3(_ref3, 2),
              values = _ref4[1];
            return values;
          });
        }
      };
      var _default$2g = (0, _iterationDecorator$3.default)(domMap, domMap.entries());
      domMap$1.default = _default$2g;

      var rolesMap$1 = {};

      var ariaAbstractRoles$1 = {};

      var commandRole$1 = {};

      Object.defineProperty(commandRole$1, "__esModule", {
        value: true
      });
      commandRole$1.default = void 0;
      var commandRole = {
        abstract: true,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'widget']]
      };
      var _default$2f = commandRole;
      commandRole$1.default = _default$2f;

      var compositeRole$1 = {};

      Object.defineProperty(compositeRole$1, "__esModule", {
        value: true
      });
      compositeRole$1.default = void 0;
      var compositeRole = {
        abstract: true,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-activedescendant': null,
          'aria-disabled': null
        },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'widget']]
      };
      var _default$2e = compositeRole;
      compositeRole$1.default = _default$2e;

      var inputRole$1 = {};

      Object.defineProperty(inputRole$1, "__esModule", {
        value: true
      });
      inputRole$1.default = void 0;
      var inputRole = {
        abstract: true,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null
        },
        relatedConcepts: [{
          concept: {
            name: 'input'
          },
          module: 'XForms'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'widget']]
      };
      var _default$2d = inputRole;
      inputRole$1.default = _default$2d;

      var landmarkRole$1 = {};

      Object.defineProperty(landmarkRole$1, "__esModule", {
        value: true
      });
      landmarkRole$1.default = void 0;
      var landmarkRole = {
        abstract: true,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']]
      };
      var _default$2c = landmarkRole;
      landmarkRole$1.default = _default$2c;

      var rangeRole$1 = {};

      Object.defineProperty(rangeRole$1, "__esModule", {
        value: true
      });
      rangeRole$1.default = void 0;
      var rangeRole = {
        abstract: true,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-valuemax': null,
          'aria-valuemin': null,
          'aria-valuenow': null
        },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure']]
      };
      var _default$2b = rangeRole;
      rangeRole$1.default = _default$2b;

      var roletypeRole$1 = {};

      Object.defineProperty(roletypeRole$1, "__esModule", {
        value: true
      });
      roletypeRole$1.default = void 0;
      var roletypeRole = {
        abstract: true,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [],
        prohibitedProps: [],
        props: {
          'aria-atomic': null,
          'aria-busy': null,
          'aria-controls': null,
          'aria-current': null,
          'aria-describedby': null,
          'aria-details': null,
          'aria-dropeffect': null,
          'aria-flowto': null,
          'aria-grabbed': null,
          'aria-hidden': null,
          'aria-keyshortcuts': null,
          'aria-label': null,
          'aria-labelledby': null,
          'aria-live': null,
          'aria-owns': null,
          'aria-relevant': null,
          'aria-roledescription': null
        },
        relatedConcepts: [{
          concept: {
            name: 'role'
          },
          module: 'XHTML'
        }, {
          concept: {
            name: 'type'
          },
          module: 'Dublin Core'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: []
      };
      var _default$2a = roletypeRole;
      roletypeRole$1.default = _default$2a;

      var sectionRole$1 = {};

      Object.defineProperty(sectionRole$1, "__esModule", {
        value: true
      });
      sectionRole$1.default = void 0;
      var sectionRole = {
        abstract: true,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            name: 'frontmatter'
          },
          module: 'DTB'
        }, {
          concept: {
            name: 'level'
          },
          module: 'DTB'
        }, {
          concept: {
            name: 'level'
          },
          module: 'SMIL'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure']]
      };
      var _default$29 = sectionRole;
      sectionRole$1.default = _default$29;

      var sectionheadRole$1 = {};

      Object.defineProperty(sectionheadRole$1, "__esModule", {
        value: true
      });
      sectionheadRole$1.default = void 0;
      var sectionheadRole = {
        abstract: true,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure']]
      };
      var _default$28 = sectionheadRole;
      sectionheadRole$1.default = _default$28;

      var selectRole$1 = {};

      Object.defineProperty(selectRole$1, "__esModule", {
        value: true
      });
      selectRole$1.default = void 0;
      var selectRole = {
        abstract: true,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-orientation': null
        },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'widget', 'composite'], ['roletype', 'structure', 'section', 'group']]
      };
      var _default$27 = selectRole;
      selectRole$1.default = _default$27;

      var structureRole$1 = {};

      Object.defineProperty(structureRole$1, "__esModule", {
        value: true
      });
      structureRole$1.default = void 0;
      var structureRole = {
        abstract: true,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype']]
      };
      var _default$26 = structureRole;
      structureRole$1.default = _default$26;

      var widgetRole$1 = {};

      Object.defineProperty(widgetRole$1, "__esModule", {
        value: true
      });
      widgetRole$1.default = void 0;
      var widgetRole = {
        abstract: true,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype']]
      };
      var _default$25 = widgetRole;
      widgetRole$1.default = _default$25;

      var windowRole$1 = {};

      Object.defineProperty(windowRole$1, "__esModule", {
        value: true
      });
      windowRole$1.default = void 0;
      var windowRole = {
        abstract: true,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-modal': null
        },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype']]
      };
      var _default$24 = windowRole;
      windowRole$1.default = _default$24;

      Object.defineProperty(ariaAbstractRoles$1, "__esModule", {
        value: true
      });
      ariaAbstractRoles$1.default = void 0;
      var _commandRole = _interopRequireDefault$7(commandRole$1);
      var _compositeRole = _interopRequireDefault$7(compositeRole$1);
      var _inputRole = _interopRequireDefault$7(inputRole$1);
      var _landmarkRole = _interopRequireDefault$7(landmarkRole$1);
      var _rangeRole = _interopRequireDefault$7(rangeRole$1);
      var _roletypeRole = _interopRequireDefault$7(roletypeRole$1);
      var _sectionRole = _interopRequireDefault$7(sectionRole$1);
      var _sectionheadRole = _interopRequireDefault$7(sectionheadRole$1);
      var _selectRole = _interopRequireDefault$7(selectRole$1);
      var _structureRole = _interopRequireDefault$7(structureRole$1);
      var _widgetRole = _interopRequireDefault$7(widgetRole$1);
      var _windowRole = _interopRequireDefault$7(windowRole$1);
      function _interopRequireDefault$7(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

      var ariaAbstractRoles = [['command', _commandRole.default], ['composite', _compositeRole.default], ['input', _inputRole.default], ['landmark', _landmarkRole.default], ['range', _rangeRole.default], ['roletype', _roletypeRole.default], ['section', _sectionRole.default], ['sectionhead', _sectionheadRole.default], ['select', _selectRole.default], ['structure', _structureRole.default], ['widget', _widgetRole.default], ['window', _windowRole.default]];
      var _default$23 = ariaAbstractRoles;
      ariaAbstractRoles$1.default = _default$23;

      var ariaLiteralRoles$1 = {};

      var alertRole$1 = {};

      Object.defineProperty(alertRole$1, "__esModule", {
        value: true
      });
      alertRole$1.default = void 0;
      var alertRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-atomic': 'true',
          'aria-live': 'assertive'
        },
        relatedConcepts: [{
          concept: {
            name: 'alert'
          },
          module: 'XForms'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']]
      };
      var _default$22 = alertRole;
      alertRole$1.default = _default$22;

      var alertdialogRole$1 = {};

      Object.defineProperty(alertdialogRole$1, "__esModule", {
        value: true
      });
      alertdialogRole$1.default = void 0;
      var alertdialogRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            name: 'alert'
          },
          module: 'XForms'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'alert'], ['roletype', 'window', 'dialog']]
      };
      var _default$21 = alertdialogRole;
      alertdialogRole$1.default = _default$21;

      var applicationRole$1 = {};

      Object.defineProperty(applicationRole$1, "__esModule", {
        value: true
      });
      applicationRole$1.default = void 0;
      var applicationRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-activedescendant': null,
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null
        },
        relatedConcepts: [{
          concept: {
            name: 'Device Independence Delivery Unit'
          }
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure']]
      };
      var _default$20 = applicationRole;
      applicationRole$1.default = _default$20;

      var articleRole$1 = {};

      Object.defineProperty(articleRole$1, "__esModule", {
        value: true
      });
      articleRole$1.default = void 0;
      var articleRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-posinset': null,
          'aria-setsize': null
        },
        relatedConcepts: [{
          concept: {
            name: 'article'
          },
          module: 'HTML'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'document']]
      };
      var _default$1$ = articleRole;
      articleRole$1.default = _default$1$;

      var bannerRole$1 = {};

      Object.defineProperty(bannerRole$1, "__esModule", {
        value: true
      });
      bannerRole$1.default = void 0;
      var bannerRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            constraints: ['scoped to the body element'],
            name: 'header'
          },
          module: 'HTML'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']]
      };
      var _default$1_ = bannerRole;
      bannerRole$1.default = _default$1_;

      var blockquoteRole$1 = {};

      Object.defineProperty(blockquoteRole$1, "__esModule", {
        value: true
      });
      blockquoteRole$1.default = void 0;
      var blockquoteRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            name: 'blockquote'
          },
          module: 'HTML'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']]
      };
      var _default$1Z = blockquoteRole;
      blockquoteRole$1.default = _default$1Z;

      var buttonRole$1 = {};

      Object.defineProperty(buttonRole$1, "__esModule", {
        value: true
      });
      buttonRole$1.default = void 0;
      var buttonRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: true,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-pressed': null
        },
        relatedConcepts: [{
          concept: {
            attributes: [{
              name: 'type',
              value: 'button'
            }],
            name: 'input'
          },
          module: 'HTML'
        }, {
          concept: {
            attributes: [{
              name: 'type',
              value: 'image'
            }],
            name: 'input'
          },
          module: 'HTML'
        }, {
          concept: {
            attributes: [{
              name: 'type',
              value: 'reset'
            }],
            name: 'input'
          },
          module: 'HTML'
        }, {
          concept: {
            attributes: [{
              name: 'type',
              value: 'submit'
            }],
            name: 'input'
          },
          module: 'HTML'
        }, {
          concept: {
            name: 'button'
          },
          module: 'HTML'
        }, {
          concept: {
            name: 'trigger'
          },
          module: 'XForms'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'widget', 'command']]
      };
      var _default$1Y = buttonRole;
      buttonRole$1.default = _default$1Y;

      var captionRole$1 = {};

      Object.defineProperty(captionRole$1, "__esModule", {
        value: true
      });
      captionRole$1.default = void 0;
      var captionRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['prohibited'],
        prohibitedProps: ['aria-label', 'aria-labelledby'],
        props: {},
        relatedConcepts: [{
          concept: {
            name: 'caption'
          },
          module: 'HTML'
        }],
        requireContextRole: ['figure', 'grid', 'table'],
        requiredContextRole: ['figure', 'grid', 'table'],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']]
      };
      var _default$1X = captionRole;
      captionRole$1.default = _default$1X;

      var cellRole$1 = {};

      Object.defineProperty(cellRole$1, "__esModule", {
        value: true
      });
      cellRole$1.default = void 0;
      var cellRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: {
          'aria-colindex': null,
          'aria-colspan': null,
          'aria-rowindex': null,
          'aria-rowspan': null
        },
        relatedConcepts: [{
          concept: {
            constraints: ['ancestor table element has table role'],
            name: 'td'
          },
          module: 'HTML'
        }],
        requireContextRole: ['row'],
        requiredContextRole: ['row'],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']]
      };
      var _default$1W = cellRole;
      cellRole$1.default = _default$1W;

      var checkboxRole$1 = {};

      Object.defineProperty(checkboxRole$1, "__esModule", {
        value: true
      });
      checkboxRole$1.default = void 0;
      var checkboxRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: true,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: {
          'aria-checked': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-invalid': null,
          'aria-readonly': null,
          'aria-required': null
        },
        relatedConcepts: [{
          concept: {
            attributes: [{
              name: 'type',
              value: 'checkbox'
            }],
            name: 'input'
          },
          module: 'HTML'
        }, {
          concept: {
            name: 'option'
          },
          module: 'ARIA'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {
          'aria-checked': null
        },
        superClass: [['roletype', 'widget', 'input']]
      };
      var _default$1V = checkboxRole;
      checkboxRole$1.default = _default$1V;

      var codeRole$1 = {};

      Object.defineProperty(codeRole$1, "__esModule", {
        value: true
      });
      codeRole$1.default = void 0;
      var codeRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['prohibited'],
        prohibitedProps: ['aria-label', 'aria-labelledby'],
        props: {},
        relatedConcepts: [{
          concept: {
            name: 'code'
          },
          module: 'HTML'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']]
      };
      var _default$1U = codeRole;
      codeRole$1.default = _default$1U;

      var columnheaderRole$1 = {};

      Object.defineProperty(columnheaderRole$1, "__esModule", {
        value: true
      });
      columnheaderRole$1.default = void 0;
      var columnheaderRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: {
          'aria-sort': null
        },
        relatedConcepts: [{
          concept: {
            name: 'th'
          },
          module: 'HTML'
        }, {
          concept: {
            attributes: [{
              name: 'scope',
              value: 'col'
            }],
            name: 'th'
          },
          module: 'HTML'
        }, {
          concept: {
            attributes: [{
              name: 'scope',
              value: 'colgroup'
            }],
            name: 'th'
          },
          module: 'HTML'
        }],
        requireContextRole: ['row'],
        requiredContextRole: ['row'],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'cell'], ['roletype', 'structure', 'section', 'cell', 'gridcell'], ['roletype', 'widget', 'gridcell'], ['roletype', 'structure', 'sectionhead']]
      };
      var _default$1T = columnheaderRole;
      columnheaderRole$1.default = _default$1T;

      var comboboxRole$1 = {};

      Object.defineProperty(comboboxRole$1, "__esModule", {
        value: true
      });
      comboboxRole$1.default = void 0;
      var comboboxRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-activedescendant': null,
          'aria-autocomplete': null,
          'aria-errormessage': null,
          'aria-invalid': null,
          'aria-readonly': null,
          'aria-required': null,
          'aria-expanded': 'false',
          'aria-haspopup': 'listbox'
        },
        relatedConcepts: [{
          concept: {
            attributes: [{
              constraints: ['set'],
              name: 'list'
            }, {
              name: 'type',
              value: 'email'
            }],
            name: 'input'
          },
          module: 'HTML'
        }, {
          concept: {
            attributes: [{
              constraints: ['set'],
              name: 'list'
            }, {
              name: 'type',
              value: 'search'
            }],
            name: 'input'
          },
          module: 'HTML'
        }, {
          concept: {
            attributes: [{
              constraints: ['set'],
              name: 'list'
            }, {
              name: 'type',
              value: 'tel'
            }],
            name: 'input'
          },
          module: 'HTML'
        }, {
          concept: {
            attributes: [{
              constraints: ['set'],
              name: 'list'
            }, {
              name: 'type',
              value: 'text'
            }],
            name: 'input'
          },
          module: 'HTML'
        }, {
          concept: {
            attributes: [{
              constraints: ['set'],
              name: 'list'
            }, {
              name: 'type',
              value: 'url'
            }],
            name: 'input'
          },
          module: 'HTML'
        }, {
          concept: {
            attributes: [{
              constraints: ['set'],
              name: 'list'
            }, {
              name: 'type',
              value: 'url'
            }],
            name: 'input'
          },
          module: 'HTML'
        }, {
          concept: {
            attributes: [{
              constraints: ['undefined'],
              name: 'multiple'
            }, {
              constraints: ['undefined'],
              name: 'size'
            }],
            constraints: ['the multiple attribute is not set and the size attribute does not have a value greater than 1'],
            name: 'select'
          },
          module: 'HTML'
        }, {
          concept: {
            name: 'select'
          },
          module: 'XForms'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {
          'aria-controls': null,
          'aria-expanded': 'false'
        },
        superClass: [['roletype', 'widget', 'input']]
      };
      var _default$1S = comboboxRole;
      comboboxRole$1.default = _default$1S;

      var complementaryRole$1 = {};

      Object.defineProperty(complementaryRole$1, "__esModule", {
        value: true
      });
      complementaryRole$1.default = void 0;
      var complementaryRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            name: 'aside'
          },
          module: 'HTML'
        }, {
          concept: {
            attributes: [{
              constraints: ['set'],
              name: 'aria-label'
            }],
            constraints: ['scoped to a sectioning content element', 'scoped to a sectioning root element other than body'],
            name: 'aside'
          },
          module: 'HTML'
        }, {
          concept: {
            attributes: [{
              constraints: ['set'],
              name: 'aria-labelledby'
            }],
            constraints: ['scoped to a sectioning content element', 'scoped to a sectioning root element other than body'],
            name: 'aside'
          },
          module: 'HTML'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']]
      };
      var _default$1R = complementaryRole;
      complementaryRole$1.default = _default$1R;

      var contentinfoRole$1 = {};

      Object.defineProperty(contentinfoRole$1, "__esModule", {
        value: true
      });
      contentinfoRole$1.default = void 0;
      var contentinfoRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            constraints: ['scoped to the body element'],
            name: 'footer'
          },
          module: 'HTML'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']]
      };
      var _default$1Q = contentinfoRole;
      contentinfoRole$1.default = _default$1Q;

      var definitionRole$1 = {};

      Object.defineProperty(definitionRole$1, "__esModule", {
        value: true
      });
      definitionRole$1.default = void 0;
      var definitionRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            name: 'dd'
          },
          module: 'HTML'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']]
      };
      var _default$1P = definitionRole;
      definitionRole$1.default = _default$1P;

      var deletionRole$1 = {};

      Object.defineProperty(deletionRole$1, "__esModule", {
        value: true
      });
      deletionRole$1.default = void 0;
      var deletionRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['prohibited'],
        prohibitedProps: ['aria-label', 'aria-labelledby'],
        props: {},
        relatedConcepts: [{
          concept: {
            name: 'del'
          },
          module: 'HTML'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']]
      };
      var _default$1O = deletionRole;
      deletionRole$1.default = _default$1O;

      var dialogRole$1 = {};

      Object.defineProperty(dialogRole$1, "__esModule", {
        value: true
      });
      dialogRole$1.default = void 0;
      var dialogRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            name: 'dialog'
          },
          module: 'HTML'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'window']]
      };
      var _default$1N = dialogRole;
      dialogRole$1.default = _default$1N;

      var directoryRole$1 = {};

      Object.defineProperty(directoryRole$1, "__esModule", {
        value: true
      });
      directoryRole$1.default = void 0;
      var directoryRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          module: 'DAISY Guide'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'list']]
      };
      var _default$1M = directoryRole;
      directoryRole$1.default = _default$1M;

      var documentRole$1 = {};

      Object.defineProperty(documentRole$1, "__esModule", {
        value: true
      });
      documentRole$1.default = void 0;
      var documentRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            name: 'Device Independence Delivery Unit'
          }
        }, {
          concept: {
            name: 'html'
          },
          module: 'HTML'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure']]
      };
      var _default$1L = documentRole;
      documentRole$1.default = _default$1L;

      var emphasisRole$1 = {};

      Object.defineProperty(emphasisRole$1, "__esModule", {
        value: true
      });
      emphasisRole$1.default = void 0;
      var emphasisRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['prohibited'],
        prohibitedProps: ['aria-label', 'aria-labelledby'],
        props: {},
        relatedConcepts: [{
          concept: {
            name: 'em'
          },
          module: 'HTML'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']]
      };
      var _default$1K = emphasisRole;
      emphasisRole$1.default = _default$1K;

      var feedRole$1 = {};

      Object.defineProperty(feedRole$1, "__esModule", {
        value: true
      });
      feedRole$1.default = void 0;
      var feedRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [['article']],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'list']]
      };
      var _default$1J = feedRole;
      feedRole$1.default = _default$1J;

      var figureRole$1 = {};

      Object.defineProperty(figureRole$1, "__esModule", {
        value: true
      });
      figureRole$1.default = void 0;
      var figureRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            name: 'figure'
          },
          module: 'HTML'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']]
      };
      var _default$1I = figureRole;
      figureRole$1.default = _default$1I;

      var formRole$1 = {};

      Object.defineProperty(formRole$1, "__esModule", {
        value: true
      });
      formRole$1.default = void 0;
      var formRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            attributes: [{
              constraints: ['set'],
              name: 'aria-label'
            }],
            name: 'form'
          },
          module: 'HTML'
        }, {
          concept: {
            attributes: [{
              constraints: ['set'],
              name: 'aria-labelledby'
            }],
            name: 'form'
          },
          module: 'HTML'
        }, {
          concept: {
            attributes: [{
              constraints: ['set'],
              name: 'name'
            }],
            name: 'form'
          },
          module: 'HTML'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']]
      };
      var _default$1H = formRole;
      formRole$1.default = _default$1H;

      var genericRole$1 = {};

      Object.defineProperty(genericRole$1, "__esModule", {
        value: true
      });
      genericRole$1.default = void 0;
      var genericRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['prohibited'],
        prohibitedProps: ['aria-label', 'aria-labelledby'],
        props: {},
        relatedConcepts: [{
          concept: {
            name: 'a'
          },
          module: 'HTML'
        }, {
          concept: {
            name: 'area'
          },
          module: 'HTML'
        }, {
          concept: {
            name: 'aside'
          },
          module: 'HTML'
        }, {
          concept: {
            name: 'b'
          },
          module: 'HTML'
        }, {
          concept: {
            name: 'bdo'
          },
          module: 'HTML'
        }, {
          concept: {
            name: 'body'
          },
          module: 'HTML'
        }, {
          concept: {
            name: 'data'
          },
          module: 'HTML'
        }, {
          concept: {
            name: 'div'
          },
          module: 'HTML'
        }, {
          concept: {
            constraints: ['scoped to the main element', 'scoped to a sectioning content element', 'scoped to a sectioning root element other than body'],
            name: 'footer'
          },
          module: 'HTML'
        }, {
          concept: {
            constraints: ['scoped to the main element', 'scoped to a sectioning content element', 'scoped to a sectioning root element other than body'],
            name: 'header'
          },
          module: 'HTML'
        }, {
          concept: {
            name: 'hgroup'
          },
          module: 'HTML'
        }, {
          concept: {
            name: 'i'
          },
          module: 'HTML'
        }, {
          concept: {
            name: 'pre'
          },
          module: 'HTML'
        }, {
          concept: {
            name: 'q'
          },
          module: 'HTML'
        }, {
          concept: {
            name: 'samp'
          },
          module: 'HTML'
        }, {
          concept: {
            name: 'section'
          },
          module: 'HTML'
        }, {
          concept: {
            name: 'small'
          },
          module: 'HTML'
        }, {
          concept: {
            name: 'span'
          },
          module: 'HTML'
        }, {
          concept: {
            name: 'u'
          },
          module: 'HTML'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure']]
      };
      var _default$1G = genericRole;
      genericRole$1.default = _default$1G;

      var gridRole$1 = {};

      Object.defineProperty(gridRole$1, "__esModule", {
        value: true
      });
      gridRole$1.default = void 0;
      var gridRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-multiselectable': null,
          'aria-readonly': null
        },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [['row'], ['row', 'rowgroup']],
        requiredProps: {},
        superClass: [['roletype', 'widget', 'composite'], ['roletype', 'structure', 'section', 'table']]
      };
      var _default$1F = gridRole;
      gridRole$1.default = _default$1F;

      var gridcellRole$1 = {};

      Object.defineProperty(gridcellRole$1, "__esModule", {
        value: true
      });
      gridcellRole$1.default = void 0;
      var gridcellRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
          'aria-readonly': null,
          'aria-required': null,
          'aria-selected': null
        },
        relatedConcepts: [{
          concept: {
            constraints: ['ancestor table element has grid role', 'ancestor table element has treegrid role'],
            name: 'td'
          },
          module: 'HTML'
        }],
        requireContextRole: ['row'],
        requiredContextRole: ['row'],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'cell'], ['roletype', 'widget']]
      };
      var _default$1E = gridcellRole;
      gridcellRole$1.default = _default$1E;

      var groupRole$1 = {};

      Object.defineProperty(groupRole$1, "__esModule", {
        value: true
      });
      groupRole$1.default = void 0;
      var groupRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-activedescendant': null,
          'aria-disabled': null
        },
        relatedConcepts: [{
          concept: {
            name: 'details'
          },
          module: 'HTML'
        }, {
          concept: {
            name: 'fieldset'
          },
          module: 'HTML'
        }, {
          concept: {
            name: 'optgroup'
          },
          module: 'HTML'
        }, {
          concept: {
            name: 'address'
          },
          module: 'HTML'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']]
      };
      var _default$1D = groupRole;
      groupRole$1.default = _default$1D;

      var headingRole$1 = {};

      Object.defineProperty(headingRole$1, "__esModule", {
        value: true
      });
      headingRole$1.default = void 0;
      var headingRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: {
          'aria-level': '2'
        },
        relatedConcepts: [{
          concept: {
            name: 'h1'
          },
          module: 'HTML'
        }, {
          concept: {
            name: 'h2'
          },
          module: 'HTML'
        }, {
          concept: {
            name: 'h3'
          },
          module: 'HTML'
        }, {
          concept: {
            name: 'h4'
          },
          module: 'HTML'
        }, {
          concept: {
            name: 'h5'
          },
          module: 'HTML'
        }, {
          concept: {
            name: 'h6'
          },
          module: 'HTML'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {
          'aria-level': '2'
        },
        superClass: [['roletype', 'structure', 'sectionhead']]
      };
      var _default$1C = headingRole;
      headingRole$1.default = _default$1C;

      var imgRole$1 = {};

      Object.defineProperty(imgRole$1, "__esModule", {
        value: true
      });
      imgRole$1.default = void 0;
      var imgRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: true,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            attributes: [{
              constraints: ['set'],
              name: 'alt'
            }],
            name: 'img'
          },
          module: 'HTML'
        }, {
          concept: {
            attributes: [{
              constraints: ['undefined'],
              name: 'alt'
            }],
            name: 'img'
          },
          module: 'HTML'
        }, {
          concept: {
            name: 'imggroup'
          },
          module: 'DTB'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']]
      };
      var _default$1B = imgRole;
      imgRole$1.default = _default$1B;

      var insertionRole$1 = {};

      Object.defineProperty(insertionRole$1, "__esModule", {
        value: true
      });
      insertionRole$1.default = void 0;
      var insertionRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['prohibited'],
        prohibitedProps: ['aria-label', 'aria-labelledby'],
        props: {},
        relatedConcepts: [{
          concept: {
            name: 'ins'
          },
          module: 'HTML'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']]
      };
      var _default$1A = insertionRole;
      insertionRole$1.default = _default$1A;

      var linkRole$1 = {};

      Object.defineProperty(linkRole$1, "__esModule", {
        value: true
      });
      linkRole$1.default = void 0;
      var linkRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-expanded': null,
          'aria-haspopup': null
        },
        relatedConcepts: [{
          concept: {
            attributes: [{
              constraints: ['set'],
              name: 'href'
            }],
            name: 'a'
          },
          module: 'HTML'
        }, {
          concept: {
            attributes: [{
              constraints: ['set'],
              name: 'href'
            }],
            name: 'area'
          },
          module: 'HTML'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'widget', 'command']]
      };
      var _default$1z = linkRole;
      linkRole$1.default = _default$1z;

      var listRole$1 = {};

      Object.defineProperty(listRole$1, "__esModule", {
        value: true
      });
      listRole$1.default = void 0;
      var listRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            name: 'menu'
          },
          module: 'HTML'
        }, {
          concept: {
            name: 'ol'
          },
          module: 'HTML'
        }, {
          concept: {
            name: 'ul'
          },
          module: 'HTML'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [['listitem']],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']]
      };
      var _default$1y = listRole;
      listRole$1.default = _default$1y;

      var listboxRole$1 = {};

      Object.defineProperty(listboxRole$1, "__esModule", {
        value: true
      });
      listboxRole$1.default = void 0;
      var listboxRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-invalid': null,
          'aria-multiselectable': null,
          'aria-readonly': null,
          'aria-required': null,
          'aria-orientation': 'vertical'
        },
        relatedConcepts: [{
          concept: {
            attributes: [{
              constraints: ['>1'],
              name: 'size'
            }],
            constraints: ['the size attribute value is greater than 1'],
            name: 'select'
          },
          module: 'HTML'
        }, {
          concept: {
            attributes: [{
              name: 'multiple'
            }],
            name: 'select'
          },
          module: 'HTML'
        }, {
          concept: {
            name: 'datalist'
          },
          module: 'HTML'
        }, {
          concept: {
            name: 'list'
          },
          module: 'ARIA'
        }, {
          concept: {
            name: 'select'
          },
          module: 'XForms'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [['option', 'group'], ['option']],
        requiredProps: {},
        superClass: [['roletype', 'widget', 'composite', 'select'], ['roletype', 'structure', 'section', 'group', 'select']]
      };
      var _default$1x = listboxRole;
      listboxRole$1.default = _default$1x;

      var listitemRole$1 = {};

      Object.defineProperty(listitemRole$1, "__esModule", {
        value: true
      });
      listitemRole$1.default = void 0;
      var listitemRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-level': null,
          'aria-posinset': null,
          'aria-setsize': null
        },
        relatedConcepts: [{
          concept: {
            constraints: ['direct descendant of ol', 'direct descendant of ul', 'direct descendant of menu'],
            name: 'li'
          },
          module: 'HTML'
        }, {
          concept: {
            name: 'item'
          },
          module: 'XForms'
        }],
        requireContextRole: ['directory', 'list'],
        requiredContextRole: ['directory', 'list'],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']]
      };
      var _default$1w = listitemRole;
      listitemRole$1.default = _default$1w;

      var logRole$1 = {};

      Object.defineProperty(logRole$1, "__esModule", {
        value: true
      });
      logRole$1.default = void 0;
      var logRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-live': 'polite'
        },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']]
      };
      var _default$1v = logRole;
      logRole$1.default = _default$1v;

      var mainRole$1 = {};

      Object.defineProperty(mainRole$1, "__esModule", {
        value: true
      });
      mainRole$1.default = void 0;
      var mainRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            name: 'main'
          },
          module: 'HTML'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']]
      };
      var _default$1u = mainRole;
      mainRole$1.default = _default$1u;

      var markRole$1 = {};

      Object.defineProperty(markRole$1, "__esModule", {
        value: true
      });
      markRole$1.default = void 0;
      var markRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['prohibited'],
        prohibitedProps: [],
        props: {
          'aria-braillelabel': null,
          'aria-brailleroledescription': null,
          'aria-description': null
        },
        relatedConcepts: [{
          concept: {
            name: 'mark'
          },
          module: 'HTML'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']]
      };
      var _default$1t = markRole;
      markRole$1.default = _default$1t;

      var marqueeRole$1 = {};

      Object.defineProperty(marqueeRole$1, "__esModule", {
        value: true
      });
      marqueeRole$1.default = void 0;
      var marqueeRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']]
      };
      var _default$1s = marqueeRole;
      marqueeRole$1.default = _default$1s;

      var mathRole$1 = {};

      Object.defineProperty(mathRole$1, "__esModule", {
        value: true
      });
      mathRole$1.default = void 0;
      var mathRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            name: 'math'
          },
          module: 'HTML'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']]
      };
      var _default$1r = mathRole;
      mathRole$1.default = _default$1r;

      var menuRole$1 = {};

      Object.defineProperty(menuRole$1, "__esModule", {
        value: true
      });
      menuRole$1.default = void 0;
      var menuRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-orientation': 'vertical'
        },
        relatedConcepts: [{
          concept: {
            name: 'MENU'
          },
          module: 'JAPI'
        }, {
          concept: {
            name: 'list'
          },
          module: 'ARIA'
        }, {
          concept: {
            name: 'select'
          },
          module: 'XForms'
        }, {
          concept: {
            name: 'sidebar'
          },
          module: 'DTB'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [['menuitem', 'group'], ['menuitemradio', 'group'], ['menuitemcheckbox', 'group'], ['menuitem'], ['menuitemcheckbox'], ['menuitemradio']],
        requiredProps: {},
        superClass: [['roletype', 'widget', 'composite', 'select'], ['roletype', 'structure', 'section', 'group', 'select']]
      };
      var _default$1q = menuRole;
      menuRole$1.default = _default$1q;

      var menubarRole$1 = {};

      Object.defineProperty(menubarRole$1, "__esModule", {
        value: true
      });
      menubarRole$1.default = void 0;
      var menubarRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-orientation': 'horizontal'
        },
        relatedConcepts: [{
          concept: {
            name: 'toolbar'
          },
          module: 'ARIA'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [['menuitem', 'group'], ['menuitemradio', 'group'], ['menuitemcheckbox', 'group'], ['menuitem'], ['menuitemcheckbox'], ['menuitemradio']],
        requiredProps: {},
        superClass: [['roletype', 'widget', 'composite', 'select', 'menu'], ['roletype', 'structure', 'section', 'group', 'select', 'menu']]
      };
      var _default$1p = menubarRole;
      menubarRole$1.default = _default$1p;

      var menuitemRole$1 = {};

      Object.defineProperty(menuitemRole$1, "__esModule", {
        value: true
      });
      menuitemRole$1.default = void 0;
      var menuitemRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-posinset': null,
          'aria-setsize': null
        },
        relatedConcepts: [{
          concept: {
            name: 'MENU_ITEM'
          },
          module: 'JAPI'
        }, {
          concept: {
            name: 'listitem'
          },
          module: 'ARIA'
        }, {
          concept: {
            name: 'option'
          },
          module: 'ARIA'
        }],
        requireContextRole: ['group', 'menu', 'menubar'],
        requiredContextRole: ['group', 'menu', 'menubar'],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'widget', 'command']]
      };
      var _default$1o = menuitemRole;
      menuitemRole$1.default = _default$1o;

      var menuitemcheckboxRole$1 = {};

      Object.defineProperty(menuitemcheckboxRole$1, "__esModule", {
        value: true
      });
      menuitemcheckboxRole$1.default = void 0;
      var menuitemcheckboxRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: true,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            name: 'menuitem'
          },
          module: 'ARIA'
        }],
        requireContextRole: ['group', 'menu', 'menubar'],
        requiredContextRole: ['group', 'menu', 'menubar'],
        requiredOwnedElements: [],
        requiredProps: {
          'aria-checked': null
        },
        superClass: [['roletype', 'widget', 'input', 'checkbox'], ['roletype', 'widget', 'command', 'menuitem']]
      };
      var _default$1n = menuitemcheckboxRole;
      menuitemcheckboxRole$1.default = _default$1n;

      var menuitemradioRole$1 = {};

      Object.defineProperty(menuitemradioRole$1, "__esModule", {
        value: true
      });
      menuitemradioRole$1.default = void 0;
      var menuitemradioRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: true,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            name: 'menuitem'
          },
          module: 'ARIA'
        }],
        requireContextRole: ['group', 'menu', 'menubar'],
        requiredContextRole: ['group', 'menu', 'menubar'],
        requiredOwnedElements: [],
        requiredProps: {
          'aria-checked': null
        },
        superClass: [['roletype', 'widget', 'input', 'checkbox', 'menuitemcheckbox'], ['roletype', 'widget', 'command', 'menuitem', 'menuitemcheckbox'], ['roletype', 'widget', 'input', 'radio']]
      };
      var _default$1m = menuitemradioRole;
      menuitemradioRole$1.default = _default$1m;

      var meterRole$1 = {};

      Object.defineProperty(meterRole$1, "__esModule", {
        value: true
      });
      meterRole$1.default = void 0;
      var meterRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: true,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-valuetext': null,
          'aria-valuemax': '100',
          'aria-valuemin': '0'
        },
        relatedConcepts: [{
          concept: {
            name: 'meter'
          },
          module: 'HTML'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {
          'aria-valuenow': null
        },
        superClass: [['roletype', 'structure', 'range']]
      };
      var _default$1l = meterRole;
      meterRole$1.default = _default$1l;

      var navigationRole$1 = {};

      Object.defineProperty(navigationRole$1, "__esModule", {
        value: true
      });
      navigationRole$1.default = void 0;
      var navigationRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            name: 'nav'
          },
          module: 'HTML'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']]
      };
      var _default$1k = navigationRole;
      navigationRole$1.default = _default$1k;

      var noneRole$1 = {};

      Object.defineProperty(noneRole$1, "__esModule", {
        value: true
      });
      noneRole$1.default = void 0;
      var noneRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: []
      };
      var _default$1j = noneRole;
      noneRole$1.default = _default$1j;

      var noteRole$1 = {};

      Object.defineProperty(noteRole$1, "__esModule", {
        value: true
      });
      noteRole$1.default = void 0;
      var noteRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']]
      };
      var _default$1i = noteRole;
      noteRole$1.default = _default$1i;

      var optionRole$1 = {};

      Object.defineProperty(optionRole$1, "__esModule", {
        value: true
      });
      optionRole$1.default = void 0;
      var optionRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: true,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: {
          'aria-checked': null,
          'aria-posinset': null,
          'aria-setsize': null,
          'aria-selected': 'false'
        },
        relatedConcepts: [{
          concept: {
            name: 'item'
          },
          module: 'XForms'
        }, {
          concept: {
            name: 'listitem'
          },
          module: 'ARIA'
        }, {
          concept: {
            name: 'option'
          },
          module: 'HTML'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {
          'aria-selected': 'false'
        },
        superClass: [['roletype', 'widget', 'input']]
      };
      var _default$1h = optionRole;
      optionRole$1.default = _default$1h;

      var paragraphRole$1 = {};

      Object.defineProperty(paragraphRole$1, "__esModule", {
        value: true
      });
      paragraphRole$1.default = void 0;
      var paragraphRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['prohibited'],
        prohibitedProps: ['aria-label', 'aria-labelledby'],
        props: {},
        relatedConcepts: [{
          concept: {
            name: 'p'
          },
          module: 'HTML'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']]
      };
      var _default$1g = paragraphRole;
      paragraphRole$1.default = _default$1g;

      var presentationRole$1 = {};

      Object.defineProperty(presentationRole$1, "__esModule", {
        value: true
      });
      presentationRole$1.default = void 0;
      var presentationRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['prohibited'],
        prohibitedProps: ['aria-label', 'aria-labelledby'],
        props: {},
        relatedConcepts: [{
          concept: {
            attributes: [{
              name: 'alt',
              value: ''
            }],
            name: 'img'
          },
          module: 'HTML'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure']]
      };
      var _default$1f = presentationRole;
      presentationRole$1.default = _default$1f;

      var progressbarRole$1 = {};

      Object.defineProperty(progressbarRole$1, "__esModule", {
        value: true
      });
      progressbarRole$1.default = void 0;
      var progressbarRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: true,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-valuetext': null
        },
        relatedConcepts: [{
          concept: {
            name: 'progress'
          },
          module: 'HTML'
        }, {
          concept: {
            name: 'status'
          },
          module: 'ARIA'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'range'], ['roletype', 'widget']]
      };
      var _default$1e = progressbarRole;
      progressbarRole$1.default = _default$1e;

      var radioRole$1 = {};

      Object.defineProperty(radioRole$1, "__esModule", {
        value: true
      });
      radioRole$1.default = void 0;
      var radioRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: true,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: {
          'aria-checked': null,
          'aria-posinset': null,
          'aria-setsize': null
        },
        relatedConcepts: [{
          concept: {
            attributes: [{
              name: 'type',
              value: 'radio'
            }],
            name: 'input'
          },
          module: 'HTML'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {
          'aria-checked': null
        },
        superClass: [['roletype', 'widget', 'input']]
      };
      var _default$1d = radioRole;
      radioRole$1.default = _default$1d;

      var radiogroupRole$1 = {};

      Object.defineProperty(radiogroupRole$1, "__esModule", {
        value: true
      });
      radiogroupRole$1.default = void 0;
      var radiogroupRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-errormessage': null,
          'aria-invalid': null,
          'aria-readonly': null,
          'aria-required': null
        },
        relatedConcepts: [{
          concept: {
            name: 'list'
          },
          module: 'ARIA'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [['radio']],
        requiredProps: {},
        superClass: [['roletype', 'widget', 'composite', 'select'], ['roletype', 'structure', 'section', 'group', 'select']]
      };
      var _default$1c = radiogroupRole;
      radiogroupRole$1.default = _default$1c;

      var regionRole$1 = {};

      Object.defineProperty(regionRole$1, "__esModule", {
        value: true
      });
      regionRole$1.default = void 0;
      var regionRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            attributes: [{
              constraints: ['set'],
              name: 'aria-label'
            }],
            name: 'section'
          },
          module: 'HTML'
        }, {
          concept: {
            attributes: [{
              constraints: ['set'],
              name: 'aria-labelledby'
            }],
            name: 'section'
          },
          module: 'HTML'
        }, {
          concept: {
            name: 'Device Independence Glossart perceivable unit'
          }
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']]
      };
      var _default$1b = regionRole;
      regionRole$1.default = _default$1b;

      var rowRole$1 = {};

      Object.defineProperty(rowRole$1, "__esModule", {
        value: true
      });
      rowRole$1.default = void 0;
      var rowRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: {
          'aria-colindex': null,
          'aria-expanded': null,
          'aria-level': null,
          'aria-posinset': null,
          'aria-rowindex': null,
          'aria-selected': null,
          'aria-setsize': null
        },
        relatedConcepts: [{
          concept: {
            name: 'tr'
          },
          module: 'HTML'
        }],
        requireContextRole: ['grid', 'rowgroup', 'table', 'treegrid'],
        requiredContextRole: ['grid', 'rowgroup', 'table', 'treegrid'],
        requiredOwnedElements: [['cell'], ['columnheader'], ['gridcell'], ['rowheader']],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'group'], ['roletype', 'widget']]
      };
      var _default$1a = rowRole;
      rowRole$1.default = _default$1a;

      var rowgroupRole$1 = {};

      Object.defineProperty(rowgroupRole$1, "__esModule", {
        value: true
      });
      rowgroupRole$1.default = void 0;
      var rowgroupRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            name: 'tbody'
          },
          module: 'HTML'
        }, {
          concept: {
            name: 'tfoot'
          },
          module: 'HTML'
        }, {
          concept: {
            name: 'thead'
          },
          module: 'HTML'
        }],
        requireContextRole: ['grid', 'table', 'treegrid'],
        requiredContextRole: ['grid', 'table', 'treegrid'],
        requiredOwnedElements: [['row']],
        requiredProps: {},
        superClass: [['roletype', 'structure']]
      };
      var _default$19 = rowgroupRole;
      rowgroupRole$1.default = _default$19;

      var rowheaderRole$1 = {};

      Object.defineProperty(rowheaderRole$1, "__esModule", {
        value: true
      });
      rowheaderRole$1.default = void 0;
      var rowheaderRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: {
          'aria-sort': null
        },
        relatedConcepts: [{
          concept: {
            attributes: [{
              name: 'scope',
              value: 'row'
            }],
            name: 'th'
          },
          module: 'HTML'
        }, {
          concept: {
            attributes: [{
              name: 'scope',
              value: 'rowgroup'
            }],
            name: 'th'
          },
          module: 'HTML'
        }],
        requireContextRole: ['row', 'rowgroup'],
        requiredContextRole: ['row', 'rowgroup'],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'cell'], ['roletype', 'structure', 'section', 'cell', 'gridcell'], ['roletype', 'widget', 'gridcell'], ['roletype', 'structure', 'sectionhead']]
      };
      var _default$18 = rowheaderRole;
      rowheaderRole$1.default = _default$18;

      var scrollbarRole$1 = {};

      Object.defineProperty(scrollbarRole$1, "__esModule", {
        value: true
      });
      scrollbarRole$1.default = void 0;
      var scrollbarRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: true,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-valuetext': null,
          'aria-orientation': 'vertical',
          'aria-valuemax': '100',
          'aria-valuemin': '0'
        },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {
          'aria-controls': null,
          'aria-valuenow': null
        },
        superClass: [['roletype', 'structure', 'range'], ['roletype', 'widget']]
      };
      var _default$17 = scrollbarRole;
      scrollbarRole$1.default = _default$17;

      var searchRole$1 = {};

      Object.defineProperty(searchRole$1, "__esModule", {
        value: true
      });
      searchRole$1.default = void 0;
      var searchRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']]
      };
      var _default$16 = searchRole;
      searchRole$1.default = _default$16;

      var searchboxRole$1 = {};

      Object.defineProperty(searchboxRole$1, "__esModule", {
        value: true
      });
      searchboxRole$1.default = void 0;
      var searchboxRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            attributes: [{
              constraints: ['undefined'],
              name: 'list'
            }, {
              name: 'type',
              value: 'search'
            }],
            constraints: ['the list attribute is not set'],
            name: 'input'
          },
          module: 'HTML'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'widget', 'input', 'textbox']]
      };
      var _default$15 = searchboxRole;
      searchboxRole$1.default = _default$15;

      var separatorRole$1 = {};

      Object.defineProperty(separatorRole$1, "__esModule", {
        value: true
      });
      separatorRole$1.default = void 0;
      var separatorRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: true,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-orientation': 'horizontal',
          'aria-valuemax': '100',
          'aria-valuemin': '0',
          'aria-valuenow': null,
          'aria-valuetext': null
        },
        relatedConcepts: [{
          concept: {
            name: 'hr'
          },
          module: 'HTML'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure']]
      };
      var _default$14 = separatorRole;
      separatorRole$1.default = _default$14;

      var sliderRole$1 = {};

      Object.defineProperty(sliderRole$1, "__esModule", {
        value: true
      });
      sliderRole$1.default = void 0;
      var sliderRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: true,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-errormessage': null,
          'aria-haspopup': null,
          'aria-invalid': null,
          'aria-readonly': null,
          'aria-valuetext': null,
          'aria-orientation': 'horizontal',
          'aria-valuemax': '100',
          'aria-valuemin': '0'
        },
        relatedConcepts: [{
          concept: {
            attributes: [{
              name: 'type',
              value: 'range'
            }],
            name: 'input'
          },
          module: 'HTML'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {
          'aria-valuenow': null
        },
        superClass: [['roletype', 'widget', 'input'], ['roletype', 'structure', 'range']]
      };
      var _default$13 = sliderRole;
      sliderRole$1.default = _default$13;

      var spinbuttonRole$1 = {};

      Object.defineProperty(spinbuttonRole$1, "__esModule", {
        value: true
      });
      spinbuttonRole$1.default = void 0;
      var spinbuttonRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-errormessage': null,
          'aria-invalid': null,
          'aria-readonly': null,
          'aria-required': null,
          'aria-valuetext': null,
          'aria-valuenow': '0'
        },
        relatedConcepts: [{
          concept: {
            attributes: [{
              name: 'type',
              value: 'number'
            }],
            name: 'input'
          },
          module: 'HTML'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'widget', 'composite'], ['roletype', 'widget', 'input'], ['roletype', 'structure', 'range']]
      };
      var _default$12 = spinbuttonRole;
      spinbuttonRole$1.default = _default$12;

      var statusRole$1 = {};

      Object.defineProperty(statusRole$1, "__esModule", {
        value: true
      });
      statusRole$1.default = void 0;
      var statusRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-atomic': 'true',
          'aria-live': 'polite'
        },
        relatedConcepts: [{
          concept: {
            name: 'output'
          },
          module: 'HTML'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']]
      };
      var _default$11 = statusRole;
      statusRole$1.default = _default$11;

      var strongRole$1 = {};

      Object.defineProperty(strongRole$1, "__esModule", {
        value: true
      });
      strongRole$1.default = void 0;
      var strongRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['prohibited'],
        prohibitedProps: ['aria-label', 'aria-labelledby'],
        props: {},
        relatedConcepts: [{
          concept: {
            name: 'strong'
          },
          module: 'HTML'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']]
      };
      var _default$10 = strongRole;
      strongRole$1.default = _default$10;

      var subscriptRole$1 = {};

      Object.defineProperty(subscriptRole$1, "__esModule", {
        value: true
      });
      subscriptRole$1.default = void 0;
      var subscriptRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['prohibited'],
        prohibitedProps: ['aria-label', 'aria-labelledby'],
        props: {},
        relatedConcepts: [{
          concept: {
            name: 'sub'
          },
          module: 'HTML'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']]
      };
      var _default$$ = subscriptRole;
      subscriptRole$1.default = _default$$;

      var superscriptRole$1 = {};

      Object.defineProperty(superscriptRole$1, "__esModule", {
        value: true
      });
      superscriptRole$1.default = void 0;
      var superscriptRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['prohibited'],
        prohibitedProps: ['aria-label', 'aria-labelledby'],
        props: {},
        relatedConcepts: [{
          concept: {
            name: 'sup'
          },
          module: 'HTML'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']]
      };
      var _default$_ = superscriptRole;
      superscriptRole$1.default = _default$_;

      var switchRole$1 = {};

      Object.defineProperty(switchRole$1, "__esModule", {
        value: true
      });
      switchRole$1.default = void 0;
      var switchRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: true,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            name: 'button'
          },
          module: 'ARIA'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {
          'aria-checked': null
        },
        superClass: [['roletype', 'widget', 'input', 'checkbox']]
      };
      var _default$Z = switchRole;
      switchRole$1.default = _default$Z;

      var tabRole$1 = {};

      Object.defineProperty(tabRole$1, "__esModule", {
        value: true
      });
      tabRole$1.default = void 0;
      var tabRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: true,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-posinset': null,
          'aria-setsize': null,
          'aria-selected': 'false'
        },
        relatedConcepts: [],
        requireContextRole: ['tablist'],
        requiredContextRole: ['tablist'],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'sectionhead'], ['roletype', 'widget']]
      };
      var _default$Y = tabRole;
      tabRole$1.default = _default$Y;

      var tableRole$1 = {};

      Object.defineProperty(tableRole$1, "__esModule", {
        value: true
      });
      tableRole$1.default = void 0;
      var tableRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-colcount': null,
          'aria-rowcount': null
        },
        relatedConcepts: [{
          concept: {
            name: 'table'
          },
          module: 'HTML'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [['row'], ['row', 'rowgroup']],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']]
      };
      var _default$X = tableRole;
      tableRole$1.default = _default$X;

      var tablistRole$1 = {};

      Object.defineProperty(tablistRole$1, "__esModule", {
        value: true
      });
      tablistRole$1.default = void 0;
      var tablistRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-level': null,
          'aria-multiselectable': null,
          'aria-orientation': 'horizontal'
        },
        relatedConcepts: [{
          module: 'DAISY',
          concept: {
            name: 'guide'
          }
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [['tab']],
        requiredProps: {},
        superClass: [['roletype', 'widget', 'composite']]
      };
      var _default$W = tablistRole;
      tablistRole$1.default = _default$W;

      var tabpanelRole$1 = {};

      Object.defineProperty(tabpanelRole$1, "__esModule", {
        value: true
      });
      tabpanelRole$1.default = void 0;
      var tabpanelRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']]
      };
      var _default$V = tabpanelRole;
      tabpanelRole$1.default = _default$V;

      var termRole$1 = {};

      Object.defineProperty(termRole$1, "__esModule", {
        value: true
      });
      termRole$1.default = void 0;
      var termRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            name: 'dfn'
          },
          module: 'HTML'
        }, {
          concept: {
            name: 'dt'
          },
          module: 'HTML'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']]
      };
      var _default$U = termRole;
      termRole$1.default = _default$U;

      var textboxRole$1 = {};

      Object.defineProperty(textboxRole$1, "__esModule", {
        value: true
      });
      textboxRole$1.default = void 0;
      var textboxRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-activedescendant': null,
          'aria-autocomplete': null,
          'aria-errormessage': null,
          'aria-haspopup': null,
          'aria-invalid': null,
          'aria-multiline': null,
          'aria-placeholder': null,
          'aria-readonly': null,
          'aria-required': null
        },
        relatedConcepts: [{
          concept: {
            attributes: [{
              constraints: ['undefined'],
              name: 'type'
            }, {
              constraints: ['undefined'],
              name: 'list'
            }],
            constraints: ['the list attribute is not set'],
            name: 'input'
          },
          module: 'HTML'
        }, {
          concept: {
            attributes: [{
              constraints: ['undefined'],
              name: 'list'
            }, {
              name: 'type',
              value: 'email'
            }],
            constraints: ['the list attribute is not set'],
            name: 'input'
          },
          module: 'HTML'
        }, {
          concept: {
            attributes: [{
              constraints: ['undefined'],
              name: 'list'
            }, {
              name: 'type',
              value: 'tel'
            }],
            constraints: ['the list attribute is not set'],
            name: 'input'
          },
          module: 'HTML'
        }, {
          concept: {
            attributes: [{
              constraints: ['undefined'],
              name: 'list'
            }, {
              name: 'type',
              value: 'text'
            }],
            constraints: ['the list attribute is not set'],
            name: 'input'
          },
          module: 'HTML'
        }, {
          concept: {
            attributes: [{
              constraints: ['undefined'],
              name: 'list'
            }, {
              name: 'type',
              value: 'url'
            }],
            constraints: ['the list attribute is not set'],
            name: 'input'
          },
          module: 'HTML'
        }, {
          concept: {
            name: 'input'
          },
          module: 'XForms'
        }, {
          concept: {
            name: 'textarea'
          },
          module: 'HTML'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'widget', 'input']]
      };
      var _default$T = textboxRole;
      textboxRole$1.default = _default$T;

      var timeRole$1 = {};

      Object.defineProperty(timeRole$1, "__esModule", {
        value: true
      });
      timeRole$1.default = void 0;
      var timeRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            name: 'time'
          },
          module: 'HTML'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']]
      };
      var _default$S = timeRole;
      timeRole$1.default = _default$S;

      var timerRole$1 = {};

      Object.defineProperty(timerRole$1, "__esModule", {
        value: true
      });
      timerRole$1.default = void 0;
      var timerRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'status']]
      };
      var _default$R = timerRole;
      timerRole$1.default = _default$R;

      var toolbarRole$1 = {};

      Object.defineProperty(toolbarRole$1, "__esModule", {
        value: true
      });
      toolbarRole$1.default = void 0;
      var toolbarRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-orientation': 'horizontal'
        },
        relatedConcepts: [{
          concept: {
            name: 'menubar'
          },
          module: 'ARIA'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'group']]
      };
      var _default$Q = toolbarRole;
      toolbarRole$1.default = _default$Q;

      var tooltipRole$1 = {};

      Object.defineProperty(tooltipRole$1, "__esModule", {
        value: true
      });
      tooltipRole$1.default = void 0;
      var tooltipRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']]
      };
      var _default$P = tooltipRole;
      tooltipRole$1.default = _default$P;

      var treeRole$1 = {};

      Object.defineProperty(treeRole$1, "__esModule", {
        value: true
      });
      treeRole$1.default = void 0;
      var treeRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-errormessage': null,
          'aria-invalid': null,
          'aria-multiselectable': null,
          'aria-required': null,
          'aria-orientation': 'vertical'
        },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [['treeitem', 'group'], ['treeitem']],
        requiredProps: {},
        superClass: [['roletype', 'widget', 'composite', 'select'], ['roletype', 'structure', 'section', 'group', 'select']]
      };
      var _default$O = treeRole;
      treeRole$1.default = _default$O;

      var treegridRole$1 = {};

      Object.defineProperty(treegridRole$1, "__esModule", {
        value: true
      });
      treegridRole$1.default = void 0;
      var treegridRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [['row'], ['row', 'rowgroup']],
        requiredProps: {},
        superClass: [['roletype', 'widget', 'composite', 'grid'], ['roletype', 'structure', 'section', 'table', 'grid'], ['roletype', 'widget', 'composite', 'select', 'tree'], ['roletype', 'structure', 'section', 'group', 'select', 'tree']]
      };
      var _default$N = treegridRole;
      treegridRole$1.default = _default$N;

      var treeitemRole$1 = {};

      Object.defineProperty(treeitemRole$1, "__esModule", {
        value: true
      });
      treeitemRole$1.default = void 0;
      var treeitemRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: {
          'aria-expanded': null,
          'aria-haspopup': null
        },
        relatedConcepts: [],
        requireContextRole: ['group', 'tree'],
        requiredContextRole: ['group', 'tree'],
        requiredOwnedElements: [],
        requiredProps: {
          'aria-selected': null
        },
        superClass: [['roletype', 'structure', 'section', 'listitem'], ['roletype', 'widget', 'input', 'option']]
      };
      var _default$M = treeitemRole;
      treeitemRole$1.default = _default$M;

      Object.defineProperty(ariaLiteralRoles$1, "__esModule", {
        value: true
      });
      ariaLiteralRoles$1.default = void 0;
      var _alertRole = _interopRequireDefault$6(alertRole$1);
      var _alertdialogRole = _interopRequireDefault$6(alertdialogRole$1);
      var _applicationRole = _interopRequireDefault$6(applicationRole$1);
      var _articleRole = _interopRequireDefault$6(articleRole$1);
      var _bannerRole = _interopRequireDefault$6(bannerRole$1);
      var _blockquoteRole = _interopRequireDefault$6(blockquoteRole$1);
      var _buttonRole = _interopRequireDefault$6(buttonRole$1);
      var _captionRole = _interopRequireDefault$6(captionRole$1);
      var _cellRole = _interopRequireDefault$6(cellRole$1);
      var _checkboxRole = _interopRequireDefault$6(checkboxRole$1);
      var _codeRole = _interopRequireDefault$6(codeRole$1);
      var _columnheaderRole = _interopRequireDefault$6(columnheaderRole$1);
      var _comboboxRole = _interopRequireDefault$6(comboboxRole$1);
      var _complementaryRole = _interopRequireDefault$6(complementaryRole$1);
      var _contentinfoRole = _interopRequireDefault$6(contentinfoRole$1);
      var _definitionRole = _interopRequireDefault$6(definitionRole$1);
      var _deletionRole = _interopRequireDefault$6(deletionRole$1);
      var _dialogRole = _interopRequireDefault$6(dialogRole$1);
      var _directoryRole = _interopRequireDefault$6(directoryRole$1);
      var _documentRole = _interopRequireDefault$6(documentRole$1);
      var _emphasisRole = _interopRequireDefault$6(emphasisRole$1);
      var _feedRole = _interopRequireDefault$6(feedRole$1);
      var _figureRole = _interopRequireDefault$6(figureRole$1);
      var _formRole = _interopRequireDefault$6(formRole$1);
      var _genericRole = _interopRequireDefault$6(genericRole$1);
      var _gridRole = _interopRequireDefault$6(gridRole$1);
      var _gridcellRole = _interopRequireDefault$6(gridcellRole$1);
      var _groupRole = _interopRequireDefault$6(groupRole$1);
      var _headingRole = _interopRequireDefault$6(headingRole$1);
      var _imgRole = _interopRequireDefault$6(imgRole$1);
      var _insertionRole = _interopRequireDefault$6(insertionRole$1);
      var _linkRole = _interopRequireDefault$6(linkRole$1);
      var _listRole = _interopRequireDefault$6(listRole$1);
      var _listboxRole = _interopRequireDefault$6(listboxRole$1);
      var _listitemRole = _interopRequireDefault$6(listitemRole$1);
      var _logRole = _interopRequireDefault$6(logRole$1);
      var _mainRole = _interopRequireDefault$6(mainRole$1);
      var _markRole = _interopRequireDefault$6(markRole$1);
      var _marqueeRole = _interopRequireDefault$6(marqueeRole$1);
      var _mathRole = _interopRequireDefault$6(mathRole$1);
      var _menuRole = _interopRequireDefault$6(menuRole$1);
      var _menubarRole = _interopRequireDefault$6(menubarRole$1);
      var _menuitemRole = _interopRequireDefault$6(menuitemRole$1);
      var _menuitemcheckboxRole = _interopRequireDefault$6(menuitemcheckboxRole$1);
      var _menuitemradioRole = _interopRequireDefault$6(menuitemradioRole$1);
      var _meterRole = _interopRequireDefault$6(meterRole$1);
      var _navigationRole = _interopRequireDefault$6(navigationRole$1);
      var _noneRole = _interopRequireDefault$6(noneRole$1);
      var _noteRole = _interopRequireDefault$6(noteRole$1);
      var _optionRole = _interopRequireDefault$6(optionRole$1);
      var _paragraphRole = _interopRequireDefault$6(paragraphRole$1);
      var _presentationRole = _interopRequireDefault$6(presentationRole$1);
      var _progressbarRole = _interopRequireDefault$6(progressbarRole$1);
      var _radioRole = _interopRequireDefault$6(radioRole$1);
      var _radiogroupRole = _interopRequireDefault$6(radiogroupRole$1);
      var _regionRole = _interopRequireDefault$6(regionRole$1);
      var _rowRole = _interopRequireDefault$6(rowRole$1);
      var _rowgroupRole = _interopRequireDefault$6(rowgroupRole$1);
      var _rowheaderRole = _interopRequireDefault$6(rowheaderRole$1);
      var _scrollbarRole = _interopRequireDefault$6(scrollbarRole$1);
      var _searchRole = _interopRequireDefault$6(searchRole$1);
      var _searchboxRole = _interopRequireDefault$6(searchboxRole$1);
      var _separatorRole = _interopRequireDefault$6(separatorRole$1);
      var _sliderRole = _interopRequireDefault$6(sliderRole$1);
      var _spinbuttonRole = _interopRequireDefault$6(spinbuttonRole$1);
      var _statusRole = _interopRequireDefault$6(statusRole$1);
      var _strongRole = _interopRequireDefault$6(strongRole$1);
      var _subscriptRole = _interopRequireDefault$6(subscriptRole$1);
      var _superscriptRole = _interopRequireDefault$6(superscriptRole$1);
      var _switchRole = _interopRequireDefault$6(switchRole$1);
      var _tabRole = _interopRequireDefault$6(tabRole$1);
      var _tableRole = _interopRequireDefault$6(tableRole$1);
      var _tablistRole = _interopRequireDefault$6(tablistRole$1);
      var _tabpanelRole = _interopRequireDefault$6(tabpanelRole$1);
      var _termRole = _interopRequireDefault$6(termRole$1);
      var _textboxRole = _interopRequireDefault$6(textboxRole$1);
      var _timeRole = _interopRequireDefault$6(timeRole$1);
      var _timerRole = _interopRequireDefault$6(timerRole$1);
      var _toolbarRole = _interopRequireDefault$6(toolbarRole$1);
      var _tooltipRole = _interopRequireDefault$6(tooltipRole$1);
      var _treeRole = _interopRequireDefault$6(treeRole$1);
      var _treegridRole = _interopRequireDefault$6(treegridRole$1);
      var _treeitemRole = _interopRequireDefault$6(treeitemRole$1);
      function _interopRequireDefault$6(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

      var ariaLiteralRoles = [['alert', _alertRole.default], ['alertdialog', _alertdialogRole.default], ['application', _applicationRole.default], ['article', _articleRole.default], ['banner', _bannerRole.default], ['blockquote', _blockquoteRole.default], ['button', _buttonRole.default], ['caption', _captionRole.default], ['cell', _cellRole.default], ['checkbox', _checkboxRole.default], ['code', _codeRole.default], ['columnheader', _columnheaderRole.default], ['combobox', _comboboxRole.default], ['complementary', _complementaryRole.default], ['contentinfo', _contentinfoRole.default], ['definition', _definitionRole.default], ['deletion', _deletionRole.default], ['dialog', _dialogRole.default], ['directory', _directoryRole.default], ['document', _documentRole.default], ['emphasis', _emphasisRole.default], ['feed', _feedRole.default], ['figure', _figureRole.default], ['form', _formRole.default], ['generic', _genericRole.default], ['grid', _gridRole.default], ['gridcell', _gridcellRole.default], ['group', _groupRole.default], ['heading', _headingRole.default], ['img', _imgRole.default], ['insertion', _insertionRole.default], ['link', _linkRole.default], ['list', _listRole.default], ['listbox', _listboxRole.default], ['listitem', _listitemRole.default], ['log', _logRole.default], ['main', _mainRole.default], ['mark', _markRole.default], ['marquee', _marqueeRole.default], ['math', _mathRole.default], ['menu', _menuRole.default], ['menubar', _menubarRole.default], ['menuitem', _menuitemRole.default], ['menuitemcheckbox', _menuitemcheckboxRole.default], ['menuitemradio', _menuitemradioRole.default], ['meter', _meterRole.default], ['navigation', _navigationRole.default], ['none', _noneRole.default], ['note', _noteRole.default], ['option', _optionRole.default], ['paragraph', _paragraphRole.default], ['presentation', _presentationRole.default], ['progressbar', _progressbarRole.default], ['radio', _radioRole.default], ['radiogroup', _radiogroupRole.default], ['region', _regionRole.default], ['row', _rowRole.default], ['rowgroup', _rowgroupRole.default], ['rowheader', _rowheaderRole.default], ['scrollbar', _scrollbarRole.default], ['search', _searchRole.default], ['searchbox', _searchboxRole.default], ['separator', _separatorRole.default], ['slider', _sliderRole.default], ['spinbutton', _spinbuttonRole.default], ['status', _statusRole.default], ['strong', _strongRole.default], ['subscript', _subscriptRole.default], ['superscript', _superscriptRole.default], ['switch', _switchRole.default], ['tab', _tabRole.default], ['table', _tableRole.default], ['tablist', _tablistRole.default], ['tabpanel', _tabpanelRole.default], ['term', _termRole.default], ['textbox', _textboxRole.default], ['time', _timeRole.default], ['timer', _timerRole.default], ['toolbar', _toolbarRole.default], ['tooltip', _tooltipRole.default], ['tree', _treeRole.default], ['treegrid', _treegridRole.default], ['treeitem', _treeitemRole.default]];
      var _default$L = ariaLiteralRoles;
      ariaLiteralRoles$1.default = _default$L;

      var ariaDpubRoles$1 = {};

      var docAbstractRole$1 = {};

      Object.defineProperty(docAbstractRole$1, "__esModule", {
        value: true
      });
      docAbstractRole$1.default = void 0;
      var docAbstractRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null
        },
        relatedConcepts: [{
          concept: {
            name: 'abstract [EPUB-SSV]'
          },
          module: 'EPUB'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']]
      };
      var _default$K = docAbstractRole;
      docAbstractRole$1.default = _default$K;

      var docAcknowledgmentsRole$1 = {};

      Object.defineProperty(docAcknowledgmentsRole$1, "__esModule", {
        value: true
      });
      docAcknowledgmentsRole$1.default = void 0;
      var docAcknowledgmentsRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null
        },
        relatedConcepts: [{
          concept: {
            name: 'acknowledgments [EPUB-SSV]'
          },
          module: 'EPUB'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']]
      };
      var _default$J = docAcknowledgmentsRole;
      docAcknowledgmentsRole$1.default = _default$J;

      var docAfterwordRole$1 = {};

      Object.defineProperty(docAfterwordRole$1, "__esModule", {
        value: true
      });
      docAfterwordRole$1.default = void 0;
      var docAfterwordRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null
        },
        relatedConcepts: [{
          concept: {
            name: 'afterword [EPUB-SSV]'
          },
          module: 'EPUB'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']]
      };
      var _default$I = docAfterwordRole;
      docAfterwordRole$1.default = _default$I;

      var docAppendixRole$1 = {};

      Object.defineProperty(docAppendixRole$1, "__esModule", {
        value: true
      });
      docAppendixRole$1.default = void 0;
      var docAppendixRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null
        },
        relatedConcepts: [{
          concept: {
            name: 'appendix [EPUB-SSV]'
          },
          module: 'EPUB'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']]
      };
      var _default$H = docAppendixRole;
      docAppendixRole$1.default = _default$H;

      var docBacklinkRole$1 = {};

      Object.defineProperty(docBacklinkRole$1, "__esModule", {
        value: true
      });
      docBacklinkRole$1.default = void 0;
      var docBacklinkRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: {
          'aria-errormessage': null,
          'aria-invalid': null
        },
        relatedConcepts: [{
          concept: {
            name: 'referrer [EPUB-SSV]'
          },
          module: 'EPUB'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'widget', 'command', 'link']]
      };
      var _default$G = docBacklinkRole;
      docBacklinkRole$1.default = _default$G;

      var docBiblioentryRole$1 = {};

      Object.defineProperty(docBiblioentryRole$1, "__esModule", {
        value: true
      });
      docBiblioentryRole$1.default = void 0;
      var docBiblioentryRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null
        },
        relatedConcepts: [{
          concept: {
            name: 'EPUB biblioentry [EPUB-SSV]'
          },
          module: 'EPUB'
        }],
        requireContextRole: ['doc-bibliography'],
        requiredContextRole: ['doc-bibliography'],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'listitem']]
      };
      var _default$F = docBiblioentryRole;
      docBiblioentryRole$1.default = _default$F;

      var docBibliographyRole$1 = {};

      Object.defineProperty(docBibliographyRole$1, "__esModule", {
        value: true
      });
      docBibliographyRole$1.default = void 0;
      var docBibliographyRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null
        },
        relatedConcepts: [{
          concept: {
            name: 'bibliography [EPUB-SSV]'
          },
          module: 'EPUB'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [['doc-biblioentry']],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']]
      };
      var _default$E = docBibliographyRole;
      docBibliographyRole$1.default = _default$E;

      var docBibliorefRole$1 = {};

      Object.defineProperty(docBibliorefRole$1, "__esModule", {
        value: true
      });
      docBibliorefRole$1.default = void 0;
      var docBibliorefRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: {
          'aria-errormessage': null,
          'aria-invalid': null
        },
        relatedConcepts: [{
          concept: {
            name: 'biblioref [EPUB-SSV]'
          },
          module: 'EPUB'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'widget', 'command', 'link']]
      };
      var _default$D = docBibliorefRole;
      docBibliorefRole$1.default = _default$D;

      var docChapterRole$1 = {};

      Object.defineProperty(docChapterRole$1, "__esModule", {
        value: true
      });
      docChapterRole$1.default = void 0;
      var docChapterRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null
        },
        relatedConcepts: [{
          concept: {
            name: 'chapter [EPUB-SSV]'
          },
          module: 'EPUB'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']]
      };
      var _default$C = docChapterRole;
      docChapterRole$1.default = _default$C;

      var docColophonRole$1 = {};

      Object.defineProperty(docColophonRole$1, "__esModule", {
        value: true
      });
      docColophonRole$1.default = void 0;
      var docColophonRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null
        },
        relatedConcepts: [{
          concept: {
            name: 'colophon [EPUB-SSV]'
          },
          module: 'EPUB'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']]
      };
      var _default$B = docColophonRole;
      docColophonRole$1.default = _default$B;

      var docConclusionRole$1 = {};

      Object.defineProperty(docConclusionRole$1, "__esModule", {
        value: true
      });
      docConclusionRole$1.default = void 0;
      var docConclusionRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null
        },
        relatedConcepts: [{
          concept: {
            name: 'conclusion [EPUB-SSV]'
          },
          module: 'EPUB'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']]
      };
      var _default$A = docConclusionRole;
      docConclusionRole$1.default = _default$A;

      var docCoverRole$1 = {};

      Object.defineProperty(docCoverRole$1, "__esModule", {
        value: true
      });
      docCoverRole$1.default = void 0;
      var docCoverRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null
        },
        relatedConcepts: [{
          concept: {
            name: 'cover [EPUB-SSV]'
          },
          module: 'EPUB'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'img']]
      };
      var _default$z = docCoverRole;
      docCoverRole$1.default = _default$z;

      var docCreditRole$1 = {};

      Object.defineProperty(docCreditRole$1, "__esModule", {
        value: true
      });
      docCreditRole$1.default = void 0;
      var docCreditRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null
        },
        relatedConcepts: [{
          concept: {
            name: 'credit [EPUB-SSV]'
          },
          module: 'EPUB'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']]
      };
      var _default$y = docCreditRole;
      docCreditRole$1.default = _default$y;

      var docCreditsRole$1 = {};

      Object.defineProperty(docCreditsRole$1, "__esModule", {
        value: true
      });
      docCreditsRole$1.default = void 0;
      var docCreditsRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null
        },
        relatedConcepts: [{
          concept: {
            name: 'credits [EPUB-SSV]'
          },
          module: 'EPUB'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']]
      };
      var _default$x = docCreditsRole;
      docCreditsRole$1.default = _default$x;

      var docDedicationRole$1 = {};

      Object.defineProperty(docDedicationRole$1, "__esModule", {
        value: true
      });
      docDedicationRole$1.default = void 0;
      var docDedicationRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null
        },
        relatedConcepts: [{
          concept: {
            name: 'dedication [EPUB-SSV]'
          },
          module: 'EPUB'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']]
      };
      var _default$w = docDedicationRole;
      docDedicationRole$1.default = _default$w;

      var docEndnoteRole$1 = {};

      Object.defineProperty(docEndnoteRole$1, "__esModule", {
        value: true
      });
      docEndnoteRole$1.default = void 0;
      var docEndnoteRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null
        },
        relatedConcepts: [{
          concept: {
            name: 'rearnote [EPUB-SSV]'
          },
          module: 'EPUB'
        }],
        requireContextRole: ['doc-endnotes'],
        requiredContextRole: ['doc-endnotes'],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'listitem']]
      };
      var _default$v = docEndnoteRole;
      docEndnoteRole$1.default = _default$v;

      var docEndnotesRole$1 = {};

      Object.defineProperty(docEndnotesRole$1, "__esModule", {
        value: true
      });
      docEndnotesRole$1.default = void 0;
      var docEndnotesRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null
        },
        relatedConcepts: [{
          concept: {
            name: 'rearnotes [EPUB-SSV]'
          },
          module: 'EPUB'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [['doc-endnote']],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']]
      };
      var _default$u = docEndnotesRole;
      docEndnotesRole$1.default = _default$u;

      var docEpigraphRole$1 = {};

      Object.defineProperty(docEpigraphRole$1, "__esModule", {
        value: true
      });
      docEpigraphRole$1.default = void 0;
      var docEpigraphRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null
        },
        relatedConcepts: [{
          concept: {
            name: 'epigraph [EPUB-SSV]'
          },
          module: 'EPUB'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']]
      };
      var _default$t = docEpigraphRole;
      docEpigraphRole$1.default = _default$t;

      var docEpilogueRole$1 = {};

      Object.defineProperty(docEpilogueRole$1, "__esModule", {
        value: true
      });
      docEpilogueRole$1.default = void 0;
      var docEpilogueRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null
        },
        relatedConcepts: [{
          concept: {
            name: 'epilogue [EPUB-SSV]'
          },
          module: 'EPUB'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']]
      };
      var _default$s = docEpilogueRole;
      docEpilogueRole$1.default = _default$s;

      var docErrataRole$1 = {};

      Object.defineProperty(docErrataRole$1, "__esModule", {
        value: true
      });
      docErrataRole$1.default = void 0;
      var docErrataRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null
        },
        relatedConcepts: [{
          concept: {
            name: 'errata [EPUB-SSV]'
          },
          module: 'EPUB'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']]
      };
      var _default$r = docErrataRole;
      docErrataRole$1.default = _default$r;

      var docExampleRole$1 = {};

      Object.defineProperty(docExampleRole$1, "__esModule", {
        value: true
      });
      docExampleRole$1.default = void 0;
      var docExampleRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null
        },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']]
      };
      var _default$q = docExampleRole;
      docExampleRole$1.default = _default$q;

      var docFootnoteRole$1 = {};

      Object.defineProperty(docFootnoteRole$1, "__esModule", {
        value: true
      });
      docFootnoteRole$1.default = void 0;
      var docFootnoteRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null
        },
        relatedConcepts: [{
          concept: {
            name: 'footnote [EPUB-SSV]'
          },
          module: 'EPUB'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']]
      };
      var _default$p = docFootnoteRole;
      docFootnoteRole$1.default = _default$p;

      var docForewordRole$1 = {};

      Object.defineProperty(docForewordRole$1, "__esModule", {
        value: true
      });
      docForewordRole$1.default = void 0;
      var docForewordRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null
        },
        relatedConcepts: [{
          concept: {
            name: 'foreword [EPUB-SSV]'
          },
          module: 'EPUB'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']]
      };
      var _default$o = docForewordRole;
      docForewordRole$1.default = _default$o;

      var docGlossaryRole$1 = {};

      Object.defineProperty(docGlossaryRole$1, "__esModule", {
        value: true
      });
      docGlossaryRole$1.default = void 0;
      var docGlossaryRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null
        },
        relatedConcepts: [{
          concept: {
            name: 'glossary [EPUB-SSV]'
          },
          module: 'EPUB'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [['definition'], ['term']],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']]
      };
      var _default$n = docGlossaryRole;
      docGlossaryRole$1.default = _default$n;

      var docGlossrefRole$1 = {};

      Object.defineProperty(docGlossrefRole$1, "__esModule", {
        value: true
      });
      docGlossrefRole$1.default = void 0;
      var docGlossrefRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: {
          'aria-errormessage': null,
          'aria-invalid': null
        },
        relatedConcepts: [{
          concept: {
            name: 'glossref [EPUB-SSV]'
          },
          module: 'EPUB'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'widget', 'command', 'link']]
      };
      var _default$m = docGlossrefRole;
      docGlossrefRole$1.default = _default$m;

      var docIndexRole$1 = {};

      Object.defineProperty(docIndexRole$1, "__esModule", {
        value: true
      });
      docIndexRole$1.default = void 0;
      var docIndexRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null
        },
        relatedConcepts: [{
          concept: {
            name: 'index [EPUB-SSV]'
          },
          module: 'EPUB'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark', 'navigation']]
      };
      var _default$l = docIndexRole;
      docIndexRole$1.default = _default$l;

      var docIntroductionRole$1 = {};

      Object.defineProperty(docIntroductionRole$1, "__esModule", {
        value: true
      });
      docIntroductionRole$1.default = void 0;
      var docIntroductionRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null
        },
        relatedConcepts: [{
          concept: {
            name: 'introduction [EPUB-SSV]'
          },
          module: 'EPUB'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']]
      };
      var _default$k = docIntroductionRole;
      docIntroductionRole$1.default = _default$k;

      var docNoterefRole$1 = {};

      Object.defineProperty(docNoterefRole$1, "__esModule", {
        value: true
      });
      docNoterefRole$1.default = void 0;
      var docNoterefRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: {
          'aria-errormessage': null,
          'aria-invalid': null
        },
        relatedConcepts: [{
          concept: {
            name: 'noteref [EPUB-SSV]'
          },
          module: 'EPUB'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'widget', 'command', 'link']]
      };
      var _default$j = docNoterefRole;
      docNoterefRole$1.default = _default$j;

      var docNoticeRole$1 = {};

      Object.defineProperty(docNoticeRole$1, "__esModule", {
        value: true
      });
      docNoticeRole$1.default = void 0;
      var docNoticeRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null
        },
        relatedConcepts: [{
          concept: {
            name: 'notice [EPUB-SSV]'
          },
          module: 'EPUB'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'note']]
      };
      var _default$i = docNoticeRole;
      docNoticeRole$1.default = _default$i;

      var docPagebreakRole$1 = {};

      Object.defineProperty(docPagebreakRole$1, "__esModule", {
        value: true
      });
      docPagebreakRole$1.default = void 0;
      var docPagebreakRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: true,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null
        },
        relatedConcepts: [{
          concept: {
            name: 'pagebreak [EPUB-SSV]'
          },
          module: 'EPUB'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'separator']]
      };
      var _default$h = docPagebreakRole;
      docPagebreakRole$1.default = _default$h;

      var docPagelistRole$1 = {};

      Object.defineProperty(docPagelistRole$1, "__esModule", {
        value: true
      });
      docPagelistRole$1.default = void 0;
      var docPagelistRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null
        },
        relatedConcepts: [{
          concept: {
            name: 'page-list [EPUB-SSV]'
          },
          module: 'EPUB'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark', 'navigation']]
      };
      var _default$g = docPagelistRole;
      docPagelistRole$1.default = _default$g;

      var docPartRole$1 = {};

      Object.defineProperty(docPartRole$1, "__esModule", {
        value: true
      });
      docPartRole$1.default = void 0;
      var docPartRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null
        },
        relatedConcepts: [{
          concept: {
            name: 'part [EPUB-SSV]'
          },
          module: 'EPUB'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']]
      };
      var _default$f = docPartRole;
      docPartRole$1.default = _default$f;

      var docPrefaceRole$1 = {};

      Object.defineProperty(docPrefaceRole$1, "__esModule", {
        value: true
      });
      docPrefaceRole$1.default = void 0;
      var docPrefaceRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null
        },
        relatedConcepts: [{
          concept: {
            name: 'preface [EPUB-SSV]'
          },
          module: 'EPUB'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']]
      };
      var _default$e = docPrefaceRole;
      docPrefaceRole$1.default = _default$e;

      var docPrologueRole$1 = {};

      Object.defineProperty(docPrologueRole$1, "__esModule", {
        value: true
      });
      docPrologueRole$1.default = void 0;
      var docPrologueRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null
        },
        relatedConcepts: [{
          concept: {
            name: 'prologue [EPUB-SSV]'
          },
          module: 'EPUB'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']]
      };
      var _default$d = docPrologueRole;
      docPrologueRole$1.default = _default$d;

      var docPullquoteRole$1 = {};

      Object.defineProperty(docPullquoteRole$1, "__esModule", {
        value: true
      });
      docPullquoteRole$1.default = void 0;
      var docPullquoteRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            name: 'pullquote [EPUB-SSV]'
          },
          module: 'EPUB'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['none']]
      };
      var _default$c = docPullquoteRole;
      docPullquoteRole$1.default = _default$c;

      var docQnaRole$1 = {};

      Object.defineProperty(docQnaRole$1, "__esModule", {
        value: true
      });
      docQnaRole$1.default = void 0;
      var docQnaRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null
        },
        relatedConcepts: [{
          concept: {
            name: 'qna [EPUB-SSV]'
          },
          module: 'EPUB'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']]
      };
      var _default$b = docQnaRole;
      docQnaRole$1.default = _default$b;

      var docSubtitleRole$1 = {};

      Object.defineProperty(docSubtitleRole$1, "__esModule", {
        value: true
      });
      docSubtitleRole$1.default = void 0;
      var docSubtitleRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null
        },
        relatedConcepts: [{
          concept: {
            name: 'subtitle [EPUB-SSV]'
          },
          module: 'EPUB'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'sectionhead']]
      };
      var _default$a = docSubtitleRole;
      docSubtitleRole$1.default = _default$a;

      var docTipRole$1 = {};

      Object.defineProperty(docTipRole$1, "__esModule", {
        value: true
      });
      docTipRole$1.default = void 0;
      var docTipRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null
        },
        relatedConcepts: [{
          concept: {
            name: 'help [EPUB-SSV]'
          },
          module: 'EPUB'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'note']]
      };
      var _default$9 = docTipRole;
      docTipRole$1.default = _default$9;

      var docTocRole$1 = {};

      Object.defineProperty(docTocRole$1, "__esModule", {
        value: true
      });
      docTocRole$1.default = void 0;
      var docTocRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null
        },
        relatedConcepts: [{
          concept: {
            name: 'toc [EPUB-SSV]'
          },
          module: 'EPUB'
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark', 'navigation']]
      };
      var _default$8 = docTocRole;
      docTocRole$1.default = _default$8;

      Object.defineProperty(ariaDpubRoles$1, "__esModule", {
        value: true
      });
      ariaDpubRoles$1.default = void 0;
      var _docAbstractRole = _interopRequireDefault$5(docAbstractRole$1);
      var _docAcknowledgmentsRole = _interopRequireDefault$5(docAcknowledgmentsRole$1);
      var _docAfterwordRole = _interopRequireDefault$5(docAfterwordRole$1);
      var _docAppendixRole = _interopRequireDefault$5(docAppendixRole$1);
      var _docBacklinkRole = _interopRequireDefault$5(docBacklinkRole$1);
      var _docBiblioentryRole = _interopRequireDefault$5(docBiblioentryRole$1);
      var _docBibliographyRole = _interopRequireDefault$5(docBibliographyRole$1);
      var _docBibliorefRole = _interopRequireDefault$5(docBibliorefRole$1);
      var _docChapterRole = _interopRequireDefault$5(docChapterRole$1);
      var _docColophonRole = _interopRequireDefault$5(docColophonRole$1);
      var _docConclusionRole = _interopRequireDefault$5(docConclusionRole$1);
      var _docCoverRole = _interopRequireDefault$5(docCoverRole$1);
      var _docCreditRole = _interopRequireDefault$5(docCreditRole$1);
      var _docCreditsRole = _interopRequireDefault$5(docCreditsRole$1);
      var _docDedicationRole = _interopRequireDefault$5(docDedicationRole$1);
      var _docEndnoteRole = _interopRequireDefault$5(docEndnoteRole$1);
      var _docEndnotesRole = _interopRequireDefault$5(docEndnotesRole$1);
      var _docEpigraphRole = _interopRequireDefault$5(docEpigraphRole$1);
      var _docEpilogueRole = _interopRequireDefault$5(docEpilogueRole$1);
      var _docErrataRole = _interopRequireDefault$5(docErrataRole$1);
      var _docExampleRole = _interopRequireDefault$5(docExampleRole$1);
      var _docFootnoteRole = _interopRequireDefault$5(docFootnoteRole$1);
      var _docForewordRole = _interopRequireDefault$5(docForewordRole$1);
      var _docGlossaryRole = _interopRequireDefault$5(docGlossaryRole$1);
      var _docGlossrefRole = _interopRequireDefault$5(docGlossrefRole$1);
      var _docIndexRole = _interopRequireDefault$5(docIndexRole$1);
      var _docIntroductionRole = _interopRequireDefault$5(docIntroductionRole$1);
      var _docNoterefRole = _interopRequireDefault$5(docNoterefRole$1);
      var _docNoticeRole = _interopRequireDefault$5(docNoticeRole$1);
      var _docPagebreakRole = _interopRequireDefault$5(docPagebreakRole$1);
      var _docPagelistRole = _interopRequireDefault$5(docPagelistRole$1);
      var _docPartRole = _interopRequireDefault$5(docPartRole$1);
      var _docPrefaceRole = _interopRequireDefault$5(docPrefaceRole$1);
      var _docPrologueRole = _interopRequireDefault$5(docPrologueRole$1);
      var _docPullquoteRole = _interopRequireDefault$5(docPullquoteRole$1);
      var _docQnaRole = _interopRequireDefault$5(docQnaRole$1);
      var _docSubtitleRole = _interopRequireDefault$5(docSubtitleRole$1);
      var _docTipRole = _interopRequireDefault$5(docTipRole$1);
      var _docTocRole = _interopRequireDefault$5(docTocRole$1);
      function _interopRequireDefault$5(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

      var ariaDpubRoles = [['doc-abstract', _docAbstractRole.default], ['doc-acknowledgments', _docAcknowledgmentsRole.default], ['doc-afterword', _docAfterwordRole.default], ['doc-appendix', _docAppendixRole.default], ['doc-backlink', _docBacklinkRole.default], ['doc-biblioentry', _docBiblioentryRole.default], ['doc-bibliography', _docBibliographyRole.default], ['doc-biblioref', _docBibliorefRole.default], ['doc-chapter', _docChapterRole.default], ['doc-colophon', _docColophonRole.default], ['doc-conclusion', _docConclusionRole.default], ['doc-cover', _docCoverRole.default], ['doc-credit', _docCreditRole.default], ['doc-credits', _docCreditsRole.default], ['doc-dedication', _docDedicationRole.default], ['doc-endnote', _docEndnoteRole.default], ['doc-endnotes', _docEndnotesRole.default], ['doc-epigraph', _docEpigraphRole.default], ['doc-epilogue', _docEpilogueRole.default], ['doc-errata', _docErrataRole.default], ['doc-example', _docExampleRole.default], ['doc-footnote', _docFootnoteRole.default], ['doc-foreword', _docForewordRole.default], ['doc-glossary', _docGlossaryRole.default], ['doc-glossref', _docGlossrefRole.default], ['doc-index', _docIndexRole.default], ['doc-introduction', _docIntroductionRole.default], ['doc-noteref', _docNoterefRole.default], ['doc-notice', _docNoticeRole.default], ['doc-pagebreak', _docPagebreakRole.default], ['doc-pagelist', _docPagelistRole.default], ['doc-part', _docPartRole.default], ['doc-preface', _docPrefaceRole.default], ['doc-prologue', _docPrologueRole.default], ['doc-pullquote', _docPullquoteRole.default], ['doc-qna', _docQnaRole.default], ['doc-subtitle', _docSubtitleRole.default], ['doc-tip', _docTipRole.default], ['doc-toc', _docTocRole.default]];
      var _default$7 = ariaDpubRoles;
      ariaDpubRoles$1.default = _default$7;

      var ariaGraphicsRoles$1 = {};

      var graphicsDocumentRole$1 = {};

      Object.defineProperty(graphicsDocumentRole$1, "__esModule", {
        value: true
      });
      graphicsDocumentRole$1.default = void 0;
      var graphicsDocumentRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null
        },
        relatedConcepts: [{
          module: 'GRAPHICS',
          concept: {
            name: 'graphics-object'
          }
        }, {
          module: 'ARIA',
          concept: {
            name: 'img'
          }
        }, {
          module: 'ARIA',
          concept: {
            name: 'article'
          }
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'document']]
      };
      var _default$6 = graphicsDocumentRole;
      graphicsDocumentRole$1.default = _default$6;

      var graphicsObjectRole$1 = {};

      Object.defineProperty(graphicsObjectRole$1, "__esModule", {
        value: true
      });
      graphicsObjectRole$1.default = void 0;
      var graphicsObjectRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: {
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null
        },
        relatedConcepts: [{
          module: 'GRAPHICS',
          concept: {
            name: 'graphics-document'
          }
        }, {
          module: 'ARIA',
          concept: {
            name: 'group'
          }
        }, {
          module: 'ARIA',
          concept: {
            name: 'img'
          }
        }, {
          module: 'GRAPHICS',
          concept: {
            name: 'graphics-symbol'
          }
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'group']]
      };
      var _default$5 = graphicsObjectRole;
      graphicsObjectRole$1.default = _default$5;

      var graphicsSymbolRole$1 = {};

      Object.defineProperty(graphicsSymbolRole$1, "__esModule", {
        value: true
      });
      graphicsSymbolRole$1.default = void 0;
      var graphicsSymbolRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: true,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null
        },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'img']]
      };
      var _default$4 = graphicsSymbolRole;
      graphicsSymbolRole$1.default = _default$4;

      Object.defineProperty(ariaGraphicsRoles$1, "__esModule", {
        value: true
      });
      ariaGraphicsRoles$1.default = void 0;
      var _graphicsDocumentRole = _interopRequireDefault$4(graphicsDocumentRole$1);
      var _graphicsObjectRole = _interopRequireDefault$4(graphicsObjectRole$1);
      var _graphicsSymbolRole = _interopRequireDefault$4(graphicsSymbolRole$1);
      function _interopRequireDefault$4(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

      var ariaGraphicsRoles = [['graphics-document', _graphicsDocumentRole.default], ['graphics-object', _graphicsObjectRole.default], ['graphics-symbol', _graphicsSymbolRole.default]];
      var _default$3 = ariaGraphicsRoles;
      ariaGraphicsRoles$1.default = _default$3;

      Object.defineProperty(rolesMap$1, "__esModule", {
        value: true
      });
      rolesMap$1.default = void 0;
      var _ariaAbstractRoles = _interopRequireDefault$3(ariaAbstractRoles$1);
      var _ariaLiteralRoles = _interopRequireDefault$3(ariaLiteralRoles$1);
      var _ariaDpubRoles = _interopRequireDefault$3(ariaDpubRoles$1);
      var _ariaGraphicsRoles = _interopRequireDefault$3(ariaGraphicsRoles$1);
      var _iterationDecorator$2 = _interopRequireDefault$3(iterationDecorator$1);
      function _interopRequireDefault$3(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
      function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
      function _createForOfIteratorHelper$2(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$2(o)) || allowArrayLike) { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
      function _slicedToArray$2(arr, i) { return _arrayWithHoles$2(arr) || _iterableToArrayLimit$2(arr, i) || _unsupportedIterableToArray$2(arr, i) || _nonIterableRest$2(); }
      function _nonIterableRest$2() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
      function _unsupportedIterableToArray$2(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$2(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$2(o, minLen); }
      function _arrayLikeToArray$2(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
      function _iterableToArrayLimit$2(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }
      function _arrayWithHoles$2(arr) { if (Array.isArray(arr)) return arr; }
      var roles$1 = [].concat(_ariaAbstractRoles.default, _ariaLiteralRoles.default, _ariaDpubRoles.default, _ariaGraphicsRoles.default);
      roles$1.forEach(function (_ref) {
        var _ref2 = _slicedToArray$2(_ref, 2),
          roleDefinition = _ref2[1];
        // Conglomerate the properties
        var _iterator = _createForOfIteratorHelper$2(roleDefinition.superClass),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var superClassIter = _step.value;
            var _iterator2 = _createForOfIteratorHelper$2(superClassIter),
              _step2;
            try {
              var _loop = function _loop() {
                var superClassName = _step2.value;
                var superClassRoleTuple = roles$1.find(function (_ref3) {
                  var _ref4 = _slicedToArray$2(_ref3, 1),
                    name = _ref4[0];
                  return name === superClassName;
                });
                if (superClassRoleTuple) {
                  var superClassDefinition = superClassRoleTuple[1];
                  for (var _i2 = 0, _Object$keys = Object.keys(superClassDefinition.props); _i2 < _Object$keys.length; _i2++) {
                    var prop = _Object$keys[_i2];
                    if (
                    // $FlowIssue Accessing the hasOwnProperty on the Object prototype is fine.
                    !Object.prototype.hasOwnProperty.call(roleDefinition.props, prop)) {
                      Object.assign(roleDefinition.props, _defineProperty({}, prop, superClassDefinition.props[prop]));
                    }
                  }
                }
              };
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                _loop();
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      });
      var rolesMap = {
        entries: function entries() {
          return roles$1;
        },
        forEach: function forEach(fn) {
          var thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          var _iterator3 = _createForOfIteratorHelper$2(roles$1),
            _step3;
          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
              var _step3$value = _slicedToArray$2(_step3.value, 2),
                key = _step3$value[0],
                values = _step3$value[1];
              fn.call(thisArg, values, key, roles$1);
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }
        },
        get: function get(key) {
          var item = roles$1.find(function (tuple) {
            return tuple[0] === key ? true : false;
          });
          return item && item[1];
        },
        has: function has(key) {
          return !!rolesMap.get(key);
        },
        keys: function keys() {
          return roles$1.map(function (_ref5) {
            var _ref6 = _slicedToArray$2(_ref5, 1),
              key = _ref6[0];
            return key;
          });
        },
        values: function values() {
          return roles$1.map(function (_ref7) {
            var _ref8 = _slicedToArray$2(_ref7, 2),
              values = _ref8[1];
            return values;
          });
        }
      };
      var _default$2 = (0, _iterationDecorator$2.default)(rolesMap, rolesMap.entries());
      rolesMap$1.default = _default$2;

      var elementRoleMap$1 = {};

      var lite = {};

      var has = Object.prototype.hasOwnProperty;

      function dequal(foo, bar) {
      	var ctor, len;
      	if (foo === bar) return true;

      	if (foo && bar && (ctor=foo.constructor) === bar.constructor) {
      		if (ctor === Date) return foo.getTime() === bar.getTime();
      		if (ctor === RegExp) return foo.toString() === bar.toString();

      		if (ctor === Array) {
      			if ((len=foo.length) === bar.length) {
      				while (len-- && dequal(foo[len], bar[len]));
      			}
      			return len === -1;
      		}

      		if (!ctor || typeof foo === 'object') {
      			len = 0;
      			for (ctor in foo) {
      				if (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;
      				if (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;
      			}
      			return Object.keys(bar).length === len;
      		}
      	}

      	return foo !== foo && bar !== bar;
      }

      lite.dequal = dequal;

      Object.defineProperty(elementRoleMap$1, "__esModule", {
        value: true
      });
      elementRoleMap$1.default = void 0;
      var _lite = lite;
      var _iterationDecorator$1 = _interopRequireDefault$2(iterationDecorator$1);
      var _rolesMap$2 = _interopRequireDefault$2(rolesMap$1);
      function _interopRequireDefault$2(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
      function _slicedToArray$1(arr, i) { return _arrayWithHoles$1(arr) || _iterableToArrayLimit$1(arr, i) || _unsupportedIterableToArray$1(arr, i) || _nonIterableRest$1(); }
      function _nonIterableRest$1() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
      function _iterableToArrayLimit$1(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }
      function _arrayWithHoles$1(arr) { if (Array.isArray(arr)) return arr; }
      function _createForOfIteratorHelper$1(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike) { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
      function _unsupportedIterableToArray$1(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$1(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen); }
      function _arrayLikeToArray$1(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
      var elementRoles$1 = [];
      var keys$1 = _rolesMap$2.default.keys();
      for (var i$1 = 0; i$1 < keys$1.length; i$1++) {
        var key$1 = keys$1[i$1];
        var role$1 = _rolesMap$2.default.get(key$1);
        if (role$1) {
          var concepts$1 = [].concat(role$1.baseConcepts, role$1.relatedConcepts);
          for (var k$1 = 0; k$1 < concepts$1.length; k$1++) {
            var relation$1 = concepts$1[k$1];
            if (relation$1.module === 'HTML') {
              (function () {
                var concept = relation$1.concept;
                if (concept) {
                  var elementRoleRelation = elementRoles$1.find(function (relation) {
                    return (0, _lite.dequal)(relation, concept);
                  });
                  var roles;
                  if (elementRoleRelation) {
                    roles = elementRoleRelation[1];
                  } else {
                    roles = [];
                  }
                  var isUnique = true;
                  for (var _i = 0; _i < roles.length; _i++) {
                    if (roles[_i] === key$1) {
                      isUnique = false;
                      break;
                    }
                  }
                  if (isUnique) {
                    roles.push(key$1);
                  }
                  elementRoles$1.push([concept, roles]);
                }
              })();
            }
          }
        }
      }
      var elementRoleMap = {
        entries: function entries() {
          return elementRoles$1;
        },
        forEach: function forEach(fn) {
          var thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          var _iterator = _createForOfIteratorHelper$1(elementRoles$1),
            _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var _step$value = _slicedToArray$1(_step.value, 2),
                _key = _step$value[0],
                values = _step$value[1];
              fn.call(thisArg, values, _key, elementRoles$1);
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        },
        get: function get(key) {
          var item = elementRoles$1.find(function (tuple) {
            return key.name === tuple[0].name && (0, _lite.dequal)(key.attributes, tuple[0].attributes);
          });
          return item && item[1];
        },
        has: function has(key) {
          return !!elementRoleMap.get(key);
        },
        keys: function keys() {
          return elementRoles$1.map(function (_ref) {
            var _ref2 = _slicedToArray$1(_ref, 1),
              key = _ref2[0];
            return key;
          });
        },
        values: function values() {
          return elementRoles$1.map(function (_ref3) {
            var _ref4 = _slicedToArray$1(_ref3, 2),
              values = _ref4[1];
            return values;
          });
        }
      };
      var _default$1 = (0, _iterationDecorator$1.default)(elementRoleMap, elementRoleMap.entries());
      elementRoleMap$1.default = _default$1;

      var roleElementMap$1 = {};

      Object.defineProperty(roleElementMap$1, "__esModule", {
        value: true
      });
      roleElementMap$1.default = void 0;
      var _iterationDecorator = _interopRequireDefault$1(iterationDecorator$1);
      var _rolesMap$1 = _interopRequireDefault$1(rolesMap$1);
      function _interopRequireDefault$1(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
      function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
      function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
      function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }
      function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
      function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike) { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
      function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
      function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
      var roleElement = [];
      var keys = _rolesMap$1.default.keys();
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        var role = _rolesMap$1.default.get(key);
        var relationConcepts = [];
        if (role) {
          var concepts = [].concat(role.baseConcepts, role.relatedConcepts);
          for (var k = 0; k < concepts.length; k++) {
            var relation = concepts[k];
            if (relation.module === 'HTML') {
              var concept = relation.concept;
              if (concept != null) {
                relationConcepts.push(concept);
              }
            }
          }
          if (relationConcepts.length > 0) {
            roleElement.push([key, relationConcepts]);
          }
        }
      }
      var roleElementMap = {
        entries: function entries() {
          return roleElement;
        },
        forEach: function forEach(fn) {
          var thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          var _iterator = _createForOfIteratorHelper(roleElement),
            _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var _step$value = _slicedToArray(_step.value, 2),
                _key = _step$value[0],
                values = _step$value[1];
              fn.call(thisArg, values, _key, roleElement);
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        },
        get: function get(key) {
          var item = roleElement.find(function (tuple) {
            return tuple[0] === key ? true : false;
          });
          return item && item[1];
        },
        has: function has(key) {
          return !!roleElementMap.get(key);
        },
        keys: function keys() {
          return roleElement.map(function (_ref) {
            var _ref2 = _slicedToArray(_ref, 1),
              key = _ref2[0];
            return key;
          });
        },
        values: function values() {
          return roleElement.map(function (_ref3) {
            var _ref4 = _slicedToArray(_ref3, 2),
              values = _ref4[1];
            return values;
          });
        }
      };
      var _default = (0, _iterationDecorator.default)(roleElementMap, roleElementMap.entries());
      roleElementMap$1.default = _default;

      Object.defineProperty(lib, "__esModule", {
        value: true
      });
      var roles_1 = lib.roles = roleElements_1 = lib.roleElements = elementRoles_1 = lib.elementRoles = lib.dom = lib.aria = void 0;
      var _ariaPropsMap = _interopRequireDefault(ariaPropsMap$1);
      var _domMap = _interopRequireDefault(domMap$1);
      var _rolesMap = _interopRequireDefault(rolesMap$1);
      var _elementRoleMap = _interopRequireDefault(elementRoleMap$1);
      var _roleElementMap = _interopRequireDefault(roleElementMap$1);
      function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

      var aria = _ariaPropsMap.default;
      lib.aria = aria;
      var dom = _domMap.default;
      lib.dom = dom;
      var roles = _rolesMap.default;
      roles_1 = lib.roles = roles;
      var elementRoles = _elementRoleMap.default;
      var elementRoles_1 = lib.elementRoles = elementRoles;
      var roleElements = _roleElementMap.default;
      var roleElements_1 = lib.roleElements = roleElements;

      var lzString$1 = {exports: {}};

      (function (module) {
      	// Copyright (c) 2013 Pieroxy <pieroxy@pieroxy.net>
      	// This work is free. You can redistribute it and/or modify it
      	// under the terms of the WTFPL, Version 2
      	// For more information see LICENSE.txt or http://www.wtfpl.net/
      	//
      	// For more information, the home page:
      	// http://pieroxy.net/blog/pages/lz-string/testing.html
      	//
      	// LZ-based compression algorithm, version 1.4.5
      	var LZString = (function() {

      	// private property
      	var f = String.fromCharCode;
      	var keyStrBase64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      	var keyStrUriSafe = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$";
      	var baseReverseDic = {};

      	function getBaseValue(alphabet, character) {
      	  if (!baseReverseDic[alphabet]) {
      	    baseReverseDic[alphabet] = {};
      	    for (var i=0 ; i<alphabet.length ; i++) {
      	      baseReverseDic[alphabet][alphabet.charAt(i)] = i;
      	    }
      	  }
      	  return baseReverseDic[alphabet][character];
      	}

      	var LZString = {
      	  compressToBase64 : function (input) {
      	    if (input == null) return "";
      	    var res = LZString._compress(input, 6, function(a){return keyStrBase64.charAt(a);});
      	    switch (res.length % 4) { // To produce valid Base64
      	    default: // When could this happen ?
      	    case 0 : return res;
      	    case 1 : return res+"===";
      	    case 2 : return res+"==";
      	    case 3 : return res+"=";
      	    }
      	  },

      	  decompressFromBase64 : function (input) {
      	    if (input == null) return "";
      	    if (input == "") return null;
      	    return LZString._decompress(input.length, 32, function(index) { return getBaseValue(keyStrBase64, input.charAt(index)); });
      	  },

      	  compressToUTF16 : function (input) {
      	    if (input == null) return "";
      	    return LZString._compress(input, 15, function(a){return f(a+32);}) + " ";
      	  },

      	  decompressFromUTF16: function (compressed) {
      	    if (compressed == null) return "";
      	    if (compressed == "") return null;
      	    return LZString._decompress(compressed.length, 16384, function(index) { return compressed.charCodeAt(index) - 32; });
      	  },

      	  //compress into uint8array (UCS-2 big endian format)
      	  compressToUint8Array: function (uncompressed) {
      	    var compressed = LZString.compress(uncompressed);
      	    var buf=new Uint8Array(compressed.length*2); // 2 bytes per character

      	    for (var i=0, TotalLen=compressed.length; i<TotalLen; i++) {
      	      var current_value = compressed.charCodeAt(i);
      	      buf[i*2] = current_value >>> 8;
      	      buf[i*2+1] = current_value % 256;
      	    }
      	    return buf;
      	  },

      	  //decompress from uint8array (UCS-2 big endian format)
      	  decompressFromUint8Array:function (compressed) {
      	    if (compressed===null || compressed===undefined){
      	        return LZString.decompress(compressed);
      	    } else {
      	        var buf=new Array(compressed.length/2); // 2 bytes per character
      	        for (var i=0, TotalLen=buf.length; i<TotalLen; i++) {
      	          buf[i]=compressed[i*2]*256+compressed[i*2+1];
      	        }

      	        var result = [];
      	        buf.forEach(function (c) {
      	          result.push(f(c));
      	        });
      	        return LZString.decompress(result.join(''));

      	    }

      	  },


      	  //compress into a string that is already URI encoded
      	  compressToEncodedURIComponent: function (input) {
      	    if (input == null) return "";
      	    return LZString._compress(input, 6, function(a){return keyStrUriSafe.charAt(a);});
      	  },

      	  //decompress from an output of compressToEncodedURIComponent
      	  decompressFromEncodedURIComponent:function (input) {
      	    if (input == null) return "";
      	    if (input == "") return null;
      	    input = input.replace(/ /g, "+");
      	    return LZString._decompress(input.length, 32, function(index) { return getBaseValue(keyStrUriSafe, input.charAt(index)); });
      	  },

      	  compress: function (uncompressed) {
      	    return LZString._compress(uncompressed, 16, function(a){return f(a);});
      	  },
      	  _compress: function (uncompressed, bitsPerChar, getCharFromInt) {
      	    if (uncompressed == null) return "";
      	    var i, value,
      	        context_dictionary= {},
      	        context_dictionaryToCreate= {},
      	        context_c="",
      	        context_wc="",
      	        context_w="",
      	        context_enlargeIn= 2, // Compensate for the first entry which should not count
      	        context_dictSize= 3,
      	        context_numBits= 2,
      	        context_data=[],
      	        context_data_val=0,
      	        context_data_position=0,
      	        ii;

      	    for (ii = 0; ii < uncompressed.length; ii += 1) {
      	      context_c = uncompressed.charAt(ii);
      	      if (!Object.prototype.hasOwnProperty.call(context_dictionary,context_c)) {
      	        context_dictionary[context_c] = context_dictSize++;
      	        context_dictionaryToCreate[context_c] = true;
      	      }

      	      context_wc = context_w + context_c;
      	      if (Object.prototype.hasOwnProperty.call(context_dictionary,context_wc)) {
      	        context_w = context_wc;
      	      } else {
      	        if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate,context_w)) {
      	          if (context_w.charCodeAt(0)<256) {
      	            for (i=0 ; i<context_numBits ; i++) {
      	              context_data_val = (context_data_val << 1);
      	              if (context_data_position == bitsPerChar-1) {
      	                context_data_position = 0;
      	                context_data.push(getCharFromInt(context_data_val));
      	                context_data_val = 0;
      	              } else {
      	                context_data_position++;
      	              }
      	            }
      	            value = context_w.charCodeAt(0);
      	            for (i=0 ; i<8 ; i++) {
      	              context_data_val = (context_data_val << 1) | (value&1);
      	              if (context_data_position == bitsPerChar-1) {
      	                context_data_position = 0;
      	                context_data.push(getCharFromInt(context_data_val));
      	                context_data_val = 0;
      	              } else {
      	                context_data_position++;
      	              }
      	              value = value >> 1;
      	            }
      	          } else {
      	            value = 1;
      	            for (i=0 ; i<context_numBits ; i++) {
      	              context_data_val = (context_data_val << 1) | value;
      	              if (context_data_position ==bitsPerChar-1) {
      	                context_data_position = 0;
      	                context_data.push(getCharFromInt(context_data_val));
      	                context_data_val = 0;
      	              } else {
      	                context_data_position++;
      	              }
      	              value = 0;
      	            }
      	            value = context_w.charCodeAt(0);
      	            for (i=0 ; i<16 ; i++) {
      	              context_data_val = (context_data_val << 1) | (value&1);
      	              if (context_data_position == bitsPerChar-1) {
      	                context_data_position = 0;
      	                context_data.push(getCharFromInt(context_data_val));
      	                context_data_val = 0;
      	              } else {
      	                context_data_position++;
      	              }
      	              value = value >> 1;
      	            }
      	          }
      	          context_enlargeIn--;
      	          if (context_enlargeIn == 0) {
      	            context_enlargeIn = Math.pow(2, context_numBits);
      	            context_numBits++;
      	          }
      	          delete context_dictionaryToCreate[context_w];
      	        } else {
      	          value = context_dictionary[context_w];
      	          for (i=0 ; i<context_numBits ; i++) {
      	            context_data_val = (context_data_val << 1) | (value&1);
      	            if (context_data_position == bitsPerChar-1) {
      	              context_data_position = 0;
      	              context_data.push(getCharFromInt(context_data_val));
      	              context_data_val = 0;
      	            } else {
      	              context_data_position++;
      	            }
      	            value = value >> 1;
      	          }


      	        }
      	        context_enlargeIn--;
      	        if (context_enlargeIn == 0) {
      	          context_enlargeIn = Math.pow(2, context_numBits);
      	          context_numBits++;
      	        }
      	        // Add wc to the dictionary.
      	        context_dictionary[context_wc] = context_dictSize++;
      	        context_w = String(context_c);
      	      }
      	    }

      	    // Output the code for w.
      	    if (context_w !== "") {
      	      if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate,context_w)) {
      	        if (context_w.charCodeAt(0)<256) {
      	          for (i=0 ; i<context_numBits ; i++) {
      	            context_data_val = (context_data_val << 1);
      	            if (context_data_position == bitsPerChar-1) {
      	              context_data_position = 0;
      	              context_data.push(getCharFromInt(context_data_val));
      	              context_data_val = 0;
      	            } else {
      	              context_data_position++;
      	            }
      	          }
      	          value = context_w.charCodeAt(0);
      	          for (i=0 ; i<8 ; i++) {
      	            context_data_val = (context_data_val << 1) | (value&1);
      	            if (context_data_position == bitsPerChar-1) {
      	              context_data_position = 0;
      	              context_data.push(getCharFromInt(context_data_val));
      	              context_data_val = 0;
      	            } else {
      	              context_data_position++;
      	            }
      	            value = value >> 1;
      	          }
      	        } else {
      	          value = 1;
      	          for (i=0 ; i<context_numBits ; i++) {
      	            context_data_val = (context_data_val << 1) | value;
      	            if (context_data_position == bitsPerChar-1) {
      	              context_data_position = 0;
      	              context_data.push(getCharFromInt(context_data_val));
      	              context_data_val = 0;
      	            } else {
      	              context_data_position++;
      	            }
      	            value = 0;
      	          }
      	          value = context_w.charCodeAt(0);
      	          for (i=0 ; i<16 ; i++) {
      	            context_data_val = (context_data_val << 1) | (value&1);
      	            if (context_data_position == bitsPerChar-1) {
      	              context_data_position = 0;
      	              context_data.push(getCharFromInt(context_data_val));
      	              context_data_val = 0;
      	            } else {
      	              context_data_position++;
      	            }
      	            value = value >> 1;
      	          }
      	        }
      	        context_enlargeIn--;
      	        if (context_enlargeIn == 0) {
      	          context_enlargeIn = Math.pow(2, context_numBits);
      	          context_numBits++;
      	        }
      	        delete context_dictionaryToCreate[context_w];
      	      } else {
      	        value = context_dictionary[context_w];
      	        for (i=0 ; i<context_numBits ; i++) {
      	          context_data_val = (context_data_val << 1) | (value&1);
      	          if (context_data_position == bitsPerChar-1) {
      	            context_data_position = 0;
      	            context_data.push(getCharFromInt(context_data_val));
      	            context_data_val = 0;
      	          } else {
      	            context_data_position++;
      	          }
      	          value = value >> 1;
      	        }


      	      }
      	      context_enlargeIn--;
      	      if (context_enlargeIn == 0) {
      	        context_enlargeIn = Math.pow(2, context_numBits);
      	        context_numBits++;
      	      }
      	    }

      	    // Mark the end of the stream
      	    value = 2;
      	    for (i=0 ; i<context_numBits ; i++) {
      	      context_data_val = (context_data_val << 1) | (value&1);
      	      if (context_data_position == bitsPerChar-1) {
      	        context_data_position = 0;
      	        context_data.push(getCharFromInt(context_data_val));
      	        context_data_val = 0;
      	      } else {
      	        context_data_position++;
      	      }
      	      value = value >> 1;
      	    }

      	    // Flush the last char
      	    while (true) {
      	      context_data_val = (context_data_val << 1);
      	      if (context_data_position == bitsPerChar-1) {
      	        context_data.push(getCharFromInt(context_data_val));
      	        break;
      	      }
      	      else context_data_position++;
      	    }
      	    return context_data.join('');
      	  },

      	  decompress: function (compressed) {
      	    if (compressed == null) return "";
      	    if (compressed == "") return null;
      	    return LZString._decompress(compressed.length, 32768, function(index) { return compressed.charCodeAt(index); });
      	  },

      	  _decompress: function (length, resetValue, getNextValue) {
      	    var dictionary = [],
      	        enlargeIn = 4,
      	        dictSize = 4,
      	        numBits = 3,
      	        entry = "",
      	        result = [],
      	        i,
      	        w,
      	        bits, resb, maxpower, power,
      	        c,
      	        data = {val:getNextValue(0), position:resetValue, index:1};

      	    for (i = 0; i < 3; i += 1) {
      	      dictionary[i] = i;
      	    }

      	    bits = 0;
      	    maxpower = Math.pow(2,2);
      	    power=1;
      	    while (power!=maxpower) {
      	      resb = data.val & data.position;
      	      data.position >>= 1;
      	      if (data.position == 0) {
      	        data.position = resetValue;
      	        data.val = getNextValue(data.index++);
      	      }
      	      bits |= (resb>0 ? 1 : 0) * power;
      	      power <<= 1;
      	    }

      	    switch (bits) {
      	      case 0:
      	          bits = 0;
      	          maxpower = Math.pow(2,8);
      	          power=1;
      	          while (power!=maxpower) {
      	            resb = data.val & data.position;
      	            data.position >>= 1;
      	            if (data.position == 0) {
      	              data.position = resetValue;
      	              data.val = getNextValue(data.index++);
      	            }
      	            bits |= (resb>0 ? 1 : 0) * power;
      	            power <<= 1;
      	          }
      	        c = f(bits);
      	        break;
      	      case 1:
      	          bits = 0;
      	          maxpower = Math.pow(2,16);
      	          power=1;
      	          while (power!=maxpower) {
      	            resb = data.val & data.position;
      	            data.position >>= 1;
      	            if (data.position == 0) {
      	              data.position = resetValue;
      	              data.val = getNextValue(data.index++);
      	            }
      	            bits |= (resb>0 ? 1 : 0) * power;
      	            power <<= 1;
      	          }
      	        c = f(bits);
      	        break;
      	      case 2:
      	        return "";
      	    }
      	    dictionary[3] = c;
      	    w = c;
      	    result.push(c);
      	    while (true) {
      	      if (data.index > length) {
      	        return "";
      	      }

      	      bits = 0;
      	      maxpower = Math.pow(2,numBits);
      	      power=1;
      	      while (power!=maxpower) {
      	        resb = data.val & data.position;
      	        data.position >>= 1;
      	        if (data.position == 0) {
      	          data.position = resetValue;
      	          data.val = getNextValue(data.index++);
      	        }
      	        bits |= (resb>0 ? 1 : 0) * power;
      	        power <<= 1;
      	      }

      	      switch (c = bits) {
      	        case 0:
      	          bits = 0;
      	          maxpower = Math.pow(2,8);
      	          power=1;
      	          while (power!=maxpower) {
      	            resb = data.val & data.position;
      	            data.position >>= 1;
      	            if (data.position == 0) {
      	              data.position = resetValue;
      	              data.val = getNextValue(data.index++);
      	            }
      	            bits |= (resb>0 ? 1 : 0) * power;
      	            power <<= 1;
      	          }

      	          dictionary[dictSize++] = f(bits);
      	          c = dictSize-1;
      	          enlargeIn--;
      	          break;
      	        case 1:
      	          bits = 0;
      	          maxpower = Math.pow(2,16);
      	          power=1;
      	          while (power!=maxpower) {
      	            resb = data.val & data.position;
      	            data.position >>= 1;
      	            if (data.position == 0) {
      	              data.position = resetValue;
      	              data.val = getNextValue(data.index++);
      	            }
      	            bits |= (resb>0 ? 1 : 0) * power;
      	            power <<= 1;
      	          }
      	          dictionary[dictSize++] = f(bits);
      	          c = dictSize-1;
      	          enlargeIn--;
      	          break;
      	        case 2:
      	          return result.join('');
      	      }

      	      if (enlargeIn == 0) {
      	        enlargeIn = Math.pow(2, numBits);
      	        numBits++;
      	      }

      	      if (dictionary[c]) {
      	        entry = dictionary[c];
      	      } else {
      	        if (c === dictSize) {
      	          entry = w + w.charAt(0);
      	        } else {
      	          return null;
      	        }
      	      }
      	      result.push(entry);

      	      // Add w+entry[0] to the dictionary.
      	      dictionary[dictSize++] = w + entry.charAt(0);
      	      enlargeIn--;

      	      w = entry;

      	      if (enlargeIn == 0) {
      	        enlargeIn = Math.pow(2, numBits);
      	        numBits++;
      	      }

      	    }
      	  }
      	};
      	  return LZString;
      	})();

      	if( module != null ) {
      	  module.exports = LZString;
      	} else if( typeof angular !== 'undefined' && angular != null ) {
      	  angular.module('LZString', [])
      	  .factory('LZString', function () {
      	    return LZString;
      	  });
      	} 
      } (lzString$1));

      var lzStringExports = lzString$1.exports;
      const lzString = /*@__PURE__*/getDefaultExportFromCjs(lzStringExports);

      var define_process_env_default = {};
      function escapeHTML(str) {
        return str.replace(/</g, "&lt;").replace(/>/g, "&gt;");
      }
      const printProps = (keys, props, config2, indentation, depth, refs, printer) => {
        const indentationNext = indentation + config2.indent;
        const colors = config2.colors;
        return keys.map((key) => {
          const value = props[key];
          let printed = printer(value, config2, indentationNext, depth, refs);
          if (typeof value !== "string") {
            if (printed.indexOf("\n") !== -1) {
              printed = config2.spacingOuter + indentationNext + printed + config2.spacingOuter + indentation;
            }
            printed = "{" + printed + "}";
          }
          return config2.spacingInner + indentation + colors.prop.open + key + colors.prop.close + "=" + colors.value.open + printed + colors.value.close;
        }).join("");
      };
      const NodeTypeTextNode = 3;
      const printChildren = (children, config2, indentation, depth, refs, printer) => children.map((child) => {
        const printedChild = typeof child === "string" ? printText(child, config2) : printer(child, config2, indentation, depth, refs);
        if (printedChild === "" && typeof child === "object" && child !== null && child.nodeType !== NodeTypeTextNode) {
          return "";
        }
        return config2.spacingOuter + indentation + printedChild;
      }).join("");
      const printText = (text, config2) => {
        const contentColor = config2.colors.content;
        return contentColor.open + escapeHTML(text) + contentColor.close;
      };
      const printComment = (comment, config2) => {
        const commentColor = config2.colors.comment;
        return commentColor.open + "<!--" + escapeHTML(comment) + "-->" + commentColor.close;
      };
      const printElement = (type, printedProps, printedChildren, config2, indentation) => {
        const tagColor = config2.colors.tag;
        return tagColor.open + "<" + type + (printedProps && tagColor.close + printedProps + config2.spacingOuter + indentation + tagColor.open) + (printedChildren ? ">" + tagColor.close + printedChildren + config2.spacingOuter + indentation + tagColor.open + "</" + type : (printedProps && !config2.min ? "" : " ") + "/") + ">" + tagColor.close;
      };
      const printElementAsLeaf = (type, config2) => {
        const tagColor = config2.colors.tag;
        return tagColor.open + "<" + type + tagColor.close + " …" + tagColor.open + " />" + tagColor.close;
      };
      const ELEMENT_NODE$1 = 1;
      const TEXT_NODE$1 = 3;
      const COMMENT_NODE$1 = 8;
      const FRAGMENT_NODE = 11;
      const ELEMENT_REGEXP = /^((HTML|SVG)\w*)?Element$/;
      const isCustomElement = (val) => {
        const {
          tagName
        } = val;
        return Boolean(typeof tagName === "string" && tagName.includes("-") || typeof val.hasAttribute === "function" && val.hasAttribute("is"));
      };
      const testNode = (val) => {
        const constructorName = val.constructor.name;
        const {
          nodeType
        } = val;
        return nodeType === ELEMENT_NODE$1 && (ELEMENT_REGEXP.test(constructorName) || isCustomElement(val)) || nodeType === TEXT_NODE$1 && constructorName === "Text" || nodeType === COMMENT_NODE$1 && constructorName === "Comment" || nodeType === FRAGMENT_NODE && constructorName === "DocumentFragment";
      };
      function nodeIsText(node) {
        return node.nodeType === TEXT_NODE$1;
      }
      function nodeIsComment(node) {
        return node.nodeType === COMMENT_NODE$1;
      }
      function nodeIsFragment(node) {
        return node.nodeType === FRAGMENT_NODE;
      }
      function createDOMElementFilter(filterNode) {
        return {
          test: (val) => {
            var _val$constructor2;
            return ((val == null || (_val$constructor2 = val.constructor) == null ? void 0 : _val$constructor2.name) || isCustomElement(val)) && testNode(val);
          },
          serialize: (node, config2, indentation, depth, refs, printer) => {
            if (nodeIsText(node)) {
              return printText(node.data, config2);
            }
            if (nodeIsComment(node)) {
              return printComment(node.data, config2);
            }
            const type = nodeIsFragment(node) ? "DocumentFragment" : node.tagName.toLowerCase();
            if (++depth > config2.maxDepth) {
              return printElementAsLeaf(type, config2);
            }
            return printElement(type, printProps(nodeIsFragment(node) ? [] : Array.from(node.attributes).map((attr) => attr.name).sort(), nodeIsFragment(node) ? {} : Array.from(node.attributes).reduce((props, attribute) => {
              props[attribute.name] = attribute.value;
              return props;
            }, {}), config2, indentation + config2.indent, depth, refs, printer), printChildren(Array.prototype.slice.call(node.childNodes || node.children).filter(filterNode), config2, indentation + config2.indent, depth, refs, printer), config2, indentation);
          }
        };
      }
      let picocolors = null;
      let readFileSync = null;
      let codeFrameColumns = null;
      try {
        const nodeRequire = module && module.require;
        readFileSync = nodeRequire.call(module, "fs").readFileSync;
        codeFrameColumns = nodeRequire.call(module, "@babel/code-frame").codeFrameColumns;
        picocolors = nodeRequire.call(module, "picocolors");
      } catch {
      }
      function getCodeFrame(frame) {
        const locationStart = frame.indexOf("(") + 1;
        const locationEnd = frame.indexOf(")");
        const frameLocation = frame.slice(locationStart, locationEnd);
        const frameLocationElements = frameLocation.split(":");
        const [filename, line, column] = [frameLocationElements[0], parseInt(frameLocationElements[1], 10), parseInt(frameLocationElements[2], 10)];
        let rawFileContents = "";
        try {
          rawFileContents = readFileSync(filename, "utf-8");
        } catch {
          return "";
        }
        const codeFrame = codeFrameColumns(rawFileContents, {
          start: {
            line,
            column
          }
        }, {
          highlightCode: true,
          linesBelow: 0
        });
        return picocolors.dim(frameLocation) + "\n" + codeFrame + "\n";
      }
      function getUserCodeFrame() {
        if (!readFileSync || !codeFrameColumns) {
          return "";
        }
        const err = new Error();
        const firstClientCodeFrame = err.stack.split("\n").slice(1).find((frame) => !frame.includes("node_modules/"));
        return getCodeFrame(firstClientCodeFrame);
      }
      const TEXT_NODE = 3;
      function jestFakeTimersAreEnabled() {
        if (typeof jest !== "undefined" && jest !== null) {
          return (
            // legacy timers
            setTimeout._isMockFunction === true || // modern timers
            // eslint-disable-next-line prefer-object-has-own -- not supported by our support matrix
            Object.prototype.hasOwnProperty.call(setTimeout, "clock")
          );
        }
        return false;
      }
      function getDocument$1() {
        if (typeof window === "undefined") {
          throw new Error("Could not find default container");
        }
        return window.document;
      }
      function getWindowFromNode(node) {
        if (node.defaultView) {
          return node.defaultView;
        } else if (node.ownerDocument && node.ownerDocument.defaultView) {
          return node.ownerDocument.defaultView;
        } else if (node.window) {
          return node.window;
        } else if (node.ownerDocument && node.ownerDocument.defaultView === null) {
          throw new Error("It looks like the window object is not available for the provided node.");
        } else if (node.then instanceof Function) {
          throw new Error("It looks like you passed a Promise object instead of a DOM node. Did you do something like `fireEvent.click(screen.findBy...` when you meant to use a `getBy` query `fireEvent.click(screen.getBy...`, or await the findBy query `fireEvent.click(await screen.findBy...`?");
        } else if (Array.isArray(node)) {
          throw new Error("It looks like you passed an Array instead of a DOM node. Did you do something like `fireEvent.click(screen.getAllBy...` when you meant to use a `getBy` query `fireEvent.click(screen.getBy...`?");
        } else if (typeof node.debug === "function" && typeof node.logTestingPlaygroundURL === "function") {
          throw new Error("It looks like you passed a `screen` object. Did you do something like `fireEvent.click(screen, ...` when you meant to use a query, e.g. `fireEvent.click(screen.getBy..., `?");
        } else {
          throw new Error("The given node is not an Element, the node type is: " + typeof node + ".");
        }
      }
      function checkContainerType(container) {
        if (!container || !(typeof container.querySelector === "function") || !(typeof container.querySelectorAll === "function")) {
          throw new TypeError("Expected container to be an Element, a Document or a DocumentFragment but got " + getTypeName(container) + ".");
        }
        function getTypeName(object) {
          if (typeof object === "object") {
            return object === null ? "null" : object.constructor.name;
          }
          return typeof object;
        }
      }
      const shouldHighlight = () => {
        if (typeof process === "undefined") {
          return false;
        }
        let colors;
        try {
          var _process$env;
          const colorsJSON = (_process$env = define_process_env_default) == null ? void 0 : _process$env.COLORS;
          if (colorsJSON) {
            colors = JSON.parse(colorsJSON);
          }
        } catch {
        }
        if (typeof colors === "boolean") {
          return colors;
        } else {
          return process.versions !== void 0 && process.versions.node !== void 0;
        }
      };
      const {
        DOMCollection
      } = plugins_1;
      const ELEMENT_NODE = 1;
      const COMMENT_NODE = 8;
      function filterCommentsAndDefaultIgnoreTagsTags(value) {
        return value.nodeType !== COMMENT_NODE && (value.nodeType !== ELEMENT_NODE || !value.matches(getConfig().defaultIgnore));
      }
      function prettyDOM(dom, maxLength, options) {
        if (options === void 0) {
          options = {};
        }
        if (!dom) {
          dom = getDocument$1().body;
        }
        if (typeof maxLength !== "number") {
          maxLength = typeof process !== "undefined" && typeof define_process_env_default !== "undefined" && define_process_env_default.DEBUG_PRINT_LIMIT || 7e3;
        }
        if (maxLength === 0) {
          return "";
        }
        if (dom.documentElement) {
          dom = dom.documentElement;
        }
        let domTypeName = typeof dom;
        if (domTypeName === "object") {
          domTypeName = dom.constructor.name;
        } else {
          dom = {};
        }
        if (!("outerHTML" in dom)) {
          throw new TypeError("Expected an element or document but got " + domTypeName);
        }
        const {
          filterNode = filterCommentsAndDefaultIgnoreTagsTags,
          ...prettyFormatOptions
        } = options;
        const debugContent = format_1(dom, {
          plugins: [createDOMElementFilter(filterNode), DOMCollection],
          printFunctionName: false,
          highlight: shouldHighlight(),
          ...prettyFormatOptions
        });
        return maxLength !== void 0 && dom.outerHTML.length > maxLength ? debugContent.slice(0, maxLength) + "..." : debugContent;
      }
      const logDOM = function() {
        const userCodeFrame = getUserCodeFrame();
        if (userCodeFrame) {
          console.log(prettyDOM(...arguments) + "\n\n" + userCodeFrame);
        } else {
          console.log(prettyDOM(...arguments));
        }
      };
      let config = {
        testIdAttribute: "data-testid",
        asyncUtilTimeout: 1e3,
        // asyncWrapper and advanceTimersWrapper is to support React's async `act` function.
        // forcing react-testing-library to wrap all async functions would've been
        // a total nightmare (consider wrapping every findBy* query and then also
        // updating `within` so those would be wrapped too. Total nightmare).
        // so we have this config option that's really only intended for
        // react-testing-library to use. For that reason, this feature will remain
        // undocumented.
        asyncWrapper: (cb) => cb(),
        unstable_advanceTimersWrapper: (cb) => cb(),
        eventWrapper: (cb) => cb(),
        // default value for the `hidden` option in `ByRole` queries
        defaultHidden: false,
        // default value for the `ignore` option in `ByText` queries
        defaultIgnore: "script, style",
        // showOriginalStackTrace flag to show the full error stack traces for async errors
        showOriginalStackTrace: false,
        // throw errors w/ suggestions for better queries. Opt in so off by default.
        throwSuggestions: false,
        // called when getBy* queries fail. (message, container) => Error
        getElementError(message, container) {
          const prettifiedDOM = prettyDOM(container);
          const error = new Error([message, "Ignored nodes: comments, " + config.defaultIgnore + "\n" + prettifiedDOM].filter(Boolean).join("\n\n"));
          error.name = "TestingLibraryElementError";
          return error;
        },
        _disableExpensiveErrorDiagnostics: false,
        computedStyleSupportsPseudoElements: false
      };
      function runWithExpensiveErrorDiagnosticsDisabled(callback) {
        try {
          config._disableExpensiveErrorDiagnostics = true;
          return callback();
        } finally {
          config._disableExpensiveErrorDiagnostics = false;
        }
      }
      function getConfig() {
        return config;
      }
      const labelledNodeNames = ["button", "meter", "output", "progress", "select", "textarea", "input"];
      function getTextContent(node) {
        if (labelledNodeNames.includes(node.nodeName.toLowerCase())) {
          return "";
        }
        if (node.nodeType === TEXT_NODE) return node.textContent;
        return Array.from(node.childNodes).map((childNode) => getTextContent(childNode)).join("");
      }
      function getLabelContent(element) {
        let textContent;
        if (element.tagName.toLowerCase() === "label") {
          textContent = getTextContent(element);
        } else {
          textContent = element.value || element.textContent;
        }
        return textContent;
      }
      function getRealLabels(element) {
        if (element.labels !== void 0) {
          var _labels;
          return (_labels = element.labels) != null ? _labels : [];
        }
        if (!isLabelable(element)) return [];
        const labels = element.ownerDocument.querySelectorAll("label");
        return Array.from(labels).filter((label) => label.control === element);
      }
      function isLabelable(element) {
        return /BUTTON|METER|OUTPUT|PROGRESS|SELECT|TEXTAREA/.test(element.tagName) || element.tagName === "INPUT" && element.getAttribute("type") !== "hidden";
      }
      function getLabels(container, element, _temp) {
        let {
          selector = "*"
        } = _temp === void 0 ? {} : _temp;
        const ariaLabelledBy = element.getAttribute("aria-labelledby");
        const labelsId = ariaLabelledBy ? ariaLabelledBy.split(" ") : [];
        return labelsId.length ? labelsId.map((labelId) => {
          const labellingElement = container.querySelector('[id="' + labelId + '"]');
          return labellingElement ? {
            content: getLabelContent(labellingElement),
            formControl: null
          } : {
            content: "",
            formControl: null
          };
        }) : Array.from(getRealLabels(element)).map((label) => {
          const textToMatch = getLabelContent(label);
          const formControlSelector = "button, input, meter, output, progress, select, textarea";
          const labelledFormControl = Array.from(label.querySelectorAll(formControlSelector)).filter((formControlElement) => formControlElement.matches(selector))[0];
          return {
            content: textToMatch,
            formControl: labelledFormControl
          };
        });
      }
      function assertNotNullOrUndefined(matcher) {
        if (matcher === null || matcher === void 0) {
          throw new Error(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions -- implicitly converting `T` to `string`
            "It looks like " + matcher + " was passed instead of a matcher. Did you do something like getByText(" + matcher + ")?"
          );
        }
      }
      function fuzzyMatches(textToMatch, node, matcher, normalizer) {
        if (typeof textToMatch !== "string") {
          return false;
        }
        assertNotNullOrUndefined(matcher);
        const normalizedText = normalizer(textToMatch);
        if (typeof matcher === "string" || typeof matcher === "number") {
          return normalizedText.toLowerCase().includes(matcher.toString().toLowerCase());
        } else if (typeof matcher === "function") {
          return matcher(normalizedText, node);
        } else {
          return matchRegExp(matcher, normalizedText);
        }
      }
      function matches(textToMatch, node, matcher, normalizer) {
        if (typeof textToMatch !== "string") {
          return false;
        }
        assertNotNullOrUndefined(matcher);
        const normalizedText = normalizer(textToMatch);
        if (matcher instanceof Function) {
          return matcher(normalizedText, node);
        } else if (matcher instanceof RegExp) {
          return matchRegExp(matcher, normalizedText);
        } else {
          return normalizedText === String(matcher);
        }
      }
      function getDefaultNormalizer(_temp) {
        let {
          trim = true,
          collapseWhitespace = true
        } = _temp === void 0 ? {} : _temp;
        return (text) => {
          let normalizedText = text;
          normalizedText = trim ? normalizedText.trim() : normalizedText;
          normalizedText = collapseWhitespace ? normalizedText.replace(/\s+/g, " ") : normalizedText;
          return normalizedText;
        };
      }
      function makeNormalizer(_ref) {
        let {
          trim,
          collapseWhitespace,
          normalizer
        } = _ref;
        if (!normalizer) {
          return getDefaultNormalizer({
            trim,
            collapseWhitespace
          });
        }
        if (typeof trim !== "undefined" || typeof collapseWhitespace !== "undefined") {
          throw new Error('trim and collapseWhitespace are not supported with a normalizer. If you want to use the default trim and collapseWhitespace logic in your normalizer, use "getDefaultNormalizer({trim, collapseWhitespace})" and compose that into your normalizer');
        }
        return normalizer;
      }
      function matchRegExp(matcher, text) {
        const match = matcher.test(text);
        if (matcher.global && matcher.lastIndex !== 0) {
          console.warn("To match all elements we had to reset the lastIndex of the RegExp because the global flag is enabled. We encourage to remove the global flag from the RegExp.");
          matcher.lastIndex = 0;
        }
        return match;
      }
      function getNodeText(node) {
        if (node.matches("input[type=submit], input[type=button], input[type=reset]")) {
          return node.value;
        }
        return Array.from(node.childNodes).filter((child) => child.nodeType === TEXT_NODE && Boolean(child.textContent)).map((c) => c.textContent).join("");
      }
      const elementRoleList = buildElementRoleList(elementRoles_1);
      function isSubtreeInaccessible(element) {
        if (element.hidden === true) {
          return true;
        }
        if (element.getAttribute("aria-hidden") === "true") {
          return true;
        }
        const window2 = element.ownerDocument.defaultView;
        if (window2.getComputedStyle(element).display === "none") {
          return true;
        }
        return false;
      }
      function isInaccessible(element, options) {
        if (options === void 0) {
          options = {};
        }
        const {
          isSubtreeInaccessible: isSubtreeInaccessibleImpl = isSubtreeInaccessible
        } = options;
        const window2 = element.ownerDocument.defaultView;
        if (window2.getComputedStyle(element).visibility === "hidden") {
          return true;
        }
        let currentElement = element;
        while (currentElement) {
          if (isSubtreeInaccessibleImpl(currentElement)) {
            return true;
          }
          currentElement = currentElement.parentElement;
        }
        return false;
      }
      function getImplicitAriaRoles(currentNode) {
        for (const {
          match,
          roles: roles2
        } of elementRoleList) {
          if (match(currentNode)) {
            return [...roles2];
          }
        }
        return [];
      }
      function buildElementRoleList(elementRolesMap) {
        function makeElementSelector(_ref) {
          let {
            name,
            attributes
          } = _ref;
          return "" + name + attributes.map((_ref2) => {
            let {
              name: attributeName,
              value,
              constraints = []
            } = _ref2;
            const shouldNotExist = constraints.indexOf("undefined") !== -1;
            const shouldBeNonEmpty = constraints.indexOf("set") !== -1;
            const hasExplicitValue = typeof value !== "undefined";
            if (hasExplicitValue) {
              return "[" + attributeName + '="' + value + '"]';
            } else if (shouldNotExist) {
              return ":not([" + attributeName + "])";
            } else if (shouldBeNonEmpty) {
              return "[" + attributeName + "]:not([" + attributeName + '=""])';
            }
            return "[" + attributeName + "]";
          }).join("");
        }
        function getSelectorSpecificity(_ref3) {
          let {
            attributes = []
          } = _ref3;
          return attributes.length;
        }
        function bySelectorSpecificity(_ref4, _ref5) {
          let {
            specificity: leftSpecificity
          } = _ref4;
          let {
            specificity: rightSpecificity
          } = _ref5;
          return rightSpecificity - leftSpecificity;
        }
        function match(element) {
          let {
            attributes = []
          } = element;
          const typeTextIndex = attributes.findIndex((attribute) => attribute.value && attribute.name === "type" && attribute.value === "text");
          if (typeTextIndex >= 0) {
            attributes = [...attributes.slice(0, typeTextIndex), ...attributes.slice(typeTextIndex + 1)];
          }
          const selector = makeElementSelector({
            ...element,
            attributes
          });
          return (node) => {
            if (typeTextIndex >= 0 && node.type !== "text") {
              return false;
            }
            return node.matches(selector);
          };
        }
        let result = [];
        for (const [element, roles2] of elementRolesMap.entries()) {
          result = [...result, {
            match: match(element),
            roles: Array.from(roles2),
            specificity: getSelectorSpecificity(element)
          }];
        }
        return result.sort(bySelectorSpecificity);
      }
      function getRoles(container, _temp) {
        let {
          hidden = false
        } = _temp === void 0 ? {} : _temp;
        function flattenDOM(node) {
          return [node, ...Array.from(node.children).reduce((acc, child) => [...acc, ...flattenDOM(child)], [])];
        }
        return flattenDOM(container).filter((element) => {
          return hidden === false ? isInaccessible(element) === false : true;
        }).reduce((acc, node) => {
          let roles2 = [];
          if (node.hasAttribute("role")) {
            roles2 = node.getAttribute("role").split(" ").slice(0, 1);
          } else {
            roles2 = getImplicitAriaRoles(node);
          }
          return roles2.reduce((rolesAcc, role) => Array.isArray(rolesAcc[role]) ? {
            ...rolesAcc,
            [role]: [...rolesAcc[role], node]
          } : {
            ...rolesAcc,
            [role]: [node]
          }, acc);
        }, {});
      }
      function prettyRoles(dom, _ref6) {
        let {
          hidden,
          includeDescription
        } = _ref6;
        const roles2 = getRoles(dom, {
          hidden
        });
        return Object.entries(roles2).filter((_ref7) => {
          let [role] = _ref7;
          return role !== "generic";
        }).map((_ref8) => {
          let [role, elements] = _ref8;
          const delimiterBar = "-".repeat(50);
          const elementsString = elements.map((el) => {
            const nameString = 'Name "' + computeAccessibleName(el, {
              computedStyleSupportsPseudoElements: getConfig().computedStyleSupportsPseudoElements
            }) + '":\n';
            const domString = prettyDOM(el.cloneNode(false));
            if (includeDescription) {
              const descriptionString = 'Description "' + computeAccessibleDescription(el, {
                computedStyleSupportsPseudoElements: getConfig().computedStyleSupportsPseudoElements
              }) + '":\n';
              return "" + nameString + descriptionString + domString;
            }
            return "" + nameString + domString;
          }).join("\n\n");
          return role + ":\n\n" + elementsString + "\n\n" + delimiterBar;
        }).join("\n");
      }
      function computeAriaSelected(element) {
        if (element.tagName === "OPTION") {
          return element.selected;
        }
        return checkBooleanAttribute(element, "aria-selected");
      }
      function computeAriaBusy(element) {
        return element.getAttribute("aria-busy") === "true";
      }
      function computeAriaChecked(element) {
        if ("indeterminate" in element && element.indeterminate) {
          return void 0;
        }
        if ("checked" in element) {
          return element.checked;
        }
        return checkBooleanAttribute(element, "aria-checked");
      }
      function computeAriaPressed(element) {
        return checkBooleanAttribute(element, "aria-pressed");
      }
      function computeAriaCurrent(element) {
        var _ref9, _checkBooleanAttribut;
        return (_ref9 = (_checkBooleanAttribut = checkBooleanAttribute(element, "aria-current")) != null ? _checkBooleanAttribut : element.getAttribute("aria-current")) != null ? _ref9 : false;
      }
      function computeAriaExpanded(element) {
        return checkBooleanAttribute(element, "aria-expanded");
      }
      function checkBooleanAttribute(element, attribute) {
        const attributeValue = element.getAttribute(attribute);
        if (attributeValue === "true") {
          return true;
        }
        if (attributeValue === "false") {
          return false;
        }
        return void 0;
      }
      function computeHeadingLevel(element) {
        const implicitHeadingLevels = {
          H1: 1,
          H2: 2,
          H3: 3,
          H4: 4,
          H5: 5,
          H6: 6
        };
        const ariaLevelAttribute = element.getAttribute("aria-level") && Number(element.getAttribute("aria-level"));
        return ariaLevelAttribute || implicitHeadingLevels[element.tagName];
      }
      function computeAriaValueNow(element) {
        const valueNow = element.getAttribute("aria-valuenow");
        return valueNow === null ? void 0 : +valueNow;
      }
      function computeAriaValueMax(element) {
        const valueMax = element.getAttribute("aria-valuemax");
        return valueMax === null ? void 0 : +valueMax;
      }
      function computeAriaValueMin(element) {
        const valueMin = element.getAttribute("aria-valuemin");
        return valueMin === null ? void 0 : +valueMin;
      }
      function computeAriaValueText(element) {
        const valueText = element.getAttribute("aria-valuetext");
        return valueText === null ? void 0 : valueText;
      }
      const normalize$1 = getDefaultNormalizer();
      function escapeRegExp(string) {
        return string.replace(/[.*+\-?^${}()|[\]\\]/g, "\\$&");
      }
      function getRegExpMatcher(string) {
        return new RegExp(escapeRegExp(string.toLowerCase()), "i");
      }
      function makeSuggestion(queryName, element, content, _ref) {
        let {
          variant,
          name
        } = _ref;
        let warning = "";
        const queryOptions = {};
        const queryArgs = [["Role", "TestId"].includes(queryName) ? content : getRegExpMatcher(content)];
        if (name) {
          queryOptions.name = getRegExpMatcher(name);
        }
        if (queryName === "Role" && isInaccessible(element)) {
          queryOptions.hidden = true;
          warning = "Element is inaccessible. This means that the element and all its children are invisible to screen readers.\n    If you are using the aria-hidden prop, make sure this is the right choice for your case.\n    ";
        }
        if (Object.keys(queryOptions).length > 0) {
          queryArgs.push(queryOptions);
        }
        const queryMethod = variant + "By" + queryName;
        return {
          queryName,
          queryMethod,
          queryArgs,
          variant,
          warning,
          toString() {
            if (warning) {
              console.warn(warning);
            }
            let [text, options] = queryArgs;
            text = typeof text === "string" ? "'" + text + "'" : text;
            options = options ? ", { " + Object.entries(options).map((_ref2) => {
              let [k, v] = _ref2;
              return k + ": " + v;
            }).join(", ") + " }" : "";
            return queryMethod + "(" + text + options + ")";
          }
        };
      }
      function canSuggest(currentMethod, requestedMethod, data) {
        return data && (true);
      }
      function getSuggestedQuery(element, variant, method) {
        var _element$getAttribute, _getImplicitAriaRoles;
        if (variant === void 0) {
          variant = "get";
        }
        if (element.matches(getConfig().defaultIgnore)) {
          return void 0;
        }
        const role = (_element$getAttribute = element.getAttribute("role")) != null ? _element$getAttribute : (_getImplicitAriaRoles = getImplicitAriaRoles(element)) == null ? void 0 : _getImplicitAriaRoles[0];
        if (role !== "generic" && canSuggest("Role", method, role)) {
          return makeSuggestion("Role", element, role, {
            variant,
            name: computeAccessibleName(element, {
              computedStyleSupportsPseudoElements: getConfig().computedStyleSupportsPseudoElements
            })
          });
        }
        const labelText = getLabels(document, element).map((label) => label.content).join(" ");
        if (canSuggest("LabelText", method, labelText)) {
          return makeSuggestion("LabelText", element, labelText, {
            variant
          });
        }
        const placeholderText = element.getAttribute("placeholder");
        if (canSuggest("PlaceholderText", method, placeholderText)) {
          return makeSuggestion("PlaceholderText", element, placeholderText, {
            variant
          });
        }
        const textContent = normalize$1(getNodeText(element));
        if (canSuggest("Text", method, textContent)) {
          return makeSuggestion("Text", element, textContent, {
            variant
          });
        }
        if (canSuggest("DisplayValue", method, element.value)) {
          return makeSuggestion("DisplayValue", element, normalize$1(element.value), {
            variant
          });
        }
        const alt = element.getAttribute("alt");
        if (canSuggest("AltText", method, alt)) {
          return makeSuggestion("AltText", element, alt, {
            variant
          });
        }
        const title = element.getAttribute("title");
        if (canSuggest("Title", method, title)) {
          return makeSuggestion("Title", element, title, {
            variant
          });
        }
        const testId = element.getAttribute(getConfig().testIdAttribute);
        if (canSuggest("TestId", method, testId)) {
          return makeSuggestion("TestId", element, testId, {
            variant
          });
        }
        return void 0;
      }
      function copyStackTrace(target, source) {
        target.stack = source.stack.replace(source.message, target.message);
      }
      function waitFor(callback, _ref) {
        let {
          container = getDocument$1(),
          timeout = getConfig().asyncUtilTimeout,
          showOriginalStackTrace = getConfig().showOriginalStackTrace,
          stackTraceError,
          interval = 50,
          onTimeout = (error) => {
            Object.defineProperty(error, "message", {
              value: getConfig().getElementError(error.message, container).message
            });
            return error;
          },
          mutationObserverOptions = {
            subtree: true,
            childList: true,
            attributes: true,
            characterData: true
          }
        } = _ref;
        if (typeof callback !== "function") {
          throw new TypeError("Received `callback` arg must be a function");
        }
        return new Promise(async (resolve, reject) => {
          let lastError, intervalId, observer;
          let finished = false;
          let promiseStatus = "idle";
          const overallTimeoutTimer = setTimeout(handleTimeout, timeout);
          const usingJestFakeTimers = jestFakeTimersAreEnabled();
          if (usingJestFakeTimers) {
            const {
              unstable_advanceTimersWrapper: advanceTimersWrapper
            } = getConfig();
            checkCallback();
            while (!finished) {
              if (!jestFakeTimersAreEnabled()) {
                const error = new Error("Changed from using fake timers to real timers while using waitFor. This is not allowed and will result in very strange behavior. Please ensure you're awaiting all async things your test is doing before changing to real timers. For more info, please go to https://github.com/testing-library/dom-testing-library/issues/830");
                if (!showOriginalStackTrace) copyStackTrace(error, stackTraceError);
                reject(error);
                return;
              }
              await advanceTimersWrapper(async () => {
                jest.advanceTimersByTime(interval);
              });
              if (finished) {
                break;
              }
              checkCallback();
            }
          } else {
            try {
              checkContainerType(container);
            } catch (e) {
              reject(e);
              return;
            }
            intervalId = setInterval(checkRealTimersCallback, interval);
            const {
              MutationObserver
            } = getWindowFromNode(container);
            observer = new MutationObserver(checkRealTimersCallback);
            observer.observe(container, mutationObserverOptions);
            checkCallback();
          }
          function onDone(error, result) {
            finished = true;
            clearTimeout(overallTimeoutTimer);
            if (!usingJestFakeTimers) {
              clearInterval(intervalId);
              observer.disconnect();
            }
            if (error) {
              reject(error);
            } else {
              resolve(result);
            }
          }
          function checkRealTimersCallback() {
            if (jestFakeTimersAreEnabled()) {
              const error = new Error("Changed from using real timers to fake timers while using waitFor. This is not allowed and will result in very strange behavior. Please ensure you're awaiting all async things your test is doing before changing to fake timers. For more info, please go to https://github.com/testing-library/dom-testing-library/issues/830");
              if (!showOriginalStackTrace) copyStackTrace(error, stackTraceError);
              return reject(error);
            } else {
              return checkCallback();
            }
          }
          function checkCallback() {
            if (promiseStatus === "pending") return;
            try {
              const result = runWithExpensiveErrorDiagnosticsDisabled(callback);
              if (typeof (result == null ? void 0 : result.then) === "function") {
                promiseStatus = "pending";
                result.then((resolvedValue) => {
                  promiseStatus = "resolved";
                  onDone(null, resolvedValue);
                }, (rejectedValue) => {
                  promiseStatus = "rejected";
                  lastError = rejectedValue;
                });
              } else {
                onDone(null, result);
              }
            } catch (error) {
              lastError = error;
            }
          }
          function handleTimeout() {
            let error;
            if (lastError) {
              error = lastError;
              if (!showOriginalStackTrace && error.name === "TestingLibraryElementError") {
                copyStackTrace(error, stackTraceError);
              }
            } else {
              error = new Error("Timed out in waitFor.");
              if (!showOriginalStackTrace) {
                copyStackTrace(error, stackTraceError);
              }
            }
            onDone(onTimeout(error), null);
          }
        });
      }
      function waitForWrapper(callback, options) {
        const stackTraceError = new Error("STACK_TRACE_MESSAGE");
        return getConfig().asyncWrapper(() => waitFor(callback, {
          stackTraceError,
          ...options
        }));
      }
      function getElementError(message, container) {
        return getConfig().getElementError(message, container);
      }
      function getMultipleElementsFoundError(message, container) {
        return getElementError(message + "\n\n(If this is intentional, then use the `*AllBy*` variant of the query (like `queryAllByText`, `getAllByText`, or `findAllByText`)).", container);
      }
      function queryAllByAttribute(attribute, container, text, _temp) {
        let {
          exact = true,
          collapseWhitespace,
          trim,
          normalizer
        } = _temp === void 0 ? {} : _temp;
        const matcher = exact ? matches : fuzzyMatches;
        const matchNormalizer = makeNormalizer({
          collapseWhitespace,
          trim,
          normalizer
        });
        return Array.from(container.querySelectorAll("[" + attribute + "]")).filter((node) => matcher(node.getAttribute(attribute), node, text, matchNormalizer));
      }
      function makeSingleQuery(allQuery, getMultipleError2) {
        return function(container) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }
          const els = allQuery(container, ...args);
          if (els.length > 1) {
            const elementStrings = els.map((element) => getElementError(null, element).message).join("\n\n");
            throw getMultipleElementsFoundError(getMultipleError2(container, ...args) + "\n\nHere are the matching elements:\n\n" + elementStrings, container);
          }
          return els[0] || null;
        };
      }
      function getSuggestionError(suggestion, container) {
        return getConfig().getElementError("A better query is available, try this:\n" + suggestion.toString() + "\n", container);
      }
      function makeGetAllQuery(allQuery, getMissingError2) {
        return function(container) {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }
          const els = allQuery(container, ...args);
          if (!els.length) {
            throw getConfig().getElementError(getMissingError2(container, ...args), container);
          }
          return els;
        };
      }
      function makeFindQuery(getter) {
        return (container, text, options, waitForOptions) => {
          return waitForWrapper(() => {
            return getter(container, text, options);
          }, {
            container,
            ...waitForOptions
          });
        };
      }
      const wrapSingleQueryWithSuggestion = (query, queryAllByName, variant) => function(container) {
        for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
          args[_key3 - 1] = arguments[_key3];
        }
        const element = query(container, ...args);
        const [{
          suggest = getConfig().throwSuggestions
        } = {}] = args.slice(-1);
        if (element && suggest) {
          const suggestion = getSuggestedQuery(element, variant);
          if (suggestion && !queryAllByName.endsWith(suggestion.queryName)) {
            throw getSuggestionError(suggestion.toString(), container);
          }
        }
        return element;
      };
      const wrapAllByQueryWithSuggestion = (query, queryAllByName, variant) => function(container) {
        for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
          args[_key4 - 1] = arguments[_key4];
        }
        const els = query(container, ...args);
        const [{
          suggest = getConfig().throwSuggestions
        } = {}] = args.slice(-1);
        if (els.length && suggest) {
          const uniqueSuggestionMessages = [...new Set(els.map((element) => {
            var _getSuggestedQuery;
            return (_getSuggestedQuery = getSuggestedQuery(element, variant)) == null ? void 0 : _getSuggestedQuery.toString();
          }))];
          if (
            // only want to suggest if all the els have the same suggestion.
            uniqueSuggestionMessages.length === 1 && !queryAllByName.endsWith(
              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- TODO: Can this be null at runtime?
              getSuggestedQuery(els[0], variant).queryName
            )
          ) {
            throw getSuggestionError(uniqueSuggestionMessages[0], container);
          }
        }
        return els;
      };
      function buildQueries(queryAllBy, getMultipleError2, getMissingError2) {
        const queryBy = wrapSingleQueryWithSuggestion(makeSingleQuery(queryAllBy, getMultipleError2), queryAllBy.name, "query");
        const getAllBy = makeGetAllQuery(queryAllBy, getMissingError2);
        const getBy = makeSingleQuery(getAllBy, getMultipleError2);
        const getByWithSuggestions = wrapSingleQueryWithSuggestion(getBy, queryAllBy.name, "get");
        const getAllWithSuggestions = wrapAllByQueryWithSuggestion(getAllBy, queryAllBy.name.replace("query", "get"), "getAll");
        const findAllBy = makeFindQuery(wrapAllByQueryWithSuggestion(getAllBy, queryAllBy.name, "findAll"));
        const findBy = makeFindQuery(wrapSingleQueryWithSuggestion(getBy, queryAllBy.name, "find"));
        return [queryBy, getAllWithSuggestions, getByWithSuggestions, findAllBy, findBy];
      }
      function queryAllLabels(container) {
        return Array.from(container.querySelectorAll("label,input")).map((node) => {
          return {
            node,
            textToMatch: getLabelContent(node)
          };
        }).filter((_ref) => {
          let {
            textToMatch
          } = _ref;
          return textToMatch !== null;
        });
      }
      const queryAllLabelsByText = function(container, text, _temp) {
        let {
          exact = true,
          trim,
          collapseWhitespace,
          normalizer
        } = _temp === void 0 ? {} : _temp;
        const matcher = exact ? matches : fuzzyMatches;
        const matchNormalizer = makeNormalizer({
          collapseWhitespace,
          trim,
          normalizer
        });
        const textToMatchByLabels = queryAllLabels(container);
        return textToMatchByLabels.filter((_ref2) => {
          let {
            node,
            textToMatch
          } = _ref2;
          return matcher(textToMatch, node, text, matchNormalizer);
        }).map((_ref3) => {
          let {
            node
          } = _ref3;
          return node;
        });
      };
      const queryAllByLabelText = function(container, text, _temp2) {
        let {
          selector = "*",
          exact = true,
          collapseWhitespace,
          trim,
          normalizer
        } = _temp2 === void 0 ? {} : _temp2;
        checkContainerType(container);
        const matcher = exact ? matches : fuzzyMatches;
        const matchNormalizer = makeNormalizer({
          collapseWhitespace,
          trim,
          normalizer
        });
        const matchingLabelledElements = Array.from(container.querySelectorAll("*")).filter((element) => {
          return getRealLabels(element).length || element.hasAttribute("aria-labelledby");
        }).reduce((labelledElements, labelledElement) => {
          const labelList = getLabels(container, labelledElement, {
            selector
          });
          labelList.filter((label) => Boolean(label.formControl)).forEach((label) => {
            if (matcher(label.content, label.formControl, text, matchNormalizer) && label.formControl) {
              labelledElements.push(label.formControl);
            }
          });
          const labelsValue = labelList.filter((label) => Boolean(label.content)).map((label) => label.content);
          if (matcher(labelsValue.join(" "), labelledElement, text, matchNormalizer)) {
            labelledElements.push(labelledElement);
          }
          if (labelsValue.length > 1) {
            labelsValue.forEach((labelValue, index) => {
              if (matcher(labelValue, labelledElement, text, matchNormalizer)) {
                labelledElements.push(labelledElement);
              }
              const labelsFiltered = [...labelsValue];
              labelsFiltered.splice(index, 1);
              if (labelsFiltered.length > 1) {
                if (matcher(labelsFiltered.join(" "), labelledElement, text, matchNormalizer)) {
                  labelledElements.push(labelledElement);
                }
              }
            });
          }
          return labelledElements;
        }, []).concat(queryAllByAttribute("aria-label", container, text, {
          exact,
          normalizer: matchNormalizer
        }));
        return Array.from(new Set(matchingLabelledElements)).filter((element) => element.matches(selector));
      };
      const getAllByLabelText = function(container, text) {
        for (var _len = arguments.length, rest = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          rest[_key - 2] = arguments[_key];
        }
        const els = queryAllByLabelText(container, text, ...rest);
        if (!els.length) {
          const labels = queryAllLabelsByText(container, text, ...rest);
          if (labels.length) {
            const tagNames = labels.map((label) => getTagNameOfElementAssociatedWithLabelViaFor(container, label)).filter((tagName) => !!tagName);
            if (tagNames.length) {
              throw getConfig().getElementError(tagNames.map((tagName) => "Found a label with the text of: " + text + ", however the element associated with this label (<" + tagName + " />) is non-labellable [https://html.spec.whatwg.org/multipage/forms.html#category-label]. If you really need to label a <" + tagName + " />, you can use aria-label or aria-labelledby instead.").join("\n\n"), container);
            } else {
              throw getConfig().getElementError("Found a label with the text of: " + text + `, however no form control was found associated to that label. Make sure you're using the "for" attribute or "aria-labelledby" attribute correctly.`, container);
            }
          } else {
            throw getConfig().getElementError("Unable to find a label with the text of: " + text, container);
          }
        }
        return els;
      };
      function getTagNameOfElementAssociatedWithLabelViaFor(container, label) {
        const htmlFor = label.getAttribute("for");
        if (!htmlFor) {
          return null;
        }
        const element = container.querySelector('[id="' + htmlFor + '"]');
        return element ? element.tagName.toLowerCase() : null;
      }
      const getMultipleError$7 = (c, text) => "Found multiple elements with the text of: " + text;
      const queryByLabelText = wrapSingleQueryWithSuggestion(makeSingleQuery(queryAllByLabelText, getMultipleError$7), queryAllByLabelText.name, "query");
      const getByLabelText = makeSingleQuery(getAllByLabelText, getMultipleError$7);
      const findAllByLabelText = makeFindQuery(wrapAllByQueryWithSuggestion(getAllByLabelText, getAllByLabelText.name, "findAll"));
      const findByLabelText = makeFindQuery(wrapSingleQueryWithSuggestion(getByLabelText, getAllByLabelText.name, "find"));
      const getAllByLabelTextWithSuggestions = wrapAllByQueryWithSuggestion(getAllByLabelText, getAllByLabelText.name, "getAll");
      const getByLabelTextWithSuggestions = wrapSingleQueryWithSuggestion(getByLabelText, getAllByLabelText.name, "get");
      const queryAllByLabelTextWithSuggestions = wrapAllByQueryWithSuggestion(queryAllByLabelText, queryAllByLabelText.name, "queryAll");
      const queryAllByPlaceholderText = function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        checkContainerType(args[0]);
        return queryAllByAttribute("placeholder", ...args);
      };
      const getMultipleError$6 = (c, text) => "Found multiple elements with the placeholder text of: " + text;
      const getMissingError$6 = (c, text) => "Unable to find an element with the placeholder text of: " + text;
      const queryAllByPlaceholderTextWithSuggestions = wrapAllByQueryWithSuggestion(queryAllByPlaceholderText, queryAllByPlaceholderText.name, "queryAll");
      const [queryByPlaceholderText, getAllByPlaceholderText, getByPlaceholderText, findAllByPlaceholderText, findByPlaceholderText] = buildQueries(queryAllByPlaceholderText, getMultipleError$6, getMissingError$6);
      const queryAllByText = function(container, text, _temp) {
        let {
          selector = "*",
          exact = true,
          collapseWhitespace,
          trim,
          ignore = getConfig().defaultIgnore,
          normalizer
        } = _temp === void 0 ? {} : _temp;
        checkContainerType(container);
        const matcher = exact ? matches : fuzzyMatches;
        const matchNormalizer = makeNormalizer({
          collapseWhitespace,
          trim,
          normalizer
        });
        let baseArray = [];
        if (typeof container.matches === "function" && container.matches(selector)) {
          baseArray = [container];
        }
        return [...baseArray, ...Array.from(container.querySelectorAll(selector))].filter((node) => !ignore || !node.matches(ignore)).filter((node) => matcher(getNodeText(node), node, text, matchNormalizer));
      };
      const getMultipleError$5 = (c, text) => "Found multiple elements with the text: " + text;
      const getMissingError$5 = function(c, text, options) {
        if (options === void 0) {
          options = {};
        }
        const {
          collapseWhitespace,
          trim,
          normalizer,
          selector
        } = options;
        const matchNormalizer = makeNormalizer({
          collapseWhitespace,
          trim,
          normalizer
        });
        const normalizedText = matchNormalizer(text.toString());
        const isNormalizedDifferent = normalizedText !== text.toString();
        const isCustomSelector = (selector != null ? selector : "*") !== "*";
        return "Unable to find an element with the text: " + (isNormalizedDifferent ? normalizedText + " (normalized from '" + text + "')" : text) + (isCustomSelector ? ", which matches selector '" + selector + "'" : "") + ". This could be because the text is broken up by multiple elements. In this case, you can provide a function for your text matcher to make your matcher more flexible.";
      };
      const queryAllByTextWithSuggestions = wrapAllByQueryWithSuggestion(queryAllByText, queryAllByText.name, "queryAll");
      const [queryByText, getAllByText, getByText, findAllByText, findByText] = buildQueries(queryAllByText, getMultipleError$5, getMissingError$5);
      const queryAllByDisplayValue = function(container, value, _temp) {
        let {
          exact = true,
          collapseWhitespace,
          trim,
          normalizer
        } = _temp === void 0 ? {} : _temp;
        checkContainerType(container);
        const matcher = exact ? matches : fuzzyMatches;
        const matchNormalizer = makeNormalizer({
          collapseWhitespace,
          trim,
          normalizer
        });
        return Array.from(container.querySelectorAll("input,textarea,select")).filter((node) => {
          if (node.tagName === "SELECT") {
            const selectedOptions = Array.from(node.options).filter((option) => option.selected);
            return selectedOptions.some((optionNode) => matcher(getNodeText(optionNode), optionNode, value, matchNormalizer));
          } else {
            return matcher(node.value, node, value, matchNormalizer);
          }
        });
      };
      const getMultipleError$4 = (c, value) => "Found multiple elements with the display value: " + value + ".";
      const getMissingError$4 = (c, value) => "Unable to find an element with the display value: " + value + ".";
      const queryAllByDisplayValueWithSuggestions = wrapAllByQueryWithSuggestion(queryAllByDisplayValue, queryAllByDisplayValue.name, "queryAll");
      const [queryByDisplayValue, getAllByDisplayValue, getByDisplayValue, findAllByDisplayValue, findByDisplayValue] = buildQueries(queryAllByDisplayValue, getMultipleError$4, getMissingError$4);
      const VALID_TAG_REGEXP = /^(img|input|area|.+-.+)$/i;
      const queryAllByAltText = function(container, alt, options) {
        if (options === void 0) {
          options = {};
        }
        checkContainerType(container);
        return queryAllByAttribute("alt", container, alt, options).filter((node) => VALID_TAG_REGEXP.test(node.tagName));
      };
      const getMultipleError$3 = (c, alt) => "Found multiple elements with the alt text: " + alt;
      const getMissingError$3 = (c, alt) => "Unable to find an element with the alt text: " + alt;
      const queryAllByAltTextWithSuggestions = wrapAllByQueryWithSuggestion(queryAllByAltText, queryAllByAltText.name, "queryAll");
      const [queryByAltText, getAllByAltText, getByAltText, findAllByAltText, findByAltText] = buildQueries(queryAllByAltText, getMultipleError$3, getMissingError$3);
      const isSvgTitle = (node) => {
        var _node$parentElement;
        return node.tagName.toLowerCase() === "title" && ((_node$parentElement = node.parentElement) == null ? void 0 : _node$parentElement.tagName.toLowerCase()) === "svg";
      };
      const queryAllByTitle = function(container, text, _temp) {
        let {
          exact = true,
          collapseWhitespace,
          trim,
          normalizer
        } = _temp === void 0 ? {} : _temp;
        checkContainerType(container);
        const matcher = exact ? matches : fuzzyMatches;
        const matchNormalizer = makeNormalizer({
          collapseWhitespace,
          trim,
          normalizer
        });
        return Array.from(container.querySelectorAll("[title], svg > title")).filter((node) => matcher(node.getAttribute("title"), node, text, matchNormalizer) || isSvgTitle(node) && matcher(getNodeText(node), node, text, matchNormalizer));
      };
      const getMultipleError$2 = (c, title) => "Found multiple elements with the title: " + title + ".";
      const getMissingError$2 = (c, title) => "Unable to find an element with the title: " + title + ".";
      const queryAllByTitleWithSuggestions = wrapAllByQueryWithSuggestion(queryAllByTitle, queryAllByTitle.name, "queryAll");
      const [queryByTitle, getAllByTitle, getByTitle, findAllByTitle, findByTitle] = buildQueries(queryAllByTitle, getMultipleError$2, getMissingError$2);
      const queryAllByRole = function(container, role, _temp) {
        let {
          hidden = getConfig().defaultHidden,
          name,
          description,
          queryFallbacks = false,
          selected,
          busy,
          checked,
          pressed,
          current,
          level,
          expanded,
          value: {
            now: valueNow,
            min: valueMin,
            max: valueMax,
            text: valueText
          } = {}
        } = _temp === void 0 ? {} : _temp;
        checkContainerType(container);
        if (selected !== void 0) {
          var _allRoles$get;
          if (((_allRoles$get = roles_1.get(role)) == null ? void 0 : _allRoles$get.props["aria-selected"]) === void 0) {
            throw new Error('"aria-selected" is not supported on role "' + role + '".');
          }
        }
        if (busy !== void 0) {
          var _allRoles$get2;
          if (((_allRoles$get2 = roles_1.get(role)) == null ? void 0 : _allRoles$get2.props["aria-busy"]) === void 0) {
            throw new Error('"aria-busy" is not supported on role "' + role + '".');
          }
        }
        if (checked !== void 0) {
          var _allRoles$get3;
          if (((_allRoles$get3 = roles_1.get(role)) == null ? void 0 : _allRoles$get3.props["aria-checked"]) === void 0) {
            throw new Error('"aria-checked" is not supported on role "' + role + '".');
          }
        }
        if (pressed !== void 0) {
          var _allRoles$get4;
          if (((_allRoles$get4 = roles_1.get(role)) == null ? void 0 : _allRoles$get4.props["aria-pressed"]) === void 0) {
            throw new Error('"aria-pressed" is not supported on role "' + role + '".');
          }
        }
        if (current !== void 0) {
          var _allRoles$get5;
          if (((_allRoles$get5 = roles_1.get(role)) == null ? void 0 : _allRoles$get5.props["aria-current"]) === void 0) {
            throw new Error('"aria-current" is not supported on role "' + role + '".');
          }
        }
        if (level !== void 0) {
          if (role !== "heading") {
            throw new Error('Role "' + role + '" cannot have "level" property.');
          }
        }
        if (valueNow !== void 0) {
          var _allRoles$get6;
          if (((_allRoles$get6 = roles_1.get(role)) == null ? void 0 : _allRoles$get6.props["aria-valuenow"]) === void 0) {
            throw new Error('"aria-valuenow" is not supported on role "' + role + '".');
          }
        }
        if (valueMax !== void 0) {
          var _allRoles$get7;
          if (((_allRoles$get7 = roles_1.get(role)) == null ? void 0 : _allRoles$get7.props["aria-valuemax"]) === void 0) {
            throw new Error('"aria-valuemax" is not supported on role "' + role + '".');
          }
        }
        if (valueMin !== void 0) {
          var _allRoles$get8;
          if (((_allRoles$get8 = roles_1.get(role)) == null ? void 0 : _allRoles$get8.props["aria-valuemin"]) === void 0) {
            throw new Error('"aria-valuemin" is not supported on role "' + role + '".');
          }
        }
        if (valueText !== void 0) {
          var _allRoles$get9;
          if (((_allRoles$get9 = roles_1.get(role)) == null ? void 0 : _allRoles$get9.props["aria-valuetext"]) === void 0) {
            throw new Error('"aria-valuetext" is not supported on role "' + role + '".');
          }
        }
        if (expanded !== void 0) {
          var _allRoles$get0;
          if (((_allRoles$get0 = roles_1.get(role)) == null ? void 0 : _allRoles$get0.props["aria-expanded"]) === void 0) {
            throw new Error('"aria-expanded" is not supported on role "' + role + '".');
          }
        }
        const subtreeIsInaccessibleCache = /* @__PURE__ */ new WeakMap();
        function cachedIsSubtreeInaccessible(element) {
          if (!subtreeIsInaccessibleCache.has(element)) {
            subtreeIsInaccessibleCache.set(element, isSubtreeInaccessible(element));
          }
          return subtreeIsInaccessibleCache.get(element);
        }
        return Array.from(container.querySelectorAll(
          // Only query elements that can be matched by the following filters
          makeRoleSelector(role)
        )).filter((node) => {
          const isRoleSpecifiedExplicitly = node.hasAttribute("role");
          if (isRoleSpecifiedExplicitly) {
            const roleValue = node.getAttribute("role");
            if (queryFallbacks) {
              return roleValue.split(" ").filter(Boolean).some((roleAttributeToken) => roleAttributeToken === role);
            }
            const [firstRoleAttributeToken] = roleValue.split(" ");
            return firstRoleAttributeToken === role;
          }
          const implicitRoles = getImplicitAriaRoles(node);
          return implicitRoles.some((implicitRole) => {
            return implicitRole === role;
          });
        }).filter((element) => {
          if (selected !== void 0) {
            return selected === computeAriaSelected(element);
          }
          if (busy !== void 0) {
            return busy === computeAriaBusy(element);
          }
          if (checked !== void 0) {
            return checked === computeAriaChecked(element);
          }
          if (pressed !== void 0) {
            return pressed === computeAriaPressed(element);
          }
          if (current !== void 0) {
            return current === computeAriaCurrent(element);
          }
          if (expanded !== void 0) {
            return expanded === computeAriaExpanded(element);
          }
          if (level !== void 0) {
            return level === computeHeadingLevel(element);
          }
          if (valueNow !== void 0 || valueMax !== void 0 || valueMin !== void 0 || valueText !== void 0) {
            let valueMatches = true;
            if (valueNow !== void 0) {
              valueMatches && (valueMatches = valueNow === computeAriaValueNow(element));
            }
            if (valueMax !== void 0) {
              valueMatches && (valueMatches = valueMax === computeAriaValueMax(element));
            }
            if (valueMin !== void 0) {
              valueMatches && (valueMatches = valueMin === computeAriaValueMin(element));
            }
            if (valueText !== void 0) {
              var _computeAriaValueText;
              valueMatches && (valueMatches = matches((_computeAriaValueText = computeAriaValueText(element)) != null ? _computeAriaValueText : null, element, valueText, (text) => text));
            }
            return valueMatches;
          }
          return true;
        }).filter((element) => {
          if (name === void 0) {
            return true;
          }
          return matches(computeAccessibleName(element, {
            computedStyleSupportsPseudoElements: getConfig().computedStyleSupportsPseudoElements
          }), element, name, (text) => text);
        }).filter((element) => {
          if (description === void 0) {
            return true;
          }
          return matches(computeAccessibleDescription(element, {
            computedStyleSupportsPseudoElements: getConfig().computedStyleSupportsPseudoElements
          }), element, description, (text) => text);
        }).filter((element) => {
          return hidden === false ? isInaccessible(element, {
            isSubtreeInaccessible: cachedIsSubtreeInaccessible
          }) === false : true;
        });
      };
      function makeRoleSelector(role) {
        var _roleElements$get;
        const explicitRoleSelector = '*[role~="' + role + '"]';
        const roleRelations = (_roleElements$get = roleElements_1.get(role)) != null ? _roleElements$get : /* @__PURE__ */ new Set();
        const implicitRoleSelectors = new Set(Array.from(roleRelations).map((_ref) => {
          let {
            name
          } = _ref;
          return name;
        }));
        return [explicitRoleSelector].concat(Array.from(implicitRoleSelectors)).join(",");
      }
      const getNameHint = (name) => {
        let nameHint = "";
        if (name === void 0) {
          nameHint = "";
        } else if (typeof name === "string") {
          nameHint = ' and name "' + name + '"';
        } else {
          nameHint = " and name `" + name + "`";
        }
        return nameHint;
      };
      const getMultipleError$1 = function(c, role, _temp2) {
        let {
          name
        } = _temp2 === void 0 ? {} : _temp2;
        return 'Found multiple elements with the role "' + role + '"' + getNameHint(name);
      };
      const getMissingError$1 = function(container, role, _temp3) {
        let {
          hidden = getConfig().defaultHidden,
          name,
          description
        } = _temp3 === void 0 ? {} : _temp3;
        if (getConfig()._disableExpensiveErrorDiagnostics) {
          return 'Unable to find role="' + role + '"' + getNameHint(name);
        }
        let roles2 = "";
        Array.from(container.children).forEach((childElement) => {
          roles2 += prettyRoles(childElement, {
            hidden,
            includeDescription: description !== void 0
          });
        });
        let roleMessage;
        if (roles2.length === 0) {
          if (hidden === false) {
            roleMessage = "There are no accessible roles. But there might be some inaccessible roles. If you wish to access them, then set the `hidden` option to `true`. Learn more about this here: https://testing-library.com/docs/dom-testing-library/api-queries#byrole";
          } else {
            roleMessage = "There are no available roles.";
          }
        } else {
          roleMessage = ("\nHere are the " + (hidden === false ? "accessible" : "available") + " roles:\n\n  " + roles2.replace(/\n/g, "\n  ").replace(/\n\s\s\n/g, "\n\n") + "\n").trim();
        }
        let nameHint = "";
        if (name === void 0) {
          nameHint = "";
        } else if (typeof name === "string") {
          nameHint = ' and name "' + name + '"';
        } else {
          nameHint = " and name `" + name + "`";
        }
        let descriptionHint = "";
        if (description === void 0) {
          descriptionHint = "";
        } else if (typeof description === "string") {
          descriptionHint = ' and description "' + description + '"';
        } else {
          descriptionHint = " and description `" + description + "`";
        }
        return ("\nUnable to find an " + (hidden === false ? "accessible " : "") + 'element with the role "' + role + '"' + nameHint + descriptionHint + "\n\n" + roleMessage).trim();
      };
      const queryAllByRoleWithSuggestions = wrapAllByQueryWithSuggestion(queryAllByRole, queryAllByRole.name, "queryAll");
      const [queryByRole, getAllByRole, getByRole, findAllByRole, findByRole] = buildQueries(queryAllByRole, getMultipleError$1, getMissingError$1);
      const getTestIdAttribute = () => getConfig().testIdAttribute;
      const queryAllByTestId = function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        checkContainerType(args[0]);
        return queryAllByAttribute(getTestIdAttribute(), ...args);
      };
      const getMultipleError = (c, id) => "Found multiple elements by: [" + getTestIdAttribute() + '="' + id + '"]';
      const getMissingError = (c, id) => "Unable to find an element by: [" + getTestIdAttribute() + '="' + id + '"]';
      const queryAllByTestIdWithSuggestions = wrapAllByQueryWithSuggestion(queryAllByTestId, queryAllByTestId.name, "queryAll");
      const [queryByTestId, getAllByTestId, getByTestId, findAllByTestId, findByTestId] = buildQueries(queryAllByTestId, getMultipleError, getMissingError);
      var queries = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        queryAllByLabelText: queryAllByLabelTextWithSuggestions,
        queryByLabelText,
        getAllByLabelText: getAllByLabelTextWithSuggestions,
        getByLabelText: getByLabelTextWithSuggestions,
        findAllByLabelText,
        findByLabelText,
        queryByPlaceholderText,
        queryAllByPlaceholderText: queryAllByPlaceholderTextWithSuggestions,
        getByPlaceholderText,
        getAllByPlaceholderText,
        findAllByPlaceholderText,
        findByPlaceholderText,
        queryByText,
        queryAllByText: queryAllByTextWithSuggestions,
        getByText,
        getAllByText,
        findAllByText,
        findByText,
        queryByDisplayValue,
        queryAllByDisplayValue: queryAllByDisplayValueWithSuggestions,
        getByDisplayValue,
        getAllByDisplayValue,
        findAllByDisplayValue,
        findByDisplayValue,
        queryByAltText,
        queryAllByAltText: queryAllByAltTextWithSuggestions,
        getByAltText,
        getAllByAltText,
        findAllByAltText,
        findByAltText,
        queryByTitle,
        queryAllByTitle: queryAllByTitleWithSuggestions,
        getByTitle,
        getAllByTitle,
        findAllByTitle,
        findByTitle,
        queryByRole,
        queryAllByRole: queryAllByRoleWithSuggestions,
        getAllByRole,
        getByRole,
        findAllByRole,
        findByRole,
        queryByTestId,
        queryAllByTestId: queryAllByTestIdWithSuggestions,
        getByTestId,
        getAllByTestId,
        findAllByTestId,
        findByTestId
      });
      function getQueriesForElement(element, queries$1, initialValue2) {
        if (queries$1 === void 0) {
          queries$1 = queries;
        }
        if (initialValue2 === void 0) {
          initialValue2 = {};
        }
        return Object.keys(queries$1).reduce((helpers, key) => {
          const fn = queries$1[key];
          helpers[key] = fn.bind(null, element);
          return helpers;
        }, initialValue2);
      }
      const eventMap$1 = {
        // Clipboard Events
        copy: {
          EventType: "ClipboardEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        cut: {
          EventType: "ClipboardEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        paste: {
          EventType: "ClipboardEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        // Composition Events
        compositionEnd: {
          EventType: "CompositionEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        compositionStart: {
          EventType: "CompositionEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        compositionUpdate: {
          EventType: "CompositionEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        // Keyboard Events
        keyDown: {
          EventType: "KeyboardEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            charCode: 0,
            composed: true
          }
        },
        keyPress: {
          EventType: "KeyboardEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            charCode: 0,
            composed: true
          }
        },
        keyUp: {
          EventType: "KeyboardEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            charCode: 0,
            composed: true
          }
        },
        // Focus Events
        focus: {
          EventType: "FocusEvent",
          defaultInit: {
            bubbles: false,
            cancelable: false,
            composed: true
          }
        },
        blur: {
          EventType: "FocusEvent",
          defaultInit: {
            bubbles: false,
            cancelable: false,
            composed: true
          }
        },
        focusIn: {
          EventType: "FocusEvent",
          defaultInit: {
            bubbles: true,
            cancelable: false,
            composed: true
          }
        },
        focusOut: {
          EventType: "FocusEvent",
          defaultInit: {
            bubbles: true,
            cancelable: false,
            composed: true
          }
        },
        // Form Events
        change: {
          EventType: "Event",
          defaultInit: {
            bubbles: true,
            cancelable: false
          }
        },
        input: {
          EventType: "InputEvent",
          defaultInit: {
            bubbles: true,
            cancelable: false,
            composed: true
          }
        },
        invalid: {
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: true
          }
        },
        submit: {
          EventType: "Event",
          defaultInit: {
            bubbles: true,
            cancelable: true
          }
        },
        reset: {
          EventType: "Event",
          defaultInit: {
            bubbles: true,
            cancelable: true
          }
        },
        // Mouse Events
        click: {
          EventType: "MouseEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            button: 0,
            composed: true
          }
        },
        contextMenu: {
          EventType: "MouseEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        dblClick: {
          EventType: "MouseEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        drag: {
          EventType: "DragEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        dragEnd: {
          EventType: "DragEvent",
          defaultInit: {
            bubbles: true,
            cancelable: false,
            composed: true
          }
        },
        dragEnter: {
          EventType: "DragEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        dragExit: {
          EventType: "DragEvent",
          defaultInit: {
            bubbles: true,
            cancelable: false,
            composed: true
          }
        },
        dragLeave: {
          EventType: "DragEvent",
          defaultInit: {
            bubbles: true,
            cancelable: false,
            composed: true
          }
        },
        dragOver: {
          EventType: "DragEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        dragStart: {
          EventType: "DragEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        drop: {
          EventType: "DragEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        mouseDown: {
          EventType: "MouseEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        mouseEnter: {
          EventType: "MouseEvent",
          defaultInit: {
            bubbles: false,
            cancelable: false,
            composed: true
          }
        },
        mouseLeave: {
          EventType: "MouseEvent",
          defaultInit: {
            bubbles: false,
            cancelable: false,
            composed: true
          }
        },
        mouseMove: {
          EventType: "MouseEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        mouseOut: {
          EventType: "MouseEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        mouseOver: {
          EventType: "MouseEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        mouseUp: {
          EventType: "MouseEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        // Selection Events
        select: {
          EventType: "Event",
          defaultInit: {
            bubbles: true,
            cancelable: false
          }
        },
        // Touch Events
        touchCancel: {
          EventType: "TouchEvent",
          defaultInit: {
            bubbles: true,
            cancelable: false,
            composed: true
          }
        },
        touchEnd: {
          EventType: "TouchEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        touchMove: {
          EventType: "TouchEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        touchStart: {
          EventType: "TouchEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        // UI Events
        resize: {
          EventType: "UIEvent",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        scroll: {
          EventType: "UIEvent",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        // Wheel Events
        wheel: {
          EventType: "WheelEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        // Media Events
        abort: {
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        canPlay: {
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        canPlayThrough: {
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        durationChange: {
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        emptied: {
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        encrypted: {
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        ended: {
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        loadedData: {
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        loadedMetadata: {
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        loadStart: {
          EventType: "ProgressEvent",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        pause: {
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        play: {
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        playing: {
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        progress: {
          EventType: "ProgressEvent",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        rateChange: {
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        seeked: {
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        seeking: {
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        stalled: {
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        suspend: {
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        timeUpdate: {
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        volumeChange: {
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        waiting: {
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        // Events
        load: {
          // TODO: load events can be UIEvent or Event depending on what generated them
          // This is where this abstraction breaks down.
          // But the common targets are <img />, <script /> and window.
          // Neither of these targets receive a UIEvent
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        error: {
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        // Animation Events
        animationStart: {
          EventType: "AnimationEvent",
          defaultInit: {
            bubbles: true,
            cancelable: false
          }
        },
        animationEnd: {
          EventType: "AnimationEvent",
          defaultInit: {
            bubbles: true,
            cancelable: false
          }
        },
        animationIteration: {
          EventType: "AnimationEvent",
          defaultInit: {
            bubbles: true,
            cancelable: false
          }
        },
        // Transition Events
        transitionCancel: {
          EventType: "TransitionEvent",
          defaultInit: {
            bubbles: true,
            cancelable: false
          }
        },
        transitionEnd: {
          EventType: "TransitionEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true
          }
        },
        transitionRun: {
          EventType: "TransitionEvent",
          defaultInit: {
            bubbles: true,
            cancelable: false
          }
        },
        transitionStart: {
          EventType: "TransitionEvent",
          defaultInit: {
            bubbles: true,
            cancelable: false
          }
        },
        // pointer events
        pointerOver: {
          EventType: "PointerEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        pointerEnter: {
          EventType: "PointerEvent",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        pointerDown: {
          EventType: "PointerEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        pointerMove: {
          EventType: "PointerEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        pointerUp: {
          EventType: "PointerEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        pointerCancel: {
          EventType: "PointerEvent",
          defaultInit: {
            bubbles: true,
            cancelable: false,
            composed: true
          }
        },
        pointerOut: {
          EventType: "PointerEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        pointerLeave: {
          EventType: "PointerEvent",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        gotPointerCapture: {
          EventType: "PointerEvent",
          defaultInit: {
            bubbles: true,
            cancelable: false,
            composed: true
          }
        },
        lostPointerCapture: {
          EventType: "PointerEvent",
          defaultInit: {
            bubbles: true,
            cancelable: false,
            composed: true
          }
        },
        // history events
        popState: {
          EventType: "PopStateEvent",
          defaultInit: {
            bubbles: true,
            cancelable: false
          }
        },
        // window events
        offline: {
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        online: {
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        pageHide: {
          EventType: "PageTransitionEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true
          }
        },
        pageShow: {
          EventType: "PageTransitionEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true
          }
        }
      };
      const eventAliasMap = {
        doubleClick: "dblClick"
      };
      Object.keys(eventMap$1).forEach((key) => {
        const {
          EventType,
          defaultInit
        } = eventMap$1[key];
        key.toLowerCase();
      });
      Object.keys(eventAliasMap).forEach((aliasKey) => {
      });
      function unindent(string) {
        return string.replace(/[ \t]*[\n][ \t]*/g, "\n");
      }
      function encode(value) {
        return lzString.compressToEncodedURIComponent(unindent(value));
      }
      function getPlaygroundUrl(markup) {
        return "https://testing-playground.com/#markup=" + encode(markup);
      }
      const debug = (element, maxLength, options) => Array.isArray(element) ? element.forEach((el) => logDOM(el, maxLength, options)) : logDOM(element, maxLength, options);
      const logTestingPlaygroundURL = function(element) {
        if (element === void 0) {
          element = getDocument$1().body;
        }
        if (!element || !("innerHTML" in element)) {
          console.log("The element you're providing isn't a valid DOM element.");
          return;
        }
        if (!element.innerHTML) {
          console.log("The provided element doesn't have any children.");
          return;
        }
        const playgroundUrl = getPlaygroundUrl(element.innerHTML);
        console.log("Open this URL in your browser\n\n" + playgroundUrl);
        return playgroundUrl;
      };
      const initialValue = {
        debug,
        logTestingPlaygroundURL
      };
      typeof document !== "undefined" && document.body ? getQueriesForElement(document.body, queries, initialValue) : Object.keys(queries).reduce((helpers, key) => {
        helpers[key] = () => {
          throw new TypeError("For queries bound to document.body a global document has to be available... Learn more: https://testing-library.com/s/screen-global-error");
        };
        return helpers;
      }, initialValue);

      function wrapEvent(cb, _element) {
          return getConfig().eventWrapper(cb);
      }

      // Browsers do not dispatch FocusEvent if the document does not have focus.
      // TODO: simulate FocusEvent in browsers
      /**
       * Focus closest focusable element.
       */ function focusElement(element) {
          const target = findClosest(element, isFocusable);
          const activeElement = getActiveElement(element.ownerDocument);
          if ((target !== null && target !== undefined ? target : element.ownerDocument.body) === activeElement) {
              return;
          } else if (target) {
              wrapEvent(()=>target.focus());
          } else {
              wrapEvent(()=>activeElement === null || activeElement === undefined ? undefined : activeElement.blur());
          }
          updateSelectionOnFocus(target !== null && target !== undefined ? target : element.ownerDocument.body);
      }
      function blurElement(element) {
          if (!isFocusable(element)) return;
          const wasActive = getActiveElement(element.ownerDocument) === element;
          if (!wasActive) return;
          wrapEvent(()=>element.blur());
      }

      const behavior = {};

      behavior.click = (event, target, instance)=>{
          const context = target.closest('button,input,label,select,textarea');
          const control = context && isElementType(context, 'label') && context.control;
          if (control && control !== target) {
              return ()=>{
                  if (isFocusable(control)) {
                      focusElement(control);
                      instance.dispatchEvent(control, cloneEvent(event));
                  }
              };
          } else if (isElementType(target, 'input', {
              type: 'file'
          })) {
              return ()=>{
                  // blur fires when the file selector pops up
                  blurElement(target);
                  target.dispatchEvent(new (getWindow(target)).Event('fileDialog'));
                  // focus fires after the file selector has been closed
                  focusElement(target);
              };
          }
      };

      const UIValue = Symbol('Displayed value in UI');
      const UISelection = Symbol('Displayed selection in UI');
      const InitialValue = Symbol('Initial value to compare on blur');
      function isUIValue(value) {
          return typeof value === 'object' && UIValue in value;
      }
      function isUISelectionStart(start) {
          return !!start && typeof start === 'object' && UISelection in start;
      }
      function setUIValue(element, value) {
          if (element[InitialValue] === undefined) {
              element[InitialValue] = element.value;
          }
          element[UIValue] = value;
          // eslint-disable-next-line no-new-wrappers
          element.value = Object.assign(new String(value), {
              [UIValue]: true
          });
      }
      function getUIValue(element) {
          return element[UIValue] === undefined ? element.value : String(element[UIValue]);
      }
      /** Flag the IDL value as clean. This does not change the value.*/ function setUIValueClean(element) {
          element[UIValue] = undefined;
      }
      function clearInitialValue(element) {
          element[InitialValue] = undefined;
      }
      function getInitialValue(element) {
          return element[InitialValue];
      }
      function setUISelectionRaw(element, selection) {
          element[UISelection] = selection;
      }
      function setUISelection(element, { focusOffset: focusOffsetParam, anchorOffset: anchorOffsetParam = focusOffsetParam }, mode = 'replace') {
          const valueLength = getUIValue(element).length;
          const sanitizeOffset = (o)=>Math.max(0, Math.min(valueLength, o));
          const anchorOffset = mode === 'replace' || element[UISelection] === undefined ? sanitizeOffset(anchorOffsetParam) : element[UISelection].anchorOffset;
          const focusOffset = sanitizeOffset(focusOffsetParam);
          const startOffset = Math.min(anchorOffset, focusOffset);
          const endOffset = Math.max(anchorOffset, focusOffset);
          element[UISelection] = {
              anchorOffset,
              focusOffset
          };
          if (element.selectionStart === startOffset && element.selectionEnd === endOffset) {
              return;
          }
          // eslint-disable-next-line no-new-wrappers
          const startObj = Object.assign(new Number(startOffset), {
              [UISelection]: true
          });
          try {
              element.setSelectionRange(startObj, endOffset);
          } catch  {
          // DOMException for invalid state is expected when calling this
          // on an element without support for setSelectionRange
          }
      }
      function getUISelection(element) {
          var _element_selectionStart, _element_selectionEnd, _element_UISelection;
          const sel = (_element_UISelection = element[UISelection]) !== null && _element_UISelection !== undefined ? _element_UISelection : {
              anchorOffset: (_element_selectionStart = element.selectionStart) !== null && _element_selectionStart !== undefined ? _element_selectionStart : 0,
              focusOffset: (_element_selectionEnd = element.selectionEnd) !== null && _element_selectionEnd !== undefined ? _element_selectionEnd : 0
          };
          return {
              ...sel,
              startOffset: Math.min(sel.anchorOffset, sel.focusOffset),
              endOffset: Math.max(sel.anchorOffset, sel.focusOffset)
          };
      }
      function hasUISelection(element) {
          return !!element[UISelection];
      }
      /** Flag the IDL selection as clean. This does not change the selection. */ function setUISelectionClean(element) {
          element[UISelection] = undefined;
      }

      const parseInt$1 = globalThis.parseInt;
      function buildTimeValue(value) {
          const onlyDigitsValue = value.replace(/\D/g, '');
          if (onlyDigitsValue.length < 2) {
              return value;
          }
          const firstDigit = parseInt$1(onlyDigitsValue[0], 10);
          const secondDigit = parseInt$1(onlyDigitsValue[1], 10);
          if (firstDigit >= 3 || firstDigit === 2 && secondDigit >= 4) {
              let index;
              if (firstDigit >= 3) {
                  index = 1;
              } else {
                  index = 2;
              }
              return build(onlyDigitsValue, index);
          }
          if (value.length === 2) {
              return value;
          }
          return build(onlyDigitsValue, 2);
      }
      function build(onlyDigitsValue, index) {
          const hours = onlyDigitsValue.slice(0, index);
          const validHours = Math.min(parseInt$1(hours, 10), 23);
          const minuteCharacters = onlyDigitsValue.slice(index);
          const parsedMinutes = parseInt$1(minuteCharacters, 10);
          const validMinutes = Math.min(parsedMinutes, 59);
          return `${validHours.toString().padStart(2, '0')}:${validMinutes.toString().padStart(2, '0')}`;
      }
      function isValidDateOrTimeValue(element, value) {
          const clone = element.cloneNode();
          clone.value = value;
          return clone.value === value;
      }

      var maxLengthSupportedTypes = /*#__PURE__*/ function(maxLengthSupportedTypes) {
          maxLengthSupportedTypes["email"] = "email";
          maxLengthSupportedTypes["password"] = "password";
          maxLengthSupportedTypes["search"] = "search";
          maxLengthSupportedTypes["telephone"] = "telephone";
          maxLengthSupportedTypes["text"] = "text";
          maxLengthSupportedTypes["url"] = "url";
          return maxLengthSupportedTypes;
      }(maxLengthSupportedTypes || {});
      // can't use .maxLength property because of a jsdom bug:
      // https://github.com/jsdom/jsdom/issues/2927
      function getMaxLength(element) {
          var _element_getAttribute;
          const attr = (_element_getAttribute = element.getAttribute('maxlength')) !== null && _element_getAttribute !== undefined ? _element_getAttribute : '';
          return /^\d+$/.test(attr) && Number(attr) >= 0 ? Number(attr) : undefined;
      }
      function supportsMaxLength(element) {
          return isElementType(element, 'textarea') || isElementType(element, 'input') && element.type in maxLengthSupportedTypes;
      }

      function getNextCursorPosition(node, offset, direction, inputType) {
          // The behavior at text node zero offset is inconsistent.
          // When walking backwards:
          // Firefox always moves to zero offset and jumps over last offset.
          // Chrome jumps over zero offset per default but over last offset when Shift is pressed.
          // The cursor always moves to zero offset if the focus area (contenteditable or body) ends there.
          // When walking forward both ignore zero offset.
          // When walking over input elements the cursor moves before or after that element.
          // When walking over line breaks the cursor moves inside any following text node.
          if (isTextNode(node) && offset + direction >= 0 && offset + direction <= node.nodeValue.length) {
              return {
                  node,
                  offset: offset + direction
              };
          }
          const nextNode = getNextCharacterContentNode(node, offset, direction);
          if (nextNode) {
              if (isTextNode(nextNode)) {
                  return {
                      node: nextNode,
                      offset: direction > 0 ? Math.min(1, nextNode.nodeValue.length) : Math.max(nextNode.nodeValue.length - 1, 0)
                  };
              } else if (isElementType(nextNode, 'br')) {
                  const nextPlusOne = getNextCharacterContentNode(nextNode, undefined, direction);
                  if (!nextPlusOne) {
                      // The behavior when there is no possible cursor position beyond the line break is inconsistent.
                      // In Chrome outside of contenteditable moving before a leading line break is possible.
                      // A leading line break can still be removed per deleteContentBackward.
                      // A trailing line break on the other hand is not removed by deleteContentForward.
                      if (direction < 0 && inputType === 'deleteContentBackward') {
                          return {
                              node: nextNode.parentNode,
                              offset: getOffset(nextNode)
                          };
                      }
                      return undefined;
                  } else if (isTextNode(nextPlusOne)) {
                      return {
                          node: nextPlusOne,
                          offset: direction > 0 ? 0 : nextPlusOne.nodeValue.length
                      };
                  } else if (direction < 0 && isElementType(nextPlusOne, 'br')) {
                      return {
                          node: nextNode.parentNode,
                          offset: getOffset(nextNode)
                      };
                  } else {
                      return {
                          node: nextPlusOne.parentNode,
                          offset: getOffset(nextPlusOne) + (direction > 0 ? 0 : 1)
                      };
                  }
              } else {
                  return {
                      node: nextNode.parentNode,
                      offset: getOffset(nextNode) + (direction > 0 ? 1 : 0)
                  };
              }
          }
      }
      function getNextCharacterContentNode(node, offset, direction) {
          const nextOffset = Number(offset) + (direction < 0 ? -1 : 0);
          if (offset !== undefined && isElement(node) && nextOffset >= 0 && nextOffset < node.children.length) {
              node = node.children[nextOffset];
          }
          return walkNodes(node, direction === 1 ? 'next' : 'previous', isTreatedAsCharacterContent);
      }
      function isTreatedAsCharacterContent(node) {
          if (isTextNode(node)) {
              return true;
          }
          if (isElement(node)) {
              if (isElementType(node, [
                  'input',
                  'textarea'
              ])) {
                  return node.type !== 'hidden';
              } else if (isElementType(node, 'br')) {
                  return true;
              }
          }
          return false;
      }
      function getOffset(node) {
          let i = 0;
          while(node.previousSibling){
              i++;
              node = node.previousSibling;
          }
          return i;
      }
      function isElement(node) {
          return node.nodeType === 1;
      }
      function isTextNode(node) {
          return node.nodeType === 3;
      }
      function walkNodes(node, direction, callback) {
          for(;;){
              var _node_ownerDocument;
              const sibling = node[`${direction}Sibling`];
              if (sibling) {
                  node = getDescendant(sibling, direction === 'next' ? 'first' : 'last');
                  if (callback(node)) {
                      return node;
                  }
              } else if (node.parentNode && (!isElement(node.parentNode) || !isContentEditable(node.parentNode) && node.parentNode !== ((_node_ownerDocument = node.ownerDocument) === null || _node_ownerDocument === undefined ? undefined : _node_ownerDocument.body))) {
                  node = node.parentNode;
              } else {
                  break;
              }
          }
      }
      function getDescendant(node, direction) {
          while(node.hasChildNodes()){
              node = node[`${direction}Child`];
          }
          return node;
      }

      const TrackChanges = Symbol('Track programmatic changes for React workaround');
      // When the input event happens in the browser, React executes all event handlers
      // and if they change state of a controlled value, nothing happens.
      // But when we trigger the event handlers in test environment with React@17,
      // the changes are rolled back before the state update is applied.
      // This results in a reset cursor.
      // There might be a better way to work around if we figure out
      // why the batched update is executed differently in our test environment.
      function isReact17Element(element) {
          return Object.getOwnPropertyNames(element).some((k)=>k.startsWith('__react')) && getWindow(element).REACT_VERSION === 17;
      }
      function startTrackValue(element) {
          if (!isReact17Element(element)) {
              return;
          }
          element[TrackChanges] = {
              previousValue: String(element.value),
              tracked: []
          };
      }
      function trackOrSetValue(element, v) {
          var _element_TrackChanges_tracked, _element_TrackChanges;
          (_element_TrackChanges = element[TrackChanges]) === null || _element_TrackChanges === undefined ? undefined : (_element_TrackChanges_tracked = _element_TrackChanges.tracked) === null || _element_TrackChanges_tracked === undefined ? undefined : _element_TrackChanges_tracked.push(v);
          if (!element[TrackChanges]) {
              setUIValueClean(element);
              setUISelection(element, {
                  focusOffset: v.length
              });
          }
      }
      function commitValueAfterInput(element, cursorOffset) {
          var _changes_tracked;
          const changes = element[TrackChanges];
          element[TrackChanges] = undefined;
          if (!(changes === null || changes === undefined ? undefined : (_changes_tracked = changes.tracked) === null || _changes_tracked === undefined ? undefined : _changes_tracked.length)) {
              return;
          }
          const isJustReactStateUpdate = changes.tracked.length === 2 && changes.tracked[0] === changes.previousValue && changes.tracked[1] === element.value;
          if (!isJustReactStateUpdate) {
              setUIValueClean(element);
          }
          if (hasUISelection(element)) {
              setUISelection(element, {
                  focusOffset: isJustReactStateUpdate ? cursorOffset : element.value.length
              });
          }
      }

      /**
       * Determine which selection logic and selection ranges to consider.
       */ function getTargetTypeAndSelection(node) {
          const element = getElement(node);
          if (element && hasOwnSelection(element)) {
              return {
                  type: 'input',
                  selection: getUISelection(element)
              };
          }
          const selection = element === null || element === undefined ? undefined : element.ownerDocument.getSelection();
          // It is possible to extend a single-range selection into a contenteditable.
          // This results in the range acting like a range outside of contenteditable.
          const isCE = getContentEditable(node) && (selection === null || selection === undefined ? undefined : selection.anchorNode) && getContentEditable(selection.anchorNode);
          return {
              type: isCE ? 'contenteditable' : 'default',
              selection
          };
      }
      function getElement(node) {
          return node.nodeType === 1 ? node : node.parentElement;
      }

      /**
       * Get the range that would be overwritten by input.
       */ function getInputRange(focusNode) {
          const typeAndSelection = getTargetTypeAndSelection(focusNode);
          if (typeAndSelection.type === 'input') {
              return typeAndSelection.selection;
          } else if (typeAndSelection.type === 'contenteditable') {
              var _typeAndSelection_selection;
              // Multi-range on contenteditable edits the first selection instead of the last
              return (_typeAndSelection_selection = typeAndSelection.selection) === null || _typeAndSelection_selection === undefined ? undefined : _typeAndSelection_selection.getRangeAt(0);
          }
      }

      /**
       * Set the selection
       */ function setSelection({ focusNode, focusOffset, anchorNode = focusNode, anchorOffset = focusOffset }) {
          var _anchorNode_ownerDocument_getSelection, _anchorNode_ownerDocument;
          const typeAndSelection = getTargetTypeAndSelection(focusNode);
          if (typeAndSelection.type === 'input') {
              return setUISelection(focusNode, {
                  anchorOffset,
                  focusOffset
              });
          }
          (_anchorNode_ownerDocument = anchorNode.ownerDocument) === null || _anchorNode_ownerDocument === undefined ? undefined : (_anchorNode_ownerDocument_getSelection = _anchorNode_ownerDocument.getSelection()) === null || _anchorNode_ownerDocument_getSelection === undefined ? undefined : _anchorNode_ownerDocument_getSelection.setBaseAndExtent(anchorNode, anchorOffset, focusNode, focusOffset);
      }

      function isDateOrTime(element) {
          return isElementType(element, 'input') && [
              'date',
              'time'
          ].includes(element.type);
      }
      function input(instance, element, data, inputType = 'insertText') {
          const inputRange = getInputRange(element);
          /* istanbul ignore if */ if (!inputRange) {
              return;
          }
          // There is no `beforeinput` event on `date` and `time` input
          if (!isDateOrTime(element)) {
              const unprevented = instance.dispatchUIEvent(element, 'beforeinput', {
                  inputType,
                  data
              });
              if (!unprevented) {
                  return;
              }
          }
          if ('startContainer' in inputRange) {
              editContenteditable(instance, element, inputRange, data, inputType);
          } else {
              editInputElement(instance, element, inputRange, data, inputType);
          }
      }
      function editContenteditable(instance, element, inputRange, data, inputType) {
          let del = false;
          if (!inputRange.collapsed) {
              del = true;
              inputRange.deleteContents();
          } else if ([
              'deleteContentBackward',
              'deleteContentForward'
          ].includes(inputType)) {
              const nextPosition = getNextCursorPosition(inputRange.startContainer, inputRange.startOffset, inputType === 'deleteContentBackward' ? -1 : 1, inputType);
              if (nextPosition) {
                  del = true;
                  const delRange = inputRange.cloneRange();
                  if (delRange.comparePoint(nextPosition.node, nextPosition.offset) < 0) {
                      delRange.setStart(nextPosition.node, nextPosition.offset);
                  } else {
                      delRange.setEnd(nextPosition.node, nextPosition.offset);
                  }
                  delRange.deleteContents();
              }
          }
          if (data) {
              if (inputRange.endContainer.nodeType === 3) {
                  const offset = inputRange.endOffset;
                  inputRange.endContainer.insertData(offset, data);
                  inputRange.setStart(inputRange.endContainer, offset + data.length);
                  inputRange.setEnd(inputRange.endContainer, offset + data.length);
              } else {
                  const text = element.ownerDocument.createTextNode(data);
                  inputRange.insertNode(text);
                  inputRange.setStart(text, data.length);
                  inputRange.setEnd(text, data.length);
              }
          }
          if (del || data) {
              instance.dispatchUIEvent(element, 'input', {
                  inputType
              });
          }
      }
      function editInputElement(instance, element, inputRange, data, inputType) {
          let dataToInsert = data;
          if (supportsMaxLength(element)) {
              const maxLength = getMaxLength(element);
              if (maxLength !== undefined && data.length > 0) {
                  const spaceUntilMaxLength = maxLength - element.value.length;
                  if (spaceUntilMaxLength > 0) {
                      dataToInsert = data.substring(0, spaceUntilMaxLength);
                  } else {
                      return;
                  }
              }
          }
          const { newValue, newOffset, oldValue } = calculateNewValue(dataToInsert, element, inputRange, inputType);
          if (newValue === oldValue && newOffset === inputRange.startOffset && newOffset === inputRange.endOffset) {
              return;
          }
          if (isElementType(element, 'input', {
              type: 'number'
          }) && !isValidNumberInput(newValue)) {
              return;
          }
          setUIValue(element, newValue);
          setSelection({
              focusNode: element,
              anchorOffset: newOffset,
              focusOffset: newOffset
          });
          if (isDateOrTime(element)) {
              if (isValidDateOrTimeValue(element, newValue)) {
                  commitInput(instance, element, newOffset, {});
                  instance.dispatchUIEvent(element, 'change');
                  clearInitialValue(element);
              }
          } else {
              commitInput(instance, element, newOffset, {
                  data,
                  inputType
              });
          }
      }
      function calculateNewValue(inputData, node, { startOffset, endOffset }, inputType) {
          const value = getUIValue(node);
          const prologEnd = Math.max(0, startOffset === endOffset && inputType === 'deleteContentBackward' ? startOffset - 1 : startOffset);
          const prolog = value.substring(0, prologEnd);
          const epilogStart = Math.min(value.length, startOffset === endOffset && inputType === 'deleteContentForward' ? startOffset + 1 : endOffset);
          const epilog = value.substring(epilogStart, value.length);
          let newValue = `${prolog}${inputData}${epilog}`;
          let newOffset = prologEnd + inputData.length;
          if (isElementType(node, 'input', {
              type: 'time'
          })) {
              const builtValue = buildTimeValue(newValue);
              if (builtValue !== '' && isValidDateOrTimeValue(node, builtValue)) {
                  newValue = builtValue;
                  newOffset = builtValue.length;
              }
          }
          return {
              oldValue: value,
              newValue,
              newOffset
          };
      }
      function commitInput(instance, element, newOffset, inputInit) {
          instance.dispatchUIEvent(element, 'input', inputInit);
          commitValueAfterInput(element, newOffset);
      }
      function isValidNumberInput(value) {
          var _value_match, _value_match1;
          // the browser allows some invalid input but not others
          // it allows up to two '-' at any place before any 'e' or one directly following 'e'
          // it allows one '.' at any place before e
          const valueParts = value.split('e', 2);
          return !(/[^\d.\-e]/.test(value) || Number((_value_match = value.match(/-/g)) === null || _value_match === undefined ? undefined : _value_match.length) > 2 || Number((_value_match1 = value.match(/\./g)) === null || _value_match1 === undefined ? undefined : _value_match1.length) > 1 || valueParts[1] && !/^-?\d*$/.test(valueParts[1]));
      }

      behavior.cut = (event, target, instance)=>{
          return ()=>{
              if (isEditable(target)) {
                  input(instance, target, '', 'deleteByCut');
              }
          };
      };

      function getValueOrTextContent(element) {
          // istanbul ignore if
          if (!element) {
              return null;
          }
          if (isContentEditable(element)) {
              return element.textContent;
          }
          return getUIValue(element);
      }

      function isVisible(element) {
          const window = getWindow(element);
          for(let el = element; el === null || el === undefined ? undefined : el.ownerDocument; el = el.parentElement){
              const { display, visibility } = window.getComputedStyle(el);
              if (display === 'none') {
                  return false;
              }
              if (visibility === 'hidden') {
                  return false;
              }
          }
          return true;
      }

      function getTabDestination(activeElement, shift) {
          const document = activeElement.ownerDocument;
          const focusableElements = document.querySelectorAll(FOCUSABLE_SELECTOR);
          const enabledElements = Array.from(focusableElements).filter((el)=>el === activeElement || !(Number(el.getAttribute('tabindex')) < 0 || isDisabled(el)));
          // tabindex has no effect if the active element has negative tabindex
          if (Number(activeElement.getAttribute('tabindex')) >= 0) {
              enabledElements.sort((a, b)=>{
                  const i = Number(a.getAttribute('tabindex'));
                  const j = Number(b.getAttribute('tabindex'));
                  if (i === j) {
                      return 0;
                  } else if (i === 0) {
                      return 1;
                  } else if (j === 0) {
                      return -1;
                  }
                  return i - j;
              });
          }
          const checkedRadio = {};
          let prunedElements = [
              document.body
          ];
          const activeRadioGroup = isElementType(activeElement, 'input', {
              type: 'radio'
          }) ? activeElement.name : undefined;
          enabledElements.forEach((currentElement)=>{
              const el = currentElement;
              // For radio groups keep only the active radio
              // If there is no active radio, keep only the checked radio
              // If there is no checked radio, treat like everything else
              if (isElementType(el, 'input', {
                  type: 'radio'
              }) && el.name) {
                  // If the active element is part of the group, add only that
                  if (el === activeElement) {
                      prunedElements.push(el);
                      return;
                  } else if (el.name === activeRadioGroup) {
                      return;
                  }
                  // If we stumble upon a checked radio, remove the others
                  if (el.checked) {
                      prunedElements = prunedElements.filter((e)=>!isElementType(e, 'input', {
                              type: 'radio',
                              name: el.name
                          }));
                      prunedElements.push(el);
                      checkedRadio[el.name] = el;
                      return;
                  }
                  // If we already found the checked one, skip
                  if (typeof checkedRadio[el.name] !== 'undefined') {
                      return;
                  }
              }
              prunedElements.push(el);
          });
          for(let index = prunedElements.findIndex((el)=>el === activeElement);;){
              index += shift ? -1 : 1;
              // loop at overflow
              if (index === prunedElements.length) {
                  index = 0;
              } else if (index === -1) {
                  index = prunedElements.length - 1;
              }
              if (prunedElements[index] === activeElement || prunedElements[index] === document.body || isVisible(prunedElements[index])) {
                  return prunedElements[index];
              }
          }
      }

      /**
       * Move the selection
       */ function moveSelection(node, direction) {
          // TODO: implement shift
          if (hasOwnSelection(node)) {
              const selection = getUISelection(node);
              setSelection({
                  focusNode: node,
                  focusOffset: selection.startOffset === selection.endOffset ? selection.focusOffset + direction : direction < 0 ? selection.startOffset : selection.endOffset
              });
          } else {
              const selection = node.ownerDocument.getSelection();
              if (!(selection === null || selection === undefined ? undefined : selection.focusNode)) {
                  return;
              }
              if (selection.isCollapsed) {
                  const nextPosition = getNextCursorPosition(selection.focusNode, selection.focusOffset, direction);
                  if (nextPosition) {
                      setSelection({
                          focusNode: nextPosition.node,
                          focusOffset: nextPosition.offset
                      });
                  }
              } else {
                  selection[direction < 0 ? 'collapseToStart' : 'collapseToEnd']();
              }
          }
      }

      /**
       * Expand a selection like the browser does when pressing Ctrl+A.
       */ function selectAll(target) {
          if (hasOwnSelection(target)) {
              return setSelection({
                  focusNode: target,
                  anchorOffset: 0,
                  focusOffset: getUIValue(target).length
              });
          }
          var _getContentEditable;
          const focusNode = (_getContentEditable = getContentEditable(target)) !== null && _getContentEditable !== undefined ? _getContentEditable : target.ownerDocument.body;
          setSelection({
              focusNode,
              anchorOffset: 0,
              focusOffset: focusNode.childNodes.length
          });
      }
      function isAllSelected(target) {
          if (hasOwnSelection(target)) {
              return getUISelection(target).startOffset === 0 && getUISelection(target).endOffset === getUIValue(target).length;
          }
          var _getContentEditable;
          const focusNode = (_getContentEditable = getContentEditable(target)) !== null && _getContentEditable !== undefined ? _getContentEditable : target.ownerDocument.body;
          const selection = target.ownerDocument.getSelection();
          return (selection === null || selection === undefined ? undefined : selection.anchorNode) === focusNode && selection.focusNode === focusNode && selection.anchorOffset === 0 && selection.focusOffset === focusNode.childNodes.length;
      }

      /**
       * Backward-compatible selection.
       *
       * Handles input elements and contenteditable if it only contains a single text node.
       */ function setSelectionRange(element, anchorOffset, focusOffset) {
          var _element_firstChild;
          if (hasOwnSelection(element)) {
              return setSelection({
                  focusNode: element,
                  anchorOffset,
                  focusOffset
              });
          }
          /* istanbul ignore else */ if (isContentEditable(element) && ((_element_firstChild = element.firstChild) === null || _element_firstChild === undefined ? undefined : _element_firstChild.nodeType) === 3) {
              return setSelection({
                  focusNode: element.firstChild,
                  anchorOffset,
                  focusOffset
              });
          }
          /* istanbul ignore next */ throw new Error('Not implemented. The result of this interaction is unreliable.');
      }

      function walkRadio(instance, el, direction) {
          const window = getWindow(el);
          const group = Array.from(el.ownerDocument.querySelectorAll(el.name ? `input[type="radio"][name="${window.CSS.escape(el.name)}"]` : `input[type="radio"][name=""], input[type="radio"]:not([name])`));
          for(let i = group.findIndex((e)=>e === el) + direction;; i += direction){
              if (!group[i]) {
                  i = direction > 0 ? 0 : group.length - 1;
              }
              if (group[i] === el) {
                  return;
              }
              if (isDisabled(group[i])) {
                  continue;
              }
              focusElement(group[i]);
              instance.dispatchUIEvent(group[i], 'click');
              return;
          }
      }

      behavior.keydown = (event, target, instance)=>{
          var _keydownBehavior_event_key;
          var _keydownBehavior_event_key1;
          return (_keydownBehavior_event_key1 = (_keydownBehavior_event_key = keydownBehavior[event.key]) === null || _keydownBehavior_event_key === undefined ? undefined : _keydownBehavior_event_key.call(keydownBehavior, event, target, instance)) !== null && _keydownBehavior_event_key1 !== undefined ? _keydownBehavior_event_key1 : combinationBehavior(event, target, instance);
      };
      const keydownBehavior = {
          ArrowDown: (event, target, instance)=>{
              /* istanbul ignore else */ if (isElementType(target, 'input', {
                  type: 'radio'
              })) {
                  return ()=>walkRadio(instance, target, 1);
              }
          },
          ArrowLeft: (event, target, instance)=>{
              if (isElementType(target, 'input', {
                  type: 'radio'
              })) {
                  return ()=>walkRadio(instance, target, -1);
              }
              return ()=>moveSelection(target, -1);
          },
          ArrowRight: (event, target, instance)=>{
              if (isElementType(target, 'input', {
                  type: 'radio'
              })) {
                  return ()=>walkRadio(instance, target, 1);
              }
              return ()=>moveSelection(target, 1);
          },
          ArrowUp: (event, target, instance)=>{
              /* istanbul ignore else */ if (isElementType(target, 'input', {
                  type: 'radio'
              })) {
                  return ()=>walkRadio(instance, target, -1);
              }
          },
          Backspace: (event, target, instance)=>{
              if (isEditable(target)) {
                  return ()=>{
                      input(instance, target, '', 'deleteContentBackward');
                  };
              }
          },
          Delete: (event, target, instance)=>{
              if (isEditable(target)) {
                  return ()=>{
                      input(instance, target, '', 'deleteContentForward');
                  };
              }
          },
          End: (event, target)=>{
              if (isElementType(target, [
                  'input',
                  'textarea'
              ]) || isContentEditable(target)) {
                  return ()=>{
                      var _getValueOrTextContent;
                      var _getValueOrTextContent_length;
                      const newPos = (_getValueOrTextContent_length = (_getValueOrTextContent = getValueOrTextContent(target)) === null || _getValueOrTextContent === undefined ? undefined : _getValueOrTextContent.length) !== null && _getValueOrTextContent_length !== undefined ? _getValueOrTextContent_length : /* istanbul ignore next */ 0;
                      setSelectionRange(target, newPos, newPos);
                  };
              }
          },
          Home: (event, target)=>{
              if (isElementType(target, [
                  'input',
                  'textarea'
              ]) || isContentEditable(target)) {
                  return ()=>{
                      setSelectionRange(target, 0, 0);
                  };
              }
          },
          PageDown: (event, target)=>{
              if (isElementType(target, [
                  'input'
              ])) {
                  return ()=>{
                      const newPos = getUIValue(target).length;
                      setSelectionRange(target, newPos, newPos);
                  };
              }
          },
          PageUp: (event, target)=>{
              if (isElementType(target, [
                  'input'
              ])) {
                  return ()=>{
                      setSelectionRange(target, 0, 0);
                  };
              }
          },
          Tab: (event, target, instance)=>{
              return ()=>{
                  const dest = getTabDestination(target, instance.system.keyboard.modifiers.Shift);
                  focusElement(dest);
                  if (hasOwnSelection(dest)) {
                      setUISelection(dest, {
                          anchorOffset: 0,
                          focusOffset: dest.value.length
                      });
                  }
              };
          }
      };
      const combinationBehavior = (event, target, instance)=>{
          if (event.code === 'KeyA' && instance.system.keyboard.modifiers.Control) {
              return ()=>selectAll(target);
          }
      };

      behavior.keypress = (event, target, instance)=>{
          if (event.key === 'Enter') {
              if (isElementType(target, 'button') || isElementType(target, 'input') && ClickInputOnEnter.includes(target.type) || isElementType(target, 'a') && Boolean(target.href)) {
                  return ()=>{
                      instance.dispatchUIEvent(target, 'click');
                  };
              } else if (isElementType(target, 'input')) {
                  const form = target.form;
                  const submit = form === null || form === undefined ? undefined : form.querySelector('input[type="submit"], button:not([type]), button[type="submit"]');
                  if (submit) {
                      return ()=>instance.dispatchUIEvent(submit, 'click');
                  } else if (form && SubmitSingleInputOnEnter.includes(target.type) && form.querySelectorAll('input').length === 1) {
                      return ()=>instance.dispatchUIEvent(form, 'submit');
                  } else {
                      return;
                  }
              }
          }
          if (isEditable(target)) {
              const inputType = event.key === 'Enter' ? isContentEditable(target) && !instance.system.keyboard.modifiers.Shift ? 'insertParagraph' : 'insertLineBreak' : 'insertText';
              const inputData = event.key === 'Enter' ? '\n' : event.key;
              return ()=>input(instance, target, inputData, inputType);
          }
      };
      const ClickInputOnEnter = [
          'button',
          'color',
          'file',
          'image',
          'reset',
          'submit'
      ];
      const SubmitSingleInputOnEnter = [
          'email',
          'month',
          'password',
          'search',
          'tel',
          'text',
          'url',
          'week'
      ];

      behavior.keyup = (event, target, instance)=>{
          var _keyupBehavior_event_key;
          return (_keyupBehavior_event_key = keyupBehavior[event.key]) === null || _keyupBehavior_event_key === undefined ? undefined : _keyupBehavior_event_key.call(keyupBehavior, event, target, instance);
      };
      const keyupBehavior = {
          ' ': (event, target, instance)=>{
              if (isClickableInput(target)) {
                  return ()=>instance.dispatchUIEvent(target, 'click');
              }
          }
      };

      behavior.paste = (event, target, instance)=>{
          if (isEditable(target)) {
              return ()=>{
                  var _event_clipboardData;
                  const insertData = (_event_clipboardData = event.clipboardData) === null || _event_clipboardData === undefined ? undefined : _event_clipboardData.getData('text');
                  if (insertData) {
                      input(instance, target, insertData, 'insertFromPaste');
                  }
              };
          }
      };

      const eventMap = {
          auxclick: {
              EventType: 'PointerEvent',
              defaultInit: {
                  bubbles: true,
                  cancelable: true,
                  composed: true
              }
          },
          beforeinput: {
              EventType: 'InputEvent',
              defaultInit: {
                  bubbles: true,
                  cancelable: true,
                  composed: true
              }
          },
          blur: {
              EventType: 'FocusEvent',
              defaultInit: {
                  bubbles: false,
                  cancelable: false,
                  composed: true
              }
          },
          click: {
              EventType: 'PointerEvent',
              defaultInit: {
                  bubbles: true,
                  cancelable: true,
                  composed: true
              }
          },
          contextmenu: {
              EventType: 'PointerEvent',
              defaultInit: {
                  bubbles: true,
                  cancelable: true,
                  composed: true
              }
          },
          copy: {
              EventType: 'ClipboardEvent',
              defaultInit: {
                  bubbles: true,
                  cancelable: true,
                  composed: true
              }
          },
          change: {
              EventType: 'Event',
              defaultInit: {
                  bubbles: true,
                  cancelable: false
              }
          },
          cut: {
              EventType: 'ClipboardEvent',
              defaultInit: {
                  bubbles: true,
                  cancelable: true,
                  composed: true
              }
          },
          dblclick: {
              EventType: 'MouseEvent',
              defaultInit: {
                  bubbles: true,
                  cancelable: true,
                  composed: true
              }
          },
          focus: {
              EventType: 'FocusEvent',
              defaultInit: {
                  bubbles: false,
                  cancelable: false,
                  composed: true
              }
          },
          focusin: {
              EventType: 'FocusEvent',
              defaultInit: {
                  bubbles: true,
                  cancelable: false,
                  composed: true
              }
          },
          focusout: {
              EventType: 'FocusEvent',
              defaultInit: {
                  bubbles: true,
                  cancelable: false,
                  composed: true
              }
          },
          keydown: {
              EventType: 'KeyboardEvent',
              defaultInit: {
                  bubbles: true,
                  cancelable: true,
                  composed: true
              }
          },
          keypress: {
              EventType: 'KeyboardEvent',
              defaultInit: {
                  bubbles: true,
                  cancelable: true,
                  composed: true
              }
          },
          keyup: {
              EventType: 'KeyboardEvent',
              defaultInit: {
                  bubbles: true,
                  cancelable: true,
                  composed: true
              }
          },
          paste: {
              EventType: 'ClipboardEvent',
              defaultInit: {
                  bubbles: true,
                  cancelable: true,
                  composed: true
              }
          },
          input: {
              EventType: 'InputEvent',
              defaultInit: {
                  bubbles: true,
                  cancelable: false,
                  composed: true
              }
          },
          mousedown: {
              EventType: 'MouseEvent',
              defaultInit: {
                  bubbles: true,
                  cancelable: true,
                  composed: true
              }
          },
          mouseenter: {
              EventType: 'MouseEvent',
              defaultInit: {
                  bubbles: false,
                  cancelable: false,
                  composed: true
              }
          },
          mouseleave: {
              EventType: 'MouseEvent',
              defaultInit: {
                  bubbles: false,
                  cancelable: false,
                  composed: true
              }
          },
          mousemove: {
              EventType: 'MouseEvent',
              defaultInit: {
                  bubbles: true,
                  cancelable: true,
                  composed: true
              }
          },
          mouseout: {
              EventType: 'MouseEvent',
              defaultInit: {
                  bubbles: true,
                  cancelable: true,
                  composed: true
              }
          },
          mouseover: {
              EventType: 'MouseEvent',
              defaultInit: {
                  bubbles: true,
                  cancelable: true,
                  composed: true
              }
          },
          mouseup: {
              EventType: 'MouseEvent',
              defaultInit: {
                  bubbles: true,
                  cancelable: true,
                  composed: true
              }
          },
          pointerover: {
              EventType: 'PointerEvent',
              defaultInit: {
                  bubbles: true,
                  cancelable: true,
                  composed: true
              }
          },
          pointerenter: {
              EventType: 'PointerEvent',
              defaultInit: {
                  bubbles: false,
                  cancelable: false
              }
          },
          pointerdown: {
              EventType: 'PointerEvent',
              defaultInit: {
                  bubbles: true,
                  cancelable: true,
                  composed: true
              }
          },
          pointermove: {
              EventType: 'PointerEvent',
              defaultInit: {
                  bubbles: true,
                  cancelable: true,
                  composed: true
              }
          },
          pointerup: {
              EventType: 'PointerEvent',
              defaultInit: {
                  bubbles: true,
                  cancelable: true,
                  composed: true
              }
          },
          pointercancel: {
              EventType: 'PointerEvent',
              defaultInit: {
                  bubbles: true,
                  cancelable: false,
                  composed: true
              }
          },
          pointerout: {
              EventType: 'PointerEvent',
              defaultInit: {
                  bubbles: true,
                  cancelable: true,
                  composed: true
              }
          },
          pointerleave: {
              EventType: 'PointerEvent',
              defaultInit: {
                  bubbles: false,
                  cancelable: false
              }
          },
          submit: {
              EventType: 'Event',
              defaultInit: {
                  bubbles: true,
                  cancelable: true
              }
          }
      };
      function getEventClass(type) {
          return eventMap[type].EventType;
      }
      const mouseEvents = [
          'MouseEvent',
          'PointerEvent'
      ];
      function isMouseEvent(type) {
          return mouseEvents.includes(getEventClass(type));
      }
      function isKeyboardEvent(type) {
          return getEventClass(type) === 'KeyboardEvent';
      }

      const eventInitializer = {
          ClipboardEvent: [
              initClipboardEvent
          ],
          Event: [],
          FocusEvent: [
              initUIEvent,
              initFocusEvent
          ],
          InputEvent: [
              initUIEvent,
              initInputEvent
          ],
          MouseEvent: [
              initUIEvent,
              initUIEventModifiers,
              initMouseEvent
          ],
          PointerEvent: [
              initUIEvent,
              initUIEventModifiers,
              initMouseEvent,
              initPointerEvent
          ],
          KeyboardEvent: [
              initUIEvent,
              initUIEventModifiers,
              initKeyboardEvent
          ]
      };
      function createEvent(type, target, init) {
          const window = getWindow(target);
          const { EventType, defaultInit } = eventMap[type];
          const event = new (getEventConstructors(window))[EventType](type, defaultInit);
          eventInitializer[EventType].forEach((f)=>f(event, init !== null && init !== undefined ? init : {}));
          return event;
      }
      /* istanbul ignore next */ function getEventConstructors(window) {
          var _window_Event;
          /* eslint-disable @typescript-eslint/no-unnecessary-condition, @typescript-eslint/no-extraneous-class */ const Event = (_window_Event = window.Event) !== null && _window_Event !== undefined ? _window_Event : class Event {
          };
          var _window_AnimationEvent;
          const AnimationEvent = (_window_AnimationEvent = window.AnimationEvent) !== null && _window_AnimationEvent !== undefined ? _window_AnimationEvent : class AnimationEvent extends Event {
          };
          var _window_ClipboardEvent;
          const ClipboardEvent = (_window_ClipboardEvent = window.ClipboardEvent) !== null && _window_ClipboardEvent !== undefined ? _window_ClipboardEvent : class ClipboardEvent extends Event {
          };
          var _window_PopStateEvent;
          const PopStateEvent = (_window_PopStateEvent = window.PopStateEvent) !== null && _window_PopStateEvent !== undefined ? _window_PopStateEvent : class PopStateEvent extends Event {
          };
          var _window_ProgressEvent;
          const ProgressEvent = (_window_ProgressEvent = window.ProgressEvent) !== null && _window_ProgressEvent !== undefined ? _window_ProgressEvent : class ProgressEvent extends Event {
          };
          var _window_TransitionEvent;
          const TransitionEvent = (_window_TransitionEvent = window.TransitionEvent) !== null && _window_TransitionEvent !== undefined ? _window_TransitionEvent : class TransitionEvent extends Event {
          };
          var _window_UIEvent;
          const UIEvent = (_window_UIEvent = window.UIEvent) !== null && _window_UIEvent !== undefined ? _window_UIEvent : class UIEvent extends Event {
          };
          var _window_CompositionEvent;
          const CompositionEvent = (_window_CompositionEvent = window.CompositionEvent) !== null && _window_CompositionEvent !== undefined ? _window_CompositionEvent : class CompositionEvent extends UIEvent {
          };
          var _window_FocusEvent;
          const FocusEvent = (_window_FocusEvent = window.FocusEvent) !== null && _window_FocusEvent !== undefined ? _window_FocusEvent : class FocusEvent extends UIEvent {
          };
          var _window_InputEvent;
          const InputEvent = (_window_InputEvent = window.InputEvent) !== null && _window_InputEvent !== undefined ? _window_InputEvent : class InputEvent extends UIEvent {
          };
          var _window_KeyboardEvent;
          const KeyboardEvent = (_window_KeyboardEvent = window.KeyboardEvent) !== null && _window_KeyboardEvent !== undefined ? _window_KeyboardEvent : class KeyboardEvent extends UIEvent {
          };
          var _window_MouseEvent;
          const MouseEvent = (_window_MouseEvent = window.MouseEvent) !== null && _window_MouseEvent !== undefined ? _window_MouseEvent : class MouseEvent extends UIEvent {
          };
          var _window_DragEvent;
          const DragEvent = (_window_DragEvent = window.DragEvent) !== null && _window_DragEvent !== undefined ? _window_DragEvent : class DragEvent extends MouseEvent {
          };
          var _window_PointerEvent;
          const PointerEvent = (_window_PointerEvent = window.PointerEvent) !== null && _window_PointerEvent !== undefined ? _window_PointerEvent : class PointerEvent extends MouseEvent {
          };
          var _window_TouchEvent;
          const TouchEvent = (_window_TouchEvent = window.TouchEvent) !== null && _window_TouchEvent !== undefined ? _window_TouchEvent : class TouchEvent extends UIEvent {
          };
          /* eslint-enable @typescript-eslint/no-unnecessary-condition, @typescript-eslint/no-extraneous-class */ return {
              Event,
              AnimationEvent,
              ClipboardEvent,
              PopStateEvent,
              ProgressEvent,
              TransitionEvent,
              UIEvent,
              CompositionEvent,
              FocusEvent,
              InputEvent,
              KeyboardEvent,
              MouseEvent,
              DragEvent,
              PointerEvent,
              TouchEvent
          };
      }
      function assignProps(obj, props) {
          for (const [key, value] of Object.entries(props)){
              Object.defineProperty(obj, key, {
                  get: ()=>value !== null && value !== undefined ? value : null
              });
          }
      }
      function sanitizeNumber(n) {
          return Number(n !== null && n !== undefined ? n : 0);
      }
      function initClipboardEvent(event, { clipboardData }) {
          assignProps(event, {
              clipboardData
          });
      }
      function initFocusEvent(event, { relatedTarget }) {
          assignProps(event, {
              relatedTarget
          });
      }
      function initInputEvent(event, { data, inputType, isComposing }) {
          assignProps(event, {
              data,
              isComposing: Boolean(isComposing),
              inputType: String(inputType)
          });
      }
      function initUIEvent(event, { view, detail }) {
          assignProps(event, {
              view,
              detail: sanitizeNumber(detail !== null && detail !== undefined ? detail : 0)
          });
      }
      function initUIEventModifiers(event, { altKey, ctrlKey, metaKey, shiftKey, modifierAltGraph, modifierCapsLock, modifierFn, modifierFnLock, modifierNumLock, modifierScrollLock, modifierSymbol, modifierSymbolLock }) {
          assignProps(event, {
              altKey: Boolean(altKey),
              ctrlKey: Boolean(ctrlKey),
              metaKey: Boolean(metaKey),
              shiftKey: Boolean(shiftKey),
              getModifierState (k) {
                  return Boolean({
                      Alt: altKey,
                      AltGraph: modifierAltGraph,
                      CapsLock: modifierCapsLock,
                      Control: ctrlKey,
                      Fn: modifierFn,
                      FnLock: modifierFnLock,
                      Meta: metaKey,
                      NumLock: modifierNumLock,
                      ScrollLock: modifierScrollLock,
                      Shift: shiftKey,
                      Symbol: modifierSymbol,
                      SymbolLock: modifierSymbolLock
                  }[k]);
              }
          });
      }
      function initKeyboardEvent(event, { key, code, location, repeat, isComposing, charCode }) {
          assignProps(event, {
              key: String(key),
              code: String(code),
              location: sanitizeNumber(location),
              repeat: Boolean(repeat),
              isComposing: Boolean(isComposing),
              charCode
          });
      }
      function initMouseEvent(event, { x, y, screenX, screenY, clientX = x, clientY = y, button, buttons, relatedTarget, offsetX, offsetY, pageX, pageY }) {
          assignProps(event, {
              screenX: sanitizeNumber(screenX),
              screenY: sanitizeNumber(screenY),
              clientX: sanitizeNumber(clientX),
              x: sanitizeNumber(clientX),
              clientY: sanitizeNumber(clientY),
              y: sanitizeNumber(clientY),
              button: sanitizeNumber(button),
              buttons: sanitizeNumber(buttons),
              relatedTarget,
              offsetX: sanitizeNumber(offsetX),
              offsetY: sanitizeNumber(offsetY),
              pageX: sanitizeNumber(pageX),
              pageY: sanitizeNumber(pageY)
          });
      }
      function initPointerEvent(event, { pointerId, width, height, pressure, tangentialPressure, tiltX, tiltY, twist, pointerType, isPrimary }) {
          assignProps(event, {
              pointerId: sanitizeNumber(pointerId),
              width: sanitizeNumber(width !== null && width !== undefined ? width : 1),
              height: sanitizeNumber(height !== null && height !== undefined ? height : 1),
              pressure: sanitizeNumber(pressure),
              tangentialPressure: sanitizeNumber(tangentialPressure),
              tiltX: sanitizeNumber(tiltX),
              tiltY: sanitizeNumber(tiltY),
              twist: sanitizeNumber(twist),
              pointerType: String(pointerType),
              isPrimary: Boolean(isPrimary)
          });
      }

      function dispatchUIEvent(target, type, init, preventDefault = false) {
          if (isMouseEvent(type) || isKeyboardEvent(type)) {
              init = {
                  ...init,
                  ...this.system.getUIEventModifiers()
              };
          }
          const event = createEvent(type, target, init);
          return dispatchEvent.call(this, target, event, preventDefault);
      }
      function dispatchEvent(target, event, preventDefault = false) {
          var _behavior_type;
          const type = event.type;
          const behaviorImplementation = preventDefault ? ()=>{} : (_behavior_type = behavior[type]) === null || _behavior_type === undefined ? undefined : _behavior_type.call(behavior, event, target, this);
          if (behaviorImplementation) {
              event.preventDefault();
              let defaultPrevented = false;
              Object.defineProperty(event, 'defaultPrevented', {
                  get: ()=>defaultPrevented
              });
              Object.defineProperty(event, 'preventDefault', {
                  value: ()=>{
                      defaultPrevented = event.cancelable;
                  }
              });
              wrapEvent(()=>target.dispatchEvent(event));
              if (!defaultPrevented) {
                  behaviorImplementation();
              }
              return !defaultPrevented;
          }
          return wrapEvent(()=>target.dispatchEvent(event));
      }
      function dispatchDOMEvent(target, type, init) {
          const event = createEvent(type, target, init);
          wrapEvent(()=>target.dispatchEvent(event));
      }

      const patched = Symbol('patched focus/blur methods');
      function patchFocus(HTMLElement) {
          if (HTMLElement.prototype[patched]) {
              return;
          }
          // eslint-disable-next-line @typescript-eslint/unbound-method
          const { focus, blur } = HTMLElement.prototype;
          Object.defineProperties(HTMLElement.prototype, {
              focus: {
                  configurable: true,
                  get: ()=>patchedFocus
              },
              blur: {
                  configurable: true,
                  get: ()=>patchedBlur
              },
              [patched]: {
                  configurable: true,
                  get: ()=>({
                          focus,
                          blur
                      })
              }
          });
          let activeCall;
          function patchedFocus(options) {
              if (this.ownerDocument.visibilityState !== 'hidden') {
                  return focus.call(this, options);
              }
              const blurred = getActiveTarget(this.ownerDocument);
              if (blurred === this) {
                  return;
              }
              const thisCall = Symbol('focus call');
              activeCall = thisCall;
              if (blurred) {
                  blur.call(blurred);
                  dispatchDOMEvent(blurred, 'blur', {
                      relatedTarget: this
                  });
                  dispatchDOMEvent(blurred, 'focusout', {
                      relatedTarget: activeCall === thisCall ? this : null
                  });
              }
              if (activeCall === thisCall) {
                  focus.call(this, options);
                  dispatchDOMEvent(this, 'focus', {
                      relatedTarget: blurred
                  });
              }
              if (activeCall === thisCall) {
                  dispatchDOMEvent(this, 'focusin', {
                      relatedTarget: blurred
                  });
              }
          }
          function patchedBlur() {
              if (this.ownerDocument.visibilityState !== 'hidden') {
                  return blur.call(this);
              }
              const blurred = getActiveTarget(this.ownerDocument);
              if (blurred !== this) {
                  return;
              }
              const thisCall = Symbol('blur call');
              activeCall = thisCall;
              blur.call(this);
              dispatchDOMEvent(blurred, 'blur', {
                  relatedTarget: null
              });
              dispatchDOMEvent(blurred, 'focusout', {
                  relatedTarget: null
              });
          }
      }
      function getActiveTarget(document) {
          const active = getActiveElement(document);
          return (active === null || active === undefined ? undefined : active.tagName) === 'BODY' ? null : active;
      }

      const Interceptor = Symbol('Interceptor for programmatical calls');
      function prepareInterceptor(element, propName, interceptorImpl) {
          const prototypeDescriptor = Object.getOwnPropertyDescriptor(element.constructor.prototype, propName);
          const objectDescriptor = Object.getOwnPropertyDescriptor(element, propName);
          const target = (prototypeDescriptor === null || prototypeDescriptor === undefined ? undefined : prototypeDescriptor.set) ? 'set' : 'value';
          /* istanbul ignore if */ if (typeof (prototypeDescriptor === null || prototypeDescriptor === undefined ? undefined : prototypeDescriptor[target]) !== 'function' || prototypeDescriptor[target][Interceptor]) {
              throw new Error(`Element ${element.tagName} does not implement "${String(propName)}".`);
          }
          function intercept(...args) {
              const { applyNative = false, realArgs, then } = interceptorImpl.call(this, ...args);
              const realFunc = (!applyNative && objectDescriptor || prototypeDescriptor)[target];
              if (target === 'set') {
                  realFunc.call(this, realArgs);
              } else {
                  realFunc.call(this, ...realArgs);
              }
              then === null || then === undefined ? undefined : then();
          }
          intercept[Interceptor] = Interceptor;
          Object.defineProperty(element, propName, {
              ...objectDescriptor !== null && objectDescriptor !== undefined ? objectDescriptor : prototypeDescriptor,
              [target]: intercept
          });
      }
      function prepareValueInterceptor(element) {
          prepareInterceptor(element, 'value', function interceptorImpl(v) {
              const isUI = isUIValue(v);
              if (isUI) {
                  startTrackValue(this);
              }
              return {
                  applyNative: !!isUI,
                  realArgs: sanitizeValue(this, v),
                  then: isUI ? undefined : ()=>trackOrSetValue(this, String(v))
              };
          });
      }
      function sanitizeValue(element, v) {
          // Workaround for JSDOM
          if (isElementType(element, 'input', {
              type: 'number'
          }) && String(v) !== '' && !Number.isNaN(Number(v))) {
              // Setting value to "1." results in `null` in JSDOM
              return String(Number(v));
          }
          return String(v);
      }
      function prepareSelectionInterceptor(element) {
          prepareInterceptor(element, 'setSelectionRange', function interceptorImpl(start, ...others) {
              const isUI = isUISelectionStart(start);
              return {
                  applyNative: !!isUI,
                  realArgs: [
                      Number(start),
                      ...others
                  ],
                  then: ()=>isUI ? undefined : setUISelectionClean(element)
              };
          });
          prepareInterceptor(element, 'selectionStart', function interceptorImpl(v) {
              return {
                  realArgs: v,
                  then: ()=>setUISelectionClean(element)
              };
          });
          prepareInterceptor(element, 'selectionEnd', function interceptorImpl(v) {
              return {
                  realArgs: v,
                  then: ()=>setUISelectionClean(element)
              };
          });
          prepareInterceptor(element, 'select', function interceptorImpl() {
              return {
                  realArgs: [],
                  then: ()=>setUISelectionRaw(element, {
                          anchorOffset: 0,
                          focusOffset: getUIValue(element).length
                      })
              };
          });
      }
      function prepareRangeTextInterceptor(element) {
          prepareInterceptor(element, 'setRangeText', function interceptorImpl(...realArgs) {
              return {
                  realArgs,
                  then: ()=>{
                      setUIValueClean(element);
                      setUISelectionClean(element);
                  }
              };
          });
      }

      const isPrepared = Symbol('Node prepared with document state workarounds');
      function prepareDocument(document) {
          if (document[isPrepared]) {
              return;
          }
          document.addEventListener('focus', (e)=>{
              const el = e.target;
              prepareElement(el);
          }, {
              capture: true,
              passive: true
          });
          // Our test environment defaults to `document.body` as `activeElement`.
          // In other environments this might be `null` when preparing.
          // istanbul ignore else
          if (document.activeElement) {
              prepareElement(document.activeElement);
          }
          document.addEventListener('blur', (e)=>{
              const el = e.target;
              const initialValue = getInitialValue(el);
              if (initialValue !== undefined) {
                  if (el.value !== initialValue) {
                      dispatchDOMEvent(el, 'change');
                  }
                  clearInitialValue(el);
              }
          }, {
              capture: true,
              passive: true
          });
          document[isPrepared] = isPrepared;
      }
      function prepareElement(el) {
          if (el[isPrepared]) {
              return;
          }
          if (isElementType(el, [
              'input',
              'textarea'
          ])) {
              prepareValueInterceptor(el);
              prepareSelectionInterceptor(el);
              prepareRangeTextInterceptor(el);
          }
          el[isPrepared] = isPrepared;
      }

      function getDocumentFromNode(el) {
          return isDocument(el) ? el : el.ownerDocument;
      }
      function isDocument(node) {
          return node.nodeType === 9;
      }

      var ApiLevel = /*#__PURE__*/ function(ApiLevel) {
          ApiLevel[ApiLevel["Trigger"] = 2] = "Trigger";
          ApiLevel[ApiLevel["Call"] = 1] = "Call";
          return ApiLevel;
      }({});
      function setLevelRef(instance, level) {
          instance.levelRefs[level] = {};
      }
      function getLevelRef(instance, level) {
          return instance.levelRefs[level];
      }

      function wait(config) {
          const delay = config.delay;
          if (typeof delay !== 'number') {
              return;
          }
          return Promise.all([
              new Promise((resolve)=>globalThis.setTimeout(()=>resolve(), delay)),
              config.advanceTimers(delay)
          ]);
      }

      var PointerEventsCheckLevel = /*#__PURE__*/ function(PointerEventsCheckLevel) {
          /**
         * Check pointer events on every user interaction that triggers a bunch of events.
         * E.g. once for releasing a mouse button even though this triggers `pointerup`, `mouseup`, `click`, etc...
         */ PointerEventsCheckLevel[PointerEventsCheckLevel["EachTrigger"] = 4] = "EachTrigger";
          /** Check each target once per call to pointer (related) API */ PointerEventsCheckLevel[PointerEventsCheckLevel["EachApiCall"] = 2] = "EachApiCall";
          /** Check each event target once */ PointerEventsCheckLevel[PointerEventsCheckLevel["EachTarget"] = 1] = "EachTarget";
          /** No pointer events check */ PointerEventsCheckLevel[PointerEventsCheckLevel["Never"] = 0] = "Never";
          return PointerEventsCheckLevel;
      }({});

      function _define_property$6(obj, key, value) {
          if (key in obj) {
              Object.defineProperty(obj, key, {
                  value: value,
                  enumerable: true,
                  configurable: true,
                  writable: true
              });
          } else {
              obj[key] = value;
          }
          return obj;
      }
      var DOM_KEY_LOCATION = /*#__PURE__*/ function(DOM_KEY_LOCATION) {
          DOM_KEY_LOCATION[DOM_KEY_LOCATION["STANDARD"] = 0] = "STANDARD";
          DOM_KEY_LOCATION[DOM_KEY_LOCATION["LEFT"] = 1] = "LEFT";
          DOM_KEY_LOCATION[DOM_KEY_LOCATION["RIGHT"] = 2] = "RIGHT";
          DOM_KEY_LOCATION[DOM_KEY_LOCATION["NUMPAD"] = 3] = "NUMPAD";
          return DOM_KEY_LOCATION;
      }({});
      const modifierKeys = [
          'Alt',
          'AltGraph',
          'Control',
          'Fn',
          'Meta',
          'Shift',
          'Symbol'
      ];
      function isModifierKey(key) {
          return modifierKeys.includes(key);
      }
      const modifierLocks = [
          'CapsLock',
          'FnLock',
          'NumLock',
          'ScrollLock',
          'SymbolLock'
      ];
      function isModifierLock(key) {
          return modifierLocks.includes(key);
      }
      class KeyboardHost {
          isKeyPressed(keyDef) {
              return this.pressed.has(String(keyDef.code));
          }
          getPressedKeys() {
              return this.pressed.values().map((p)=>p.keyDef);
          }
          /** Press a key */ async keydown(instance, keyDef) {
              const key = String(keyDef.key);
              const code = String(keyDef.code);
              const target = getActiveElementOrBody(instance.config.document);
              this.setKeydownTarget(target);
              this.pressed.add(code, keyDef);
              if (isModifierKey(key)) {
                  this.modifiers[key] = true;
              }
              const unprevented = instance.dispatchUIEvent(target, 'keydown', {
                  key,
                  code
              });
              if (isModifierLock(key) && !this.modifiers[key]) {
                  this.modifiers[key] = true;
                  this.modifierLockStart[key] = true;
              }
              if (unprevented) {
                  this.pressed.setUnprevented(code);
              }
              if (unprevented && this.hasKeyPress(key)) {
                  instance.dispatchUIEvent(getActiveElementOrBody(instance.config.document), 'keypress', {
                      key,
                      code,
                      charCode: keyDef.key === 'Enter' ? 13 : String(keyDef.key).charCodeAt(0)
                  });
              }
          }
          /** Release a key */ async keyup(instance, keyDef) {
              const key = String(keyDef.key);
              const code = String(keyDef.code);
              const unprevented = this.pressed.isUnprevented(code);
              this.pressed.delete(code);
              if (isModifierKey(key) && !this.pressed.values().find((p)=>p.keyDef.key === key)) {
                  this.modifiers[key] = false;
              }
              instance.dispatchUIEvent(getActiveElementOrBody(instance.config.document), 'keyup', {
                  key,
                  code
              }, !unprevented);
              if (isModifierLock(key) && this.modifiers[key]) {
                  if (this.modifierLockStart[key]) {
                      this.modifierLockStart[key] = false;
                  } else {
                      this.modifiers[key] = false;
                  }
              }
          }
          setKeydownTarget(target) {
              if (target !== this.lastKeydownTarget) {
                  this.carryChar = '';
              }
              this.lastKeydownTarget = target;
          }
          hasKeyPress(key) {
              return (key.length === 1 || key === 'Enter') && !this.modifiers.Control && !this.modifiers.Alt;
          }
          constructor(system){
              _define_property$6(this, "system", undefined);
              _define_property$6(this, "modifiers", {
                  Alt: false,
                  AltGraph: false,
                  CapsLock: false,
                  Control: false,
                  Fn: false,
                  FnLock: false,
                  Meta: false,
                  NumLock: false,
                  ScrollLock: false,
                  Shift: false,
                  Symbol: false,
                  SymbolLock: false
              });
              _define_property$6(this, "pressed", new class {
                  add(code, keyDef) {
                      var _this_registry, _code;
                      var _;
                      (_ = (_this_registry = this.registry)[_code = code]) !== null && _ !== undefined ? _ : _this_registry[_code] = {
                          keyDef,
                          unpreventedDefault: false
                      };
                  }
                  has(code) {
                      return !!this.registry[code];
                  }
                  setUnprevented(code) {
                      const o = this.registry[code];
                      if (o) {
                          o.unpreventedDefault = true;
                      }
                  }
                  isUnprevented(code) {
                      var _this_registry_code;
                      return !!((_this_registry_code = this.registry[code]) === null || _this_registry_code === undefined ? undefined : _this_registry_code.unpreventedDefault);
                  }
                  delete(code) {
                      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
                      delete this.registry[code];
                  }
                  values() {
                      return Object.values(this.registry);
                  }
                  constructor(){
                      _define_property$6(this, "registry", {});
                  }
              }());
              _define_property$6(this, "carryChar", '');
              _define_property$6(this, "lastKeydownTarget", undefined);
              _define_property$6(this, "modifierLockStart", {});
              this.system = system;
          }
      }

      /**
       * Mapping for a default US-104-QWERTY keyboard
       */ const defaultKeyMap$1 = [
          // alphanumeric block - writing system
          ...'0123456789'.split('').map((c)=>({
                  code: `Digit${c}`,
                  key: c
              })),
          ...')!@#$%^&*('.split('').map((c, i)=>({
                  code: `Digit${i}`,
                  key: c,
                  shiftKey: true
              })),
          ...'abcdefghijklmnopqrstuvwxyz'.split('').map((c)=>({
                  code: `Key${c.toUpperCase()}`,
                  key: c
              })),
          ...'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('').map((c)=>({
                  code: `Key${c}`,
                  key: c,
                  shiftKey: true
              })),
          {
              code: 'BracketLeft',
              key: '['
          },
          {
              code: 'BracketLeft',
              key: '{',
              shiftKey: true
          },
          {
              code: 'BracketRight',
              key: ']'
          },
          {
              code: 'BracketRight',
              key: '}',
              shiftKey: true
          },
          // alphanumeric block - functional
          {
              code: 'Space',
              key: ' '
          },
          {
              code: 'AltLeft',
              key: 'Alt',
              location: DOM_KEY_LOCATION.LEFT
          },
          {
              code: 'AltRight',
              key: 'Alt',
              location: DOM_KEY_LOCATION.RIGHT
          },
          {
              code: 'ShiftLeft',
              key: 'Shift',
              location: DOM_KEY_LOCATION.LEFT
          },
          {
              code: 'ShiftRight',
              key: 'Shift',
              location: DOM_KEY_LOCATION.RIGHT
          },
          {
              code: 'ControlLeft',
              key: 'Control',
              location: DOM_KEY_LOCATION.LEFT
          },
          {
              code: 'ControlRight',
              key: 'Control',
              location: DOM_KEY_LOCATION.RIGHT
          },
          {
              code: 'MetaLeft',
              key: 'Meta',
              location: DOM_KEY_LOCATION.LEFT
          },
          {
              code: 'MetaRight',
              key: 'Meta',
              location: DOM_KEY_LOCATION.RIGHT
          },
          {
              code: 'OSLeft',
              key: 'OS',
              location: DOM_KEY_LOCATION.LEFT
          },
          {
              code: 'OSRight',
              key: 'OS',
              location: DOM_KEY_LOCATION.RIGHT
          },
          {
              code: 'ContextMenu',
              key: 'ContextMenu'
          },
          {
              code: 'Tab',
              key: 'Tab'
          },
          {
              code: 'CapsLock',
              key: 'CapsLock'
          },
          {
              code: 'Backspace',
              key: 'Backspace'
          },
          {
              code: 'Enter',
              key: 'Enter'
          },
          // function
          {
              code: 'Escape',
              key: 'Escape'
          },
          // arrows
          {
              code: 'ArrowUp',
              key: 'ArrowUp'
          },
          {
              code: 'ArrowDown',
              key: 'ArrowDown'
          },
          {
              code: 'ArrowLeft',
              key: 'ArrowLeft'
          },
          {
              code: 'ArrowRight',
              key: 'ArrowRight'
          },
          // control pad
          {
              code: 'Home',
              key: 'Home'
          },
          {
              code: 'End',
              key: 'End'
          },
          {
              code: 'Delete',
              key: 'Delete'
          },
          {
              code: 'PageUp',
              key: 'PageUp'
          },
          {
              code: 'PageDown',
              key: 'PageDown'
          },
          // Special keys that are not part of a default US-layout but included for specific behavior
          {
              code: 'Fn',
              key: 'Fn'
          },
          {
              code: 'Symbol',
              key: 'Symbol'
          },
          {
              code: 'AltRight',
              key: 'AltGraph'
          }
      ];

      const defaultKeyMap = [
          {
              name: 'MouseLeft',
              pointerType: 'mouse',
              button: 'primary'
          },
          {
              name: 'MouseRight',
              pointerType: 'mouse',
              button: 'secondary'
          },
          {
              name: 'MouseMiddle',
              pointerType: 'mouse',
              button: 'auxiliary'
          },
          {
              name: 'TouchA',
              pointerType: 'touch'
          },
          {
              name: 'TouchB',
              pointerType: 'touch'
          },
          {
              name: 'TouchC',
              pointerType: 'touch'
          }
      ];

      function _define_property$5(obj, key, value) {
          if (key in obj) {
              Object.defineProperty(obj, key, {
                  value: value,
                  enumerable: true,
                  configurable: true,
                  writable: true
              });
          } else {
              obj[key] = value;
          }
          return obj;
      }
      class Buttons {
          getButtons() {
              let v = 0;
              for (const button of Object.keys(this.pressed)){
                  // eslint-disable-next-line no-bitwise
                  v |= 2 ** Number(button);
              }
              return v;
          }
          down(keyDef) {
              const button = getMouseButtonId(keyDef.button);
              if (button in this.pressed) {
                  this.pressed[button].push(keyDef);
                  return undefined;
              }
              this.pressed[button] = [
                  keyDef
              ];
              return button;
          }
          up(keyDef) {
              const button = getMouseButtonId(keyDef.button);
              if (button in this.pressed) {
                  this.pressed[button] = this.pressed[button].filter((k)=>k.name !== keyDef.name);
                  if (this.pressed[button].length === 0) {
                      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
                      delete this.pressed[button];
                      return button;
                  }
              }
              return undefined;
          }
          constructor(){
              _define_property$5(this, "pressed", {});
          }
      }
      const MouseButton = {
          primary: 0,
          secondary: 1,
          auxiliary: 2,
          back: 3,
          X1: 3,
          forward: 4,
          X2: 4
      };
      function getMouseButtonId(button = 0) {
          if (button in MouseButton) {
              return MouseButton[button];
          }
          return Number(button);
      }
      // On the `MouseEvent.button` property auxiliary and secondary button are flipped compared to `MouseEvent.buttons`.
      const MouseButtonFlip = {
          1: 2,
          2: 1
      };
      function getMouseEventButton(button) {
          button = getMouseButtonId(button);
          if (button in MouseButtonFlip) {
              return MouseButtonFlip[button];
          }
          return button;
      }

      function _define_property$4(obj, key, value) {
          if (key in obj) {
              Object.defineProperty(obj, key, {
                  value: value,
                  enumerable: true,
                  configurable: true,
                  writable: true
              });
          } else {
              obj[key] = value;
          }
          return obj;
      }
      class Device {
          get countPressed() {
              return this.pressedKeys.size;
          }
          isPressed(keyDef) {
              return this.pressedKeys.has(keyDef.name);
          }
          addPressed(keyDef) {
              return this.pressedKeys.add(keyDef.name);
          }
          removePressed(keyDef) {
              return this.pressedKeys.delete(keyDef.name);
          }
          constructor(){
              _define_property$4(this, "pressedKeys", new Set());
          }
      }

      function getTreeDiff(a, b) {
          const treeA = [];
          for(let el = a; el; el = el.parentElement){
              treeA.push(el);
          }
          const treeB = [];
          for(let el = b; el; el = el.parentElement){
              treeB.push(el);
          }
          let i = 0;
          for(;; i++){
              if (i >= treeA.length || i >= treeB.length || treeA[treeA.length - 1 - i] !== treeB[treeB.length - 1 - i]) {
                  break;
              }
          }
          return [
              treeA.slice(0, treeA.length - i),
              treeB.slice(0, treeB.length - i),
              treeB.slice(treeB.length - i)
          ];
      }

      function resolveCaretPosition({ target, node, offset }) {
          if (hasOwnSelection(target)) {
              return {
                  node: target,
                  offset: offset !== null && offset !== undefined ? offset : getUIValue(target).length
              };
          } else if (node) {
              return {
                  node,
                  offset: offset !== null && offset !== undefined ? offset : node.nodeType === 3 ? node.nodeValue.length : node.childNodes.length
              };
          }
          return findNodeAtTextOffset(target, offset);
      }
      function findNodeAtTextOffset(node, offset, isRoot = true) {
          // When clicking after the content the browser behavior can be complicated:
          // 1. If there is textContent after the last element child,
          // the cursor is moved there.
          // 2. If there is textContent in the last element child,
          // the browser moves the cursor to the last non-empty text node inside this element.
          // 3. Otherwise the cursor is moved to the end of the target.
          let i = offset === undefined ? node.childNodes.length - 1 : 0;
          const step = offset === undefined ? -1 : 1;
          while(offset === undefined ? i >= (isRoot ? Math.max(node.childNodes.length - 1, 0) : 0) : i <= node.childNodes.length){
              if (offset && i === node.childNodes.length) {
                  throw new Error('The given offset is out of bounds.');
              }
              const c = node.childNodes.item(i);
              const text = String(c.textContent);
              if (text.length) {
                  if (offset !== undefined && text.length < offset) {
                      offset -= text.length;
                  } else if (c.nodeType === 1) {
                      return findNodeAtTextOffset(c, offset, false);
                  } else {
                      // The pre-commit hooks keeps changing this
                      // See https://github.com/kentcdodds/kcd-scripts/issues/218
                      /* istanbul ignore else */ // eslint-disable-next-line no-lonely-if
                      if (c.nodeType === 3) {
                          return {
                              node: c,
                              offset: offset !== null && offset !== undefined ? offset : c.nodeValue.length
                          };
                      }
                  }
              }
              i += step;
          }
          return {
              node,
              offset: node.childNodes.length
          };
      }

      function setSelectionPerMouseDown({ document, target, clickCount, node, offset }) {
          if (hasNoSelection(target)) {
              return;
          }
          const targetHasOwnSelection = hasOwnSelection(target);
          // On non-input elements the text selection per multiple click
          // can extend beyond the target boundaries.
          // The exact mechanism what is considered in the same line is unclear.
          // Looks it might be every inline element.
          // TODO: Check what might be considered part of the same line of text.
          const text = String(targetHasOwnSelection ? getUIValue(target) : target.textContent);
          const [start, end] = node ? // which elements might be considered in the same line of text.
          // TODO: support expanding initial range on multiple clicks if node is given
          [
              offset,
              offset
          ] : getTextRange(text, offset, clickCount);
          // TODO: implement modifying selection per shift/ctrl+mouse
          if (targetHasOwnSelection) {
              setUISelection(target, {
                  anchorOffset: start !== null && start !== undefined ? start : text.length,
                  focusOffset: end !== null && end !== undefined ? end : text.length
              });
              return {
                  node: target,
                  start: start !== null && start !== undefined ? start : 0,
                  end: end !== null && end !== undefined ? end : text.length
              };
          } else {
              const { node: startNode, offset: startOffset } = resolveCaretPosition({
                  target,
                  node,
                  offset: start
              });
              const { node: endNode, offset: endOffset } = resolveCaretPosition({
                  target,
                  node,
                  offset: end
              });
              const range = target.ownerDocument.createRange();
              try {
                  range.setStart(startNode, startOffset);
                  range.setEnd(endNode, endOffset);
              } catch (e) {
                  throw new Error('The given offset is out of bounds.');
              }
              const selection = document.getSelection();
              selection === null || selection === undefined ? undefined : selection.removeAllRanges();
              selection === null || selection === undefined ? undefined : selection.addRange(range.cloneRange());
              return range;
          }
      }
      function getTextRange(text, pos, clickCount) {
          if (clickCount % 3 === 1 || text.length === 0) {
              return [
                  pos,
                  pos
              ];
          }
          const textPos = pos !== null && pos !== undefined ? pos : text.length;
          if (clickCount % 3 === 2) {
              return [
                  textPos - text.substr(0, pos).match(/(\w+|\s+|\W)?$/)[0].length,
                  pos === undefined ? pos : pos + text.substr(pos).match(/^(\w+|\s+|\W)?/)[0].length
              ];
          }
          // triple click
          return [
              textPos - text.substr(0, pos).match(/[^\r\n]*$/)[0].length,
              pos === undefined ? pos : pos + text.substr(pos).match(/^[^\r\n]*/)[0].length
          ];
      }

      function modifySelectionPerMouseMove(selectionRange, { document, target, node, offset }) {
          const selectionFocus = resolveCaretPosition({
              target,
              node,
              offset
          });
          if ('node' in selectionRange) {
              // When the mouse is dragged outside of an input/textarea,
              // the selection is extended to the beginning or end of the input
              // depending on pointer position.
              // TODO: extend selection according to pointer position
              /* istanbul ignore else */ if (selectionFocus.node === selectionRange.node) {
                  const anchorOffset = selectionFocus.offset < selectionRange.start ? selectionRange.end : selectionRange.start;
                  const focusOffset = selectionFocus.offset > selectionRange.end || selectionFocus.offset < selectionRange.start ? selectionFocus.offset : selectionRange.end;
                  setUISelection(selectionRange.node, {
                      anchorOffset,
                      focusOffset
                  });
              }
          } else {
              const range = selectionRange.cloneRange();
              const cmp = range.comparePoint(selectionFocus.node, selectionFocus.offset);
              if (cmp < 0) {
                  range.setStart(selectionFocus.node, selectionFocus.offset);
              } else if (cmp > 0) {
                  range.setEnd(selectionFocus.node, selectionFocus.offset);
              }
              const selection = document.getSelection();
              selection === null || selection === undefined ? undefined : selection.removeAllRanges();
              selection === null || selection === undefined ? undefined : selection.addRange(range.cloneRange());
          }
      }

      function isDifferentPointerPosition(positionA, positionB) {
          var _positionA_coords, _positionB_coords, _positionA_coords1, _positionB_coords1, _positionA_coords2, _positionB_coords2, _positionA_coords3, _positionB_coords3, _positionA_coords4, _positionB_coords4, _positionA_coords5, _positionB_coords5, _positionA_coords6, _positionB_coords6, _positionA_coords7, _positionB_coords7, _positionA_coords8, _positionB_coords8, _positionA_coords9, _positionB_coords9, _positionA_caret, _positionB_caret, _positionA_caret1, _positionB_caret1;
          return positionA.target !== positionB.target || ((_positionA_coords = positionA.coords) === null || _positionA_coords === undefined ? undefined : _positionA_coords.x) !== ((_positionB_coords = positionB.coords) === null || _positionB_coords === undefined ? undefined : _positionB_coords.x) || ((_positionA_coords1 = positionA.coords) === null || _positionA_coords1 === undefined ? undefined : _positionA_coords1.y) !== ((_positionB_coords1 = positionB.coords) === null || _positionB_coords1 === undefined ? undefined : _positionB_coords1.y) || ((_positionA_coords2 = positionA.coords) === null || _positionA_coords2 === undefined ? undefined : _positionA_coords2.clientX) !== ((_positionB_coords2 = positionB.coords) === null || _positionB_coords2 === undefined ? undefined : _positionB_coords2.clientX) || ((_positionA_coords3 = positionA.coords) === null || _positionA_coords3 === undefined ? undefined : _positionA_coords3.clientY) !== ((_positionB_coords3 = positionB.coords) === null || _positionB_coords3 === undefined ? undefined : _positionB_coords3.clientY) || ((_positionA_coords4 = positionA.coords) === null || _positionA_coords4 === undefined ? undefined : _positionA_coords4.offsetX) !== ((_positionB_coords4 = positionB.coords) === null || _positionB_coords4 === undefined ? undefined : _positionB_coords4.offsetX) || ((_positionA_coords5 = positionA.coords) === null || _positionA_coords5 === undefined ? undefined : _positionA_coords5.offsetY) !== ((_positionB_coords5 = positionB.coords) === null || _positionB_coords5 === undefined ? undefined : _positionB_coords5.offsetY) || ((_positionA_coords6 = positionA.coords) === null || _positionA_coords6 === undefined ? undefined : _positionA_coords6.pageX) !== ((_positionB_coords6 = positionB.coords) === null || _positionB_coords6 === undefined ? undefined : _positionB_coords6.pageX) || ((_positionA_coords7 = positionA.coords) === null || _positionA_coords7 === undefined ? undefined : _positionA_coords7.pageY) !== ((_positionB_coords7 = positionB.coords) === null || _positionB_coords7 === undefined ? undefined : _positionB_coords7.pageY) || ((_positionA_coords8 = positionA.coords) === null || _positionA_coords8 === undefined ? undefined : _positionA_coords8.screenX) !== ((_positionB_coords8 = positionB.coords) === null || _positionB_coords8 === undefined ? undefined : _positionB_coords8.screenX) || ((_positionA_coords9 = positionA.coords) === null || _positionA_coords9 === undefined ? undefined : _positionA_coords9.screenY) !== ((_positionB_coords9 = positionB.coords) === null || _positionB_coords9 === undefined ? undefined : _positionB_coords9.screenY) || ((_positionA_caret = positionA.caret) === null || _positionA_caret === undefined ? undefined : _positionA_caret.node) !== ((_positionB_caret = positionB.caret) === null || _positionB_caret === undefined ? undefined : _positionB_caret.node) || ((_positionA_caret1 = positionA.caret) === null || _positionA_caret1 === undefined ? undefined : _positionA_caret1.offset) !== ((_positionB_caret1 = positionB.caret) === null || _positionB_caret1 === undefined ? undefined : _positionB_caret1.offset);
      }

      function _define_property$3(obj, key, value) {
          if (key in obj) {
              Object.defineProperty(obj, key, {
                  value: value,
                  enumerable: true,
                  configurable: true,
                  writable: true
              });
          } else {
              obj[key] = value;
          }
          return obj;
      }
      /**
       * This object is the single "virtual" mouse that might be controlled by multiple different pointer devices.
       */ class Mouse {
          move(instance, position, /** Whether `preventDefault()` has been called on the `pointerdown` event */ isPrevented) {
              const prevPosition = this.position;
              const prevTarget = this.getTarget(instance);
              this.position = position;
              if (!isDifferentPointerPosition(prevPosition, position)) {
                  return;
              }
              const nextTarget = this.getTarget(instance);
              const init = this.getEventInit('mousemove');
              const [leave, enter] = getTreeDiff(prevTarget, nextTarget);
              return {
                  leave: ()=>{
                      if (prevTarget !== nextTarget) {
                          instance.dispatchUIEvent(prevTarget, 'mouseout', init);
                          leave.forEach((el)=>instance.dispatchUIEvent(el, 'mouseleave', init));
                      }
                  },
                  enter: ()=>{
                      if (prevTarget !== nextTarget) {
                          instance.dispatchUIEvent(nextTarget, 'mouseover', init);
                          enter.forEach((el)=>instance.dispatchUIEvent(el, 'mouseenter', init));
                      }
                  },
                  move: ()=>{
                      if (isPrevented) {
                          return;
                      }
                      instance.dispatchUIEvent(nextTarget, 'mousemove', init);
                      this.modifySelecting(instance);
                  }
              };
          }
          down(instance, keyDef, /** Whether `preventDefault()` has been called on the `pointerdown` event */ isPrevented) {
              const button = this.buttons.down(keyDef);
              if (button === undefined) {
                  return;
              }
              const target = this.getTarget(instance);
              this.buttonDownTarget[button] = target;
              const init = this.getEventInit('mousedown', keyDef.button);
              const disabled = isDisabled(target);
              if (!isPrevented && (disabled || instance.dispatchUIEvent(target, 'mousedown', init))) {
                  this.startSelecting(instance, init.detail);
                  focusElement(target);
              }
              if (!disabled && getMouseEventButton(keyDef.button) === 2) {
                  instance.dispatchUIEvent(target, 'contextmenu', this.getEventInit('contextmenu', keyDef.button));
              }
          }
          up(instance, keyDef, /** Whether `preventDefault()` has been called on the `pointerdown` event */ isPrevented) {
              const button = this.buttons.up(keyDef);
              if (button === undefined) {
                  return;
              }
              const target = this.getTarget(instance);
              if (!isDisabled(target)) {
                  if (!isPrevented) {
                      const mouseUpInit = this.getEventInit('mouseup', keyDef.button);
                      instance.dispatchUIEvent(target, 'mouseup', mouseUpInit);
                      this.endSelecting();
                  }
                  const clickTarget = getTreeDiff(this.buttonDownTarget[button], target)[2][0];
                  if (clickTarget) {
                      const init = this.getEventInit('click', keyDef.button);
                      if (init.detail) {
                          instance.dispatchUIEvent(clickTarget, init.button === 0 ? 'click' : 'auxclick', init);
                          if (init.button === 0 && init.detail === 2) {
                              instance.dispatchUIEvent(clickTarget, 'dblclick', {
                                  ...this.getEventInit('dblclick', keyDef.button),
                                  detail: init.detail
                              });
                          }
                      }
                  }
              }
          }
          resetClickCount() {
              this.clickCount.reset();
          }
          getEventInit(type, button) {
              const init = {
                  ...this.position.coords
              };
              init.button = getMouseEventButton(button);
              init.buttons = this.buttons.getButtons();
              if (type === 'mousedown') {
                  init.detail = this.clickCount.getOnDown(init.button);
              } else if (type === 'mouseup') {
                  init.detail = this.clickCount.getOnUp(init.button);
              } else if (type === 'click' || type === 'auxclick') {
                  init.detail = this.clickCount.incOnClick(init.button);
              }
              return init;
          }
          getTarget(instance) {
              var _this_position_target;
              return (_this_position_target = this.position.target) !== null && _this_position_target !== undefined ? _this_position_target : instance.config.document.body;
          }
          startSelecting(instance, clickCount) {
              var _this_position_caret, _this_position_caret1;
              // TODO: support extending range (shift)
              this.selecting = setSelectionPerMouseDown({
                  document: instance.config.document,
                  target: this.getTarget(instance),
                  node: (_this_position_caret = this.position.caret) === null || _this_position_caret === undefined ? undefined : _this_position_caret.node,
                  offset: (_this_position_caret1 = this.position.caret) === null || _this_position_caret1 === undefined ? undefined : _this_position_caret1.offset,
                  clickCount
              });
          }
          modifySelecting(instance) {
              var _this_position_caret, _this_position_caret1;
              if (!this.selecting) {
                  return;
              }
              modifySelectionPerMouseMove(this.selecting, {
                  document: instance.config.document,
                  target: this.getTarget(instance),
                  node: (_this_position_caret = this.position.caret) === null || _this_position_caret === undefined ? undefined : _this_position_caret.node,
                  offset: (_this_position_caret1 = this.position.caret) === null || _this_position_caret1 === undefined ? undefined : _this_position_caret1.offset
              });
          }
          endSelecting() {
              this.selecting = undefined;
          }
          constructor(){
              _define_property$3(this, "position", {});
              _define_property$3(this, "buttons", new Buttons());
              _define_property$3(this, "selecting", undefined);
              _define_property$3(this, "buttonDownTarget", {});
              // According to spec the `detail` on click events should be the number
              // of *consecutive* clicks with a specific button.
              // On `mousedown` and `mouseup` it should be this number increased by one.
              // But the browsers don't implement it this way.
              // If another button is pressed,
              //   in Webkit: the `mouseup` on the previously pressed button has `detail: 0` and no `click`/`auxclick`.
              //   in Gecko: the `mouseup` and click events have the same detail as the `mousedown`.
              // If there is a delay while a button is pressed,
              // the `mouseup` and `click` are normal, but a following `mousedown` starts a new click count.
              // We'll follow the minimal implementation of Webkit.
              _define_property$3(this, "clickCount", new class {
                  incOnClick(button) {
                      const current = this.down[button] === undefined ? undefined : Number(this.down[button]) + 1;
                      this.count = this.count[button] === undefined ? {} : {
                          [button]: Number(this.count[button]) + 1
                      };
                      return current;
                  }
                  getOnDown(button) {
                      var _this_count_button;
                      this.down = {
                          [button]: (_this_count_button = this.count[button]) !== null && _this_count_button !== undefined ? _this_count_button : 0
                      };
                      var _this_count_button1;
                      this.count = {
                          [button]: (_this_count_button1 = this.count[button]) !== null && _this_count_button1 !== undefined ? _this_count_button1 : 0
                      };
                      return Number(this.count[button]) + 1;
                  }
                  getOnUp(button) {
                      return this.down[button] === undefined ? undefined : Number(this.down[button]) + 1;
                  }
                  reset() {
                      this.count = {};
                  }
                  constructor(){
                      _define_property$3(this, "down", {});
                      _define_property$3(this, "count", {});
                  }
              }());
          }
      }

      function hasPointerEvents(instance, element) {
          var _checkPointerEvents;
          return ((_checkPointerEvents = checkPointerEvents(instance, element)) === null || _checkPointerEvents === undefined ? undefined : _checkPointerEvents.pointerEvents) !== 'none';
      }
      function closestPointerEventsDeclaration(element) {
          const window = getWindow(element);
          for(let el = element, tree = []; el === null || el === undefined ? undefined : el.ownerDocument; el = el.parentElement){
              tree.push(el);
              const pointerEvents = window.getComputedStyle(el).pointerEvents;
              if (pointerEvents && ![
                  'inherit',
                  'unset'
              ].includes(pointerEvents)) {
                  return {
                      pointerEvents,
                      tree
                  };
              }
          }
          return undefined;
      }
      const PointerEventsCheck = Symbol('Last check for pointer-events');
      function checkPointerEvents(instance, element) {
          const lastCheck = element[PointerEventsCheck];
          const needsCheck = instance.config.pointerEventsCheck !== PointerEventsCheckLevel.Never && (!lastCheck || hasBitFlag(instance.config.pointerEventsCheck, PointerEventsCheckLevel.EachApiCall) && lastCheck[ApiLevel.Call] !== getLevelRef(instance, ApiLevel.Call) || hasBitFlag(instance.config.pointerEventsCheck, PointerEventsCheckLevel.EachTrigger) && lastCheck[ApiLevel.Trigger] !== getLevelRef(instance, ApiLevel.Trigger));
          if (!needsCheck) {
              return lastCheck === null || lastCheck === undefined ? undefined : lastCheck.result;
          }
          const declaration = closestPointerEventsDeclaration(element);
          element[PointerEventsCheck] = {
              [ApiLevel.Call]: getLevelRef(instance, ApiLevel.Call),
              [ApiLevel.Trigger]: getLevelRef(instance, ApiLevel.Trigger),
              result: declaration
          };
          return declaration;
      }
      function assertPointerEvents(instance, element) {
          const declaration = checkPointerEvents(instance, element);
          if ((declaration === null || declaration === undefined ? undefined : declaration.pointerEvents) === 'none') {
              throw new Error([
                  `Unable to perform pointer interaction as the element ${declaration.tree.length > 1 ? 'inherits' : 'has'} \`pointer-events: none\`:`,
                  '',
                  printTree(declaration.tree)
              ].join('\n'));
          }
      }
      function printTree(tree) {
          return tree.reverse().map((el, i)=>[
                  ''.padEnd(i),
                  el.tagName,
                  el.id && `#${el.id}`,
                  el.hasAttribute('data-testid') && `(testId=${el.getAttribute('data-testid')})`,
                  getLabelDescr(el),
                  tree.length > 1 && i === 0 && '  <-- This element declared `pointer-events: none`',
                  tree.length > 1 && i === tree.length - 1 && '  <-- Asserted pointer events here'
              ].filter(Boolean).join('')).join('\n');
      }
      function getLabelDescr(element) {
          var _element_labels;
          let label;
          if (element.hasAttribute('aria-label')) {
              label = element.getAttribute('aria-label');
          } else if (element.hasAttribute('aria-labelledby')) {
              var _element_ownerDocument_getElementById_textContent, _element_ownerDocument_getElementById;
              label = (_element_ownerDocument_getElementById = element.ownerDocument.getElementById(element.getAttribute('aria-labelledby'))) === null || _element_ownerDocument_getElementById === undefined ? undefined : (_element_ownerDocument_getElementById_textContent = _element_ownerDocument_getElementById.textContent) === null || _element_ownerDocument_getElementById_textContent === undefined ? undefined : _element_ownerDocument_getElementById_textContent.trim();
          } else if (isElementType(element, [
              'button',
              'input',
              'meter',
              'output',
              'progress',
              'select',
              'textarea'
          ]) && ((_element_labels = element.labels) === null || _element_labels === undefined ? undefined : _element_labels.length)) {
              label = Array.from(element.labels).map((el)=>{
                  var _el_textContent;
                  return (_el_textContent = el.textContent) === null || _el_textContent === undefined ? undefined : _el_textContent.trim();
              }).join('|');
          } else if (isElementType(element, 'button')) {
              var _element_textContent;
              label = (_element_textContent = element.textContent) === null || _element_textContent === undefined ? undefined : _element_textContent.trim();
          }
          label = label === null || label === undefined ? undefined : label.replace(/\n/g, '  ');
          if (Number(label === null || label === undefined ? undefined : label.length) > 30) {
              label = `${label === null || label === undefined ? undefined : label.substring(0, 29)}…`;
          }
          return label ? `(label=${label})` : '';
      }
      // With the eslint rule and prettier the bitwise operation isn't nice to read
      function hasBitFlag(conf, flag) {
          // eslint-disable-next-line no-bitwise
          return (conf & flag) > 0;
      }

      function _define_property$2(obj, key, value) {
          if (key in obj) {
              Object.defineProperty(obj, key, {
                  value: value,
                  enumerable: true,
                  configurable: true,
                  writable: true
              });
          } else {
              obj[key] = value;
          }
          return obj;
      }
      class Pointer {
          init(instance) {
              const target = this.getTarget(instance);
              const [, enter] = getTreeDiff(null, target);
              const init = this.getEventInit();
              assertPointerEvents(instance, target);
              instance.dispatchUIEvent(target, 'pointerover', init);
              enter.forEach((el)=>instance.dispatchUIEvent(el, 'pointerenter', init));
              return this;
          }
          move(instance, position) {
              const prevPosition = this.position;
              const prevTarget = this.getTarget(instance);
              this.position = position;
              if (!isDifferentPointerPosition(prevPosition, position)) {
                  return;
              }
              const nextTarget = this.getTarget(instance);
              const init = this.getEventInit(-1);
              const [leave, enter] = getTreeDiff(prevTarget, nextTarget);
              return {
                  leave: ()=>{
                      if (hasPointerEvents(instance, prevTarget)) {
                          if (prevTarget !== nextTarget) {
                              instance.dispatchUIEvent(prevTarget, 'pointerout', init);
                              leave.forEach((el)=>instance.dispatchUIEvent(el, 'pointerleave', init));
                          }
                      }
                  },
                  enter: ()=>{
                      assertPointerEvents(instance, nextTarget);
                      if (prevTarget !== nextTarget) {
                          instance.dispatchUIEvent(nextTarget, 'pointerover', init);
                          enter.forEach((el)=>instance.dispatchUIEvent(el, 'pointerenter', init));
                      }
                  },
                  move: ()=>{
                      instance.dispatchUIEvent(nextTarget, 'pointermove', init);
                  }
              };
          }
          down(instance, button = 0) {
              if (this.isDown) {
                  return;
              }
              const target = this.getTarget(instance);
              assertPointerEvents(instance, target);
              this.isDown = true;
              this.isPrevented = !instance.dispatchUIEvent(target, 'pointerdown', this.getEventInit(button));
          }
          up(instance, button = 0) {
              if (!this.isDown) {
                  return;
              }
              const target = this.getTarget(instance);
              assertPointerEvents(instance, target);
              this.isPrevented = false;
              this.isDown = false;
              instance.dispatchUIEvent(target, 'pointerup', this.getEventInit(button));
          }
          release(instance) {
              const target = this.getTarget(instance);
              const [leave] = getTreeDiff(target, null);
              const init = this.getEventInit();
              // Currently there is no PointerEventsCheckLevel that would
              // make this check not use the *asserted* cached value from `up`.
              /* istanbul ignore else */ if (hasPointerEvents(instance, target)) {
                  instance.dispatchUIEvent(target, 'pointerout', init);
                  leave.forEach((el)=>instance.dispatchUIEvent(el, 'pointerleave', init));
              }
              this.isCancelled = true;
          }
          getTarget(instance) {
              var _this_position_target;
              return (_this_position_target = this.position.target) !== null && _this_position_target !== undefined ? _this_position_target : instance.config.document.body;
          }
          getEventInit(/**
           * The `button` that caused the event.
           *
           * This should be `-1` if the event is not caused by a button or touch/pen contact,
           * e.g. a moving pointer.
           */ button) {
              return {
                  ...this.position.coords,
                  pointerId: this.pointerId,
                  pointerType: this.pointerType,
                  isPrimary: this.isPrimary,
                  button: getMouseEventButton(button),
                  buttons: this.buttons.getButtons()
              };
          }
          constructor({ pointerId, pointerType, isPrimary }, buttons){
              _define_property$2(this, "pointerId", undefined);
              _define_property$2(this, "pointerType", undefined);
              _define_property$2(this, "isPrimary", undefined);
              _define_property$2(this, "buttons", undefined);
              _define_property$2(this, "isMultitouch", false);
              _define_property$2(this, "isCancelled", false);
              _define_property$2(this, "isDown", false);
              _define_property$2(this, "isPrevented", false);
              _define_property$2(this, "position", {});
              this.pointerId = pointerId;
              this.pointerType = pointerType;
              this.isPrimary = isPrimary;
              this.isMultitouch = !isPrimary;
              this.buttons = buttons;
          }
      }

      function _define_property$1(obj, key, value) {
          if (key in obj) {
              Object.defineProperty(obj, key, {
                  value: value,
                  enumerable: true,
                  configurable: true,
                  writable: true
              });
          } else {
              obj[key] = value;
          }
          return obj;
      }
      class PointerHost {
          isKeyPressed(keyDef) {
              return this.devices.get(keyDef.pointerType).isPressed(keyDef);
          }
          async press(instance, keyDef, position) {
              this.devices.get(keyDef.pointerType).addPressed(keyDef);
              this.buttons.down(keyDef);
              const pointerName = this.getPointerName(keyDef);
              const pointer = keyDef.pointerType === 'touch' ? this.pointers.new(pointerName, keyDef.pointerType, this.buttons) : this.pointers.get(pointerName);
              // TODO: deprecate the following implicit setting of position
              pointer.position = position;
              if (pointer.pointerType !== 'touch') {
                  this.mouse.position = position;
              }
              if (pointer.pointerType === 'touch') {
                  pointer.init(instance);
              }
              pointer.down(instance, keyDef.button);
              if (pointer.pointerType !== 'touch') {
                  this.mouse.down(instance, keyDef, pointer.isPrevented);
              }
          }
          async move(instance, pointerName, position) {
              const pointer = this.pointers.get(pointerName);
              // In (some?) browsers this order of events can be observed.
              // This interweaving of events is probably unnecessary.
              // While the order of mouse (or pointer) events is defined per spec,
              // the order in which they interweave/follow on a user interaction depends on the implementation.
              const pointermove = pointer.move(instance, position);
              const mousemove = pointer.pointerType === 'touch' ? undefined : this.mouse.move(instance, position, pointer.isPrevented);
              pointermove === null || pointermove === undefined ? undefined : pointermove.leave();
              mousemove === null || mousemove === undefined ? undefined : mousemove.leave();
              pointermove === null || pointermove === undefined ? undefined : pointermove.enter();
              mousemove === null || mousemove === undefined ? undefined : mousemove.enter();
              pointermove === null || pointermove === undefined ? undefined : pointermove.move();
              mousemove === null || mousemove === undefined ? undefined : mousemove.move();
          }
          async release(instance, keyDef, position) {
              const device = this.devices.get(keyDef.pointerType);
              device.removePressed(keyDef);
              this.buttons.up(keyDef);
              const pointer = this.pointers.get(this.getPointerName(keyDef));
              const isPrevented = pointer.isPrevented;
              // TODO: deprecate the following implicit setting of position
              pointer.position = position;
              if (pointer.pointerType !== 'touch') {
                  this.mouse.position = position;
              }
              if (device.countPressed === 0) {
                  pointer.up(instance, keyDef.button);
              }
              if (pointer.pointerType === 'touch') {
                  pointer.release(instance);
              }
              if (pointer.pointerType === 'touch' && !pointer.isMultitouch) {
                  const mousemove = this.mouse.move(instance, position, isPrevented);
                  mousemove === null || mousemove === undefined ? undefined : mousemove.leave();
                  mousemove === null || mousemove === undefined ? undefined : mousemove.enter();
                  mousemove === null || mousemove === undefined ? undefined : mousemove.move();
                  this.mouse.down(instance, keyDef, isPrevented);
              }
              if (!pointer.isMultitouch) {
                  const mousemove = this.mouse.move(instance, position, isPrevented);
                  mousemove === null || mousemove === undefined ? undefined : mousemove.leave();
                  mousemove === null || mousemove === undefined ? undefined : mousemove.enter();
                  mousemove === null || mousemove === undefined ? undefined : mousemove.move();
                  this.mouse.up(instance, keyDef, isPrevented);
              }
          }
          getPointerName(keyDef) {
              return keyDef.pointerType === 'touch' ? keyDef.name : keyDef.pointerType;
          }
          getPreviousPosition(pointerName) {
              return this.pointers.has(pointerName) ? this.pointers.get(pointerName).position : undefined;
          }
          resetClickCount() {
              this.mouse.resetClickCount();
          }
          getMouseTarget(instance) {
              var _this_mouse_position_target;
              return (_this_mouse_position_target = this.mouse.position.target) !== null && _this_mouse_position_target !== undefined ? _this_mouse_position_target : instance.config.document.body;
          }
          setMousePosition(position) {
              this.mouse.position = position;
              this.pointers.get('mouse').position = position;
          }
          constructor(system){
              _define_property$1(this, "system", undefined);
              _define_property$1(this, "mouse", undefined);
              _define_property$1(this, "buttons", undefined);
              _define_property$1(this, "devices", new class {
                  get(k) {
                      var _this_registry, _k;
                      var _;
                      return (_ = (_this_registry = this.registry)[_k = k]) !== null && _ !== undefined ? _ : _this_registry[_k] = new Device();
                  }
                  constructor(){
                      _define_property$1(this, "registry", {});
                  }
              }());
              _define_property$1(this, "pointers", new class {
                  new(pointerName, pointerType, buttons) {
                      const isPrimary = pointerType !== 'touch' || !Object.values(this.registry).some((p)=>p.pointerType === 'touch' && !p.isCancelled);
                      if (!isPrimary) {
                          Object.values(this.registry).forEach((p)=>{
                              if (p.pointerType === pointerType && !p.isCancelled) {
                                  p.isMultitouch = true;
                              }
                          });
                      }
                      this.registry[pointerName] = new Pointer({
                          pointerId: this.nextId++,
                          pointerType,
                          isPrimary
                      }, buttons);
                      return this.registry[pointerName];
                  }
                  get(pointerName) {
                      if (!this.has(pointerName)) {
                          throw new Error(`Trying to access pointer "${pointerName}" which does not exist.`);
                      }
                      return this.registry[pointerName];
                  }
                  has(pointerName) {
                      return pointerName in this.registry;
                  }
                  constructor(){
                      _define_property$1(this, "registry", {});
                      _define_property$1(this, "nextId", 1);
                  }
              }());
              this.system = system;
              this.buttons = new Buttons();
              this.mouse = new Mouse();
              this.pointers.new('mouse', 'mouse', this.buttons);
          }
      }

      function _define_property(obj, key, value) {
          if (key in obj) {
              Object.defineProperty(obj, key, {
                  value: value,
                  enumerable: true,
                  configurable: true,
                  writable: true
              });
          } else {
              obj[key] = value;
          }
          return obj;
      }
      /**
       * @internal Do not create/alter this by yourself as this type might be subject to changes.
       */ class System {
          getUIEventModifiers() {
              return {
                  altKey: this.keyboard.modifiers.Alt,
                  ctrlKey: this.keyboard.modifiers.Control,
                  metaKey: this.keyboard.modifiers.Meta,
                  shiftKey: this.keyboard.modifiers.Shift,
                  modifierAltGraph: this.keyboard.modifiers.AltGraph,
                  modifierCapsLock: this.keyboard.modifiers.CapsLock,
                  modifierFn: this.keyboard.modifiers.Fn,
                  modifierFnLock: this.keyboard.modifiers.FnLock,
                  modifierNumLock: this.keyboard.modifiers.NumLock,
                  modifierScrollLock: this.keyboard.modifiers.ScrollLock,
                  modifierSymbol: this.keyboard.modifiers.Symbol,
                  modifierSymbolLock: this.keyboard.modifiers.SymbolLock
              };
          }
          constructor(){
              _define_property(this, "keyboard", new KeyboardHost(this));
              _define_property(this, "pointer", new PointerHost(this));
          }
      }

      async function click$1(element) {
          const pointerIn = [];
          if (!this.config.skipHover) {
              pointerIn.push({
                  target: element
              });
          }
          pointerIn.push({
              keys: '[MouseLeft]',
              target: element
          });
          return this.pointer(pointerIn);
      }
      async function dblClick$1(element) {
          return this.pointer([
              {
                  target: element
              },
              '[MouseLeft][MouseLeft]'
          ]);
      }
      async function tripleClick$1(element) {
          return this.pointer([
              {
                  target: element
              },
              '[MouseLeft][MouseLeft][MouseLeft]'
          ]);
      }

      async function hover$1(element) {
          return this.pointer({
              target: element
          });
      }
      async function unhover$1(element) {
          assertPointerEvents(this, this.system.pointer.getMouseTarget(this));
          return this.pointer({
              target: element.ownerDocument.body
          });
      }

      async function tab$1({ shift } = {}) {
          return this.keyboard(shift === true ? '{Shift>}{Tab}{/Shift}' : shift === false ? '[/ShiftLeft][/ShiftRight]{Tab}' : '{Tab}');
      }

      var bracketDict = /*#__PURE__*/ function(bracketDict) {
          bracketDict["{"] = "}";
          bracketDict["["] = "]";
          return bracketDict;
      }(bracketDict || {});
      /**
       * Read the next key definition from user input
       *
       * Describe key per `{descriptor}` or `[descriptor]`.
       * Everything else will be interpreted as a single character as descriptor - e.g. `a`.
       * Brackets `{` and `[` can be escaped by doubling - e.g. `foo[[bar` translates to `foo[bar`.
       * A previously pressed key can be released per `{/descriptor}`.
       * Keeping the key pressed can be written as `{descriptor>}`.
       * When keeping the key pressed you can choose how long the key is pressed `{descriptor>3}`.
       * You can then release the key per `{descriptor>3/}` or keep it pressed and continue with the next key.
       */ function readNextDescriptor(text, context) {
          let pos = 0;
          const startBracket = text[pos] in bracketDict ? text[pos] : '';
          pos += startBracket.length;
          const isEscapedChar = new RegExp(`^\\${startBracket}{2}`).test(text);
          const type = isEscapedChar ? '' : startBracket;
          return {
              type,
              ...type === '' ? readPrintableChar(text, pos, context) : readTag(text, pos, type, context)
          };
      }
      function readPrintableChar(text, pos, context) {
          const descriptor = text[pos];
          assertDescriptor(descriptor, text, pos, context);
          pos += descriptor.length;
          return {
              consumedLength: pos,
              descriptor,
              releasePrevious: false,
              releaseSelf: true,
              repeat: 1
          };
      }
      function readTag(text, pos, startBracket, context) {
          var _text_slice_match, _text_slice_match1;
          const releasePreviousModifier = text[pos] === '/' ? '/' : '';
          pos += releasePreviousModifier.length;
          const escapedDescriptor = startBracket === '{' && text[pos] === '\\';
          pos += Number(escapedDescriptor);
          const descriptor = escapedDescriptor ? text[pos] : (_text_slice_match = text.slice(pos).match(startBracket === '{' ? /^\w+|^[^}>/]/ : /^\w+/)) === null || _text_slice_match === undefined ? undefined : _text_slice_match[0];
          assertDescriptor(descriptor, text, pos, context);
          pos += descriptor.length;
          var _text_slice_match_;
          const repeatModifier = (_text_slice_match_ = (_text_slice_match1 = text.slice(pos).match(/^>\d+/)) === null || _text_slice_match1 === undefined ? undefined : _text_slice_match1[0]) !== null && _text_slice_match_ !== undefined ? _text_slice_match_ : '';
          pos += repeatModifier.length;
          const releaseSelfModifier = text[pos] === '/' || !repeatModifier && text[pos] === '>' ? text[pos] : '';
          pos += releaseSelfModifier.length;
          const expectedEndBracket = bracketDict[startBracket];
          const endBracket = text[pos] === expectedEndBracket ? expectedEndBracket : '';
          if (!endBracket) {
              throw new Error(getErrorMessage([
                  !repeatModifier && 'repeat modifier',
                  !releaseSelfModifier && 'release modifier',
                  `"${expectedEndBracket}"`
              ].filter(Boolean).join(' or '), text[pos], text, context));
          }
          pos += endBracket.length;
          return {
              consumedLength: pos,
              descriptor,
              releasePrevious: !!releasePreviousModifier,
              repeat: repeatModifier ? Math.max(Number(repeatModifier.substr(1)), 1) : 1,
              releaseSelf: hasReleaseSelf(releaseSelfModifier, repeatModifier)
          };
      }
      function assertDescriptor(descriptor, text, pos, context) {
          if (!descriptor) {
              throw new Error(getErrorMessage('key descriptor', text[pos], text, context));
          }
      }
      function hasReleaseSelf(releaseSelfModifier, repeatModifier) {
          if (releaseSelfModifier) {
              return releaseSelfModifier === '/';
          }
          if (repeatModifier) {
              return false;
          }
      }
      function getErrorMessage(expected, found, text, context) {
          return `Expected ${expected} but found "${found !== null && found !== undefined ? found : ''}" in "${text}"
    See ${context === 'pointer' ? `https://testing-library.com/docs/user-event/pointer#pressing-a-button-or-touching-the-screen` : `https://testing-library.com/docs/user-event/keyboard`}
    for more information about how userEvent parses your input.`;
      }

      /**
       * Parse key definitions per `keyboardMap`
       *
       * Keys can be referenced by `{key}` or `{special}` as well as physical locations per `[code]`.
       * Everything else will be interpreted as a typed character - e.g. `a`.
       * Brackets `{` and `[` can be escaped by doubling - e.g. `foo[[bar` translates to `foo[bar`.
       * Keeping the key pressed can be written as `{key>}`.
       * When keeping the key pressed you can choose how long (how many keydown and keypress) the key is pressed `{key>3}`.
       * You can then release the key per `{key>3/}` or keep it pressed and continue with the next key.
       */ function parseKeyDef$1(keyboardMap, text) {
          const defs = [];
          do {
              const { type, descriptor, consumedLength, releasePrevious, releaseSelf = true, repeat } = readNextDescriptor(text, 'keyboard');
              var _keyboardMap_find;
              const keyDef = (_keyboardMap_find = keyboardMap.find((def)=>{
                  if (type === '[') {
                      var _def_code;
                      return ((_def_code = def.code) === null || _def_code === undefined ? undefined : _def_code.toLowerCase()) === descriptor.toLowerCase();
                  } else if (type === '{') {
                      var _def_key;
                      return ((_def_key = def.key) === null || _def_key === undefined ? undefined : _def_key.toLowerCase()) === descriptor.toLowerCase();
                  }
                  return def.key === descriptor;
              })) !== null && _keyboardMap_find !== undefined ? _keyboardMap_find : {
                  key: 'Unknown',
                  code: 'Unknown',
                  [type === '[' ? 'code' : 'key']: descriptor
              };
              defs.push({
                  keyDef,
                  releasePrevious,
                  releaseSelf,
                  repeat
              });
              text = text.slice(consumedLength);
          }while (text)
          return defs;
      }

      async function keyboard$1(text) {
          const actions = parseKeyDef$1(this.config.keyboardMap, text);
          for(let i = 0; i < actions.length; i++){
              await wait(this.config);
              await keyboardAction(this, actions[i]);
          }
      }
      async function keyboardAction(instance, { keyDef, releasePrevious, releaseSelf, repeat }) {
          const { system } = instance;
          // Release the key automatically if it was pressed before.
          if (system.keyboard.isKeyPressed(keyDef)) {
              await system.keyboard.keyup(instance, keyDef);
          }
          if (!releasePrevious) {
              for(let i = 1; i <= repeat; i++){
                  await system.keyboard.keydown(instance, keyDef);
                  if (i < repeat) {
                      await wait(instance.config);
                  }
              }
              // Release the key only on the last iteration on `state.repeatKey`.
              if (releaseSelf) {
                  await system.keyboard.keyup(instance, keyDef);
              }
          }
      }
      async function releaseAllKeys(instance) {
          for (const k of instance.system.keyboard.getPressedKeys()){
              await instance.system.keyboard.keyup(instance, k);
          }
      }

      function copySelection(target) {
          const data = hasOwnSelection(target) ? {
              'text/plain': readSelectedValueFromInput(target)
          } : {
              'text/plain': String(target.ownerDocument.getSelection())
          };
          const dt = createDataTransfer(getWindow(target));
          for(const type in data){
              if (data[type]) {
                  dt.setData(type, data[type]);
              }
          }
          return dt;
      }
      function readSelectedValueFromInput(target) {
          const sel = getUISelection(target);
          const val = getUIValue(target);
          return val.substring(sel.startOffset, sel.endOffset);
      }

      async function copy$1() {
          const doc = this.config.document;
          var _doc_activeElement;
          const target = (_doc_activeElement = doc.activeElement) !== null && _doc_activeElement !== undefined ? _doc_activeElement : /* istanbul ignore next */ doc.body;
          const clipboardData = copySelection(target);
          if (clipboardData.items.length === 0) {
              return;
          }
          if (this.dispatchUIEvent(target, 'copy', {
              clipboardData
          }) && this.config.writeToClipboard) {
              await writeDataTransferToClipboard(doc, clipboardData);
          }
          return clipboardData;
      }

      async function cut$1() {
          const doc = this.config.document;
          var _doc_activeElement;
          const target = (_doc_activeElement = doc.activeElement) !== null && _doc_activeElement !== undefined ? _doc_activeElement : /* istanbul ignore next */ doc.body;
          const clipboardData = copySelection(target);
          if (clipboardData.items.length === 0) {
              return;
          }
          if (this.dispatchUIEvent(target, 'cut', {
              clipboardData
          }) && this.config.writeToClipboard) {
              await writeDataTransferToClipboard(target.ownerDocument, clipboardData);
          }
          return clipboardData;
      }

      async function paste$1(clipboardData) {
          const doc = this.config.document;
          var _doc_activeElement;
          const target = (_doc_activeElement = doc.activeElement) !== null && _doc_activeElement !== undefined ? _doc_activeElement : /* istanbul ignore next */ doc.body;
          var _ref;
          const dataTransfer = (_ref = typeof clipboardData === 'string' ? getClipboardDataFromString(doc, clipboardData) : clipboardData) !== null && _ref !== undefined ? _ref : await readDataTransferFromClipboard(doc).catch(()=>{
              throw new Error('`userEvent.paste()` without `clipboardData` requires the `ClipboardAPI` to be available.');
          });
          this.dispatchUIEvent(target, 'paste', {
              clipboardData: dataTransfer
          });
      }
      function getClipboardDataFromString(doc, text) {
          const dt = createDataTransfer(getWindow(doc));
          dt.setData('text', text);
          return dt;
      }

      function parseKeyDef(pointerMap, keys) {
          const defs = [];
          do {
              const { descriptor, consumedLength, releasePrevious, releaseSelf = true } = readNextDescriptor(keys, 'pointer');
              const keyDef = pointerMap.find((p)=>p.name === descriptor);
              if (keyDef) {
                  defs.push({
                      keyDef,
                      releasePrevious,
                      releaseSelf
                  });
              }
              keys = keys.slice(consumedLength);
          }while (keys)
          return defs;
      }

      async function pointer$1(input) {
          const { pointerMap } = this.config;
          const actions = [];
          (Array.isArray(input) ? input : [
              input
          ]).forEach((actionInput)=>{
              if (typeof actionInput === 'string') {
                  actions.push(...parseKeyDef(pointerMap, actionInput));
              } else if ('keys' in actionInput) {
                  actions.push(...parseKeyDef(pointerMap, actionInput.keys).map((i)=>({
                          ...actionInput,
                          ...i
                      })));
              } else {
                  actions.push(actionInput);
              }
          });
          for(let i = 0; i < actions.length; i++){
              await wait(this.config);
              await pointerAction(this, actions[i]);
          }
          this.system.pointer.resetClickCount();
      }
      async function pointerAction(instance, action) {
          var _previousPosition_caret, _previousPosition_caret1;
          const pointerName = 'pointerName' in action && action.pointerName ? action.pointerName : 'keyDef' in action ? instance.system.pointer.getPointerName(action.keyDef) : 'mouse';
          const previousPosition = instance.system.pointer.getPreviousPosition(pointerName);
          var _action_target, _action_coords, _action_node, _action_offset;
          const position = {
              target: (_action_target = action.target) !== null && _action_target !== undefined ? _action_target : getPrevTarget(instance, previousPosition),
              coords: (_action_coords = action.coords) !== null && _action_coords !== undefined ? _action_coords : previousPosition === null || previousPosition === undefined ? undefined : previousPosition.coords,
              caret: {
                  node: (_action_node = action.node) !== null && _action_node !== undefined ? _action_node : hasCaretPosition(action) ? undefined : previousPosition === null || previousPosition === undefined ? undefined : (_previousPosition_caret = previousPosition.caret) === null || _previousPosition_caret === undefined ? undefined : _previousPosition_caret.node,
                  offset: (_action_offset = action.offset) !== null && _action_offset !== undefined ? _action_offset : hasCaretPosition(action) ? undefined : previousPosition === null || previousPosition === undefined ? undefined : (_previousPosition_caret1 = previousPosition.caret) === null || _previousPosition_caret1 === undefined ? undefined : _previousPosition_caret1.offset
              }
          };
          if ('keyDef' in action) {
              if (instance.system.pointer.isKeyPressed(action.keyDef)) {
                  setLevelRef(instance, ApiLevel.Trigger);
                  await instance.system.pointer.release(instance, action.keyDef, position);
              }
              if (!action.releasePrevious) {
                  setLevelRef(instance, ApiLevel.Trigger);
                  await instance.system.pointer.press(instance, action.keyDef, position);
                  if (action.releaseSelf) {
                      setLevelRef(instance, ApiLevel.Trigger);
                      await instance.system.pointer.release(instance, action.keyDef, position);
                  }
              }
          } else {
              setLevelRef(instance, ApiLevel.Trigger);
              await instance.system.pointer.move(instance, pointerName, position);
          }
      }
      function hasCaretPosition(action) {
          var _action_target, _ref;
          return !!((_ref = (_action_target = action.target) !== null && _action_target !== undefined ? _action_target : action.node) !== null && _ref !== undefined ? _ref : action.offset !== undefined);
      }
      function getPrevTarget(instance, position) {
          if (!position) {
              throw new Error('This pointer has no previous position. Provide a target property!');
          }
          var _position_target;
          return (_position_target = position.target) !== null && _position_target !== undefined ? _position_target : instance.config.document.body;
      }

      async function clear$1(element) {
          if (!isEditable(element) || isDisabled(element)) {
              throw new Error('clear()` is only supported on editable elements.');
          }
          focusElement(element);
          if (element.ownerDocument.activeElement !== element) {
              throw new Error('The element to be cleared could not be focused.');
          }
          selectAll(element);
          if (!isAllSelected(element)) {
              throw new Error('The element content to be cleared could not be selected.');
          }
          input(this, element, '', 'deleteContentBackward');
      }

      async function selectOptions$1(select, values) {
          return selectOptionsBase.call(this, true, select, values);
      }
      async function deselectOptions$1(select, values) {
          return selectOptionsBase.call(this, false, select, values);
      }
      async function selectOptionsBase(newValue, select, values) {
          if (!newValue && !select.multiple) {
              throw getConfig().getElementError(`Unable to deselect an option in a non-multiple select. Use selectOptions to change the selection instead.`, select);
          }
          const valArray = Array.isArray(values) ? values : [
              values
          ];
          const allOptions = Array.from(select.querySelectorAll('option, [role="option"]'));
          const selectedOptions = valArray.map((val)=>{
              if (typeof val !== 'string' && allOptions.includes(val)) {
                  return val;
              } else {
                  const matchingOption = allOptions.find((o)=>o.value === val || o.innerHTML === val);
                  if (matchingOption) {
                      return matchingOption;
                  } else {
                      throw getConfig().getElementError(`Value "${String(val)}" not found in options`, select);
                  }
              }
          }).filter((option)=>!isDisabled(option));
          if (isDisabled(select) || !selectedOptions.length) return;
          const selectOption = (option)=>{
              option.selected = newValue;
              this.dispatchUIEvent(select, 'input', {
                  bubbles: true,
                  cancelable: false,
                  composed: true
              });
              this.dispatchUIEvent(select, 'change');
          };
          if (isElementType(select, 'select')) {
              if (select.multiple) {
                  for (const option of selectedOptions){
                      const withPointerEvents = this.config.pointerEventsCheck === 0 ? true : hasPointerEvents(this, option);
                      // events fired for multiple select are weird. Can't use hover...
                      if (withPointerEvents) {
                          this.dispatchUIEvent(option, 'pointerover');
                          this.dispatchUIEvent(select, 'pointerenter');
                          this.dispatchUIEvent(option, 'mouseover');
                          this.dispatchUIEvent(select, 'mouseenter');
                          this.dispatchUIEvent(option, 'pointermove');
                          this.dispatchUIEvent(option, 'mousemove');
                          this.dispatchUIEvent(option, 'pointerdown');
                          this.dispatchUIEvent(option, 'mousedown');
                      }
                      focusElement(select);
                      if (withPointerEvents) {
                          this.dispatchUIEvent(option, 'pointerup');
                          this.dispatchUIEvent(option, 'mouseup');
                      }
                      selectOption(option);
                      if (withPointerEvents) {
                          this.dispatchUIEvent(option, 'click');
                      }
                      await wait(this.config);
                  }
              } else if (selectedOptions.length === 1) {
                  const withPointerEvents = this.config.pointerEventsCheck === 0 ? true : hasPointerEvents(this, select);
                  // the click to open the select options
                  if (withPointerEvents) {
                      await this.click(select);
                  } else {
                      focusElement(select);
                  }
                  selectOption(selectedOptions[0]);
                  if (withPointerEvents) {
                      // the browser triggers another click event on the select for the click on the option
                      // this second click has no 'down' phase
                      this.dispatchUIEvent(select, 'pointerover');
                      this.dispatchUIEvent(select, 'pointerenter');
                      this.dispatchUIEvent(select, 'mouseover');
                      this.dispatchUIEvent(select, 'mouseenter');
                      this.dispatchUIEvent(select, 'pointerup');
                      this.dispatchUIEvent(select, 'mouseup');
                      this.dispatchUIEvent(select, 'click');
                  }
                  await wait(this.config);
              } else {
                  throw getConfig().getElementError(`Cannot select multiple options on a non-multiple select`, select);
              }
          } else if (select.getAttribute('role') === 'listbox') {
              for (const option of selectedOptions){
                  await this.click(option);
                  await this.unhover(option);
              }
          } else {
              throw getConfig().getElementError(`Cannot select options on elements that are neither select nor listbox elements`, select);
          }
      }

      async function type$1(element, text, { skipClick = this.config.skipClick, skipAutoClose = this.config.skipAutoClose, initialSelectionStart, initialSelectionEnd } = {}) {
          // TODO: properly type guard
          // we use this workaround for now to prevent changing behavior
          if (element.disabled) return;
          if (!skipClick) {
              await this.click(element);
          }
          if (initialSelectionStart !== undefined) {
              setSelectionRange(element, initialSelectionStart, initialSelectionEnd !== null && initialSelectionEnd !== undefined ? initialSelectionEnd : initialSelectionStart);
          }
          await this.keyboard(text);
          if (!skipAutoClose) {
              await releaseAllKeys(this);
          }
      }

      // It is not possible to create a real FileList programmatically.
      // Therefore assigning `files` property with a programmatically created FileList results in an error.
      // Just assigning the property (as per fireEvent) breaks the interweaving with the `value` property.
      const fakeFiles = Symbol('files and value properties are mocked');
      function restoreProperty(obj, prop, descriptor) {
          if (descriptor) {
              Object.defineProperty(obj, prop, descriptor);
          } else {
              // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
              delete obj[prop];
          }
      }
      function setFiles(el, files) {
          var _el_fakeFiles;
          (_el_fakeFiles = el[fakeFiles]) === null || _el_fakeFiles === undefined ? undefined : _el_fakeFiles.restore();
          const typeDescr = Object.getOwnPropertyDescriptor(el, 'type');
          const valueDescr = Object.getOwnPropertyDescriptor(el, 'value');
          const filesDescr = Object.getOwnPropertyDescriptor(el, 'files');
          function restore() {
              restoreProperty(el, 'type', typeDescr);
              restoreProperty(el, 'value', valueDescr);
              restoreProperty(el, 'files', filesDescr);
          }
          el[fakeFiles] = {
              restore
          };
          Object.defineProperties(el, {
              files: {
                  configurable: true,
                  get: ()=>files
              },
              value: {
                  configurable: true,
                  get: ()=>files.length ? `C:\\fakepath\\${files[0].name}` : '',
                  set (v) {
                      if (v === '') {
                          restore();
                      } else {
                          var _valueDescr_set;
                          valueDescr === null || valueDescr === undefined ? undefined : (_valueDescr_set = valueDescr.set) === null || _valueDescr_set === undefined ? undefined : _valueDescr_set.call(el, v);
                      }
                  }
              },
              type: {
                  configurable: true,
                  get: ()=>'file',
                  set (v) {
                      if (v !== 'file') {
                          restore();
                          el.type = v;
                      }
                  }
              }
          });
      }

      async function upload$1(element, fileOrFiles) {
          const input = isElementType(element, 'label') ? element.control : element;
          if (!input || !isElementType(input, 'input', {
              type: 'file'
          })) {
              throw new TypeError(`The ${input === element ? 'given' : 'associated'} ${input === null || input === undefined ? undefined : input.tagName} element does not accept file uploads`);
          }
          if (isDisabled(element)) return;
          const files = (Array.isArray(fileOrFiles) ? fileOrFiles : [
              fileOrFiles
          ]).filter((file)=>!this.config.applyAccept || isAcceptableFile(file, input.accept)).slice(0, input.multiple ? undefined : 1);
          const fileDialog = ()=>{
              var _input_files;
              // do not fire an input event if the file selection does not change
              if (files.length === ((_input_files = input.files) === null || _input_files === undefined ? undefined : _input_files.length) && files.every((f, i)=>{
                  var _input_files;
                  return f === ((_input_files = input.files) === null || _input_files === undefined ? undefined : _input_files.item(i));
              })) {
                  return;
              }
              setFiles(input, createFileList(getWindow(element), files));
              this.dispatchUIEvent(input, 'input');
              this.dispatchUIEvent(input, 'change');
          };
          input.addEventListener('fileDialog', fileDialog);
          await this.click(element);
          input.removeEventListener('fileDialog', fileDialog);
      }
      // When matching files, browsers ignore case and consider jpeg/jpg interchangeable.
      function normalize(nameOrType) {
          return nameOrType.toLowerCase().replace(/(\.|\/)jpg\b/g, '$1jpeg');
      }
      function isAcceptableFile(file, accept) {
          if (!accept) {
              return true;
          }
          const wildcards = [
              'audio/*',
              'image/*',
              'video/*'
          ];
          return normalize(accept).trim().split(/\s*,\s*/).some((acceptToken)=>{
              // tokens starting with a dot represent a file extension
              if (acceptToken.startsWith('.')) {
                  return normalize(file.name).endsWith(acceptToken);
              } else if (wildcards.includes(acceptToken)) {
                  return normalize(file.type).startsWith(acceptToken.replace('*', ''));
              }
              return normalize(file.type) === acceptToken;
          });
      }

      const userEventApi = {
          click: click$1,
          dblClick: dblClick$1,
          tripleClick: tripleClick$1,
          hover: hover$1,
          unhover: unhover$1,
          tab: tab$1,
          keyboard: keyboard$1,
          copy: copy$1,
          cut: cut$1,
          paste: paste$1,
          pointer: pointer$1,
          clear: clear$1,
          deselectOptions: deselectOptions$1,
          selectOptions: selectOptions$1,
          type: type$1,
          upload: upload$1
      };

      /**
       * Wrap an internal Promise
       */ function wrapAsync(implementation) {
          return getConfig().asyncWrapper(implementation);
      }

      /**
       * Default options applied when API is called per `userEvent.anyApi()`
       */ const defaultOptionsDirect = {
          applyAccept: true,
          autoModify: true,
          delay: 0,
          document: globalThis.document,
          keyboardMap: defaultKeyMap$1,
          pointerMap: defaultKeyMap,
          pointerEventsCheck: PointerEventsCheckLevel.EachApiCall,
          skipAutoClose: false,
          skipClick: false,
          skipHover: false,
          writeToClipboard: false,
          advanceTimers: ()=>Promise.resolve()
      };
      /**
       * Default options applied when API is called per `userEvent().anyApi()`
       */ const defaultOptionsSetup = {
          ...defaultOptionsDirect,
          writeToClipboard: true
      };
      function createConfig(options = {}, defaults = defaultOptionsSetup, node) {
          const document = getDocument(options, node, defaults);
          return {
              ...defaults,
              ...options,
              document
          };
      }
      /**
       * Start a "session" with userEvent.
       * All APIs returned by this function share an input device state and a default configuration.
       */ function setupMain(options = {}) {
          const config = createConfig(options);
          prepareDocument(config.document);
          patchFocus(getWindow(config.document).HTMLElement);
          var _config_document_defaultView;
          const view = (_config_document_defaultView = config.document.defaultView) !== null && _config_document_defaultView !== undefined ? _config_document_defaultView : /* istanbul ignore next */ globalThis.window;
          attachClipboardStubToView(view);
          return createInstance(config).api;
      }
      /**
       * Setup in direct call per `userEvent.anyApi()`
       */ function setupDirect({ keyboardState, pointerState, ...options } = {}, node) {
          const config = createConfig(options, defaultOptionsDirect, node);
          prepareDocument(config.document);
          patchFocus(getWindow(config.document).HTMLElement);
          var _ref;
          const system = (_ref = pointerState !== null && pointerState !== undefined ? pointerState : keyboardState) !== null && _ref !== undefined ? _ref : new System();
          return {
              api: createInstance(config, system).api,
              system
          };
      }
      /**
       * Create a set of callbacks with different default settings but the same state.
       */ function setupSub(options) {
          return createInstance({
              ...this.config,
              ...options
          }, this.system).api;
      }
      function wrapAndBindImpl(instance, impl) {
          function method(...args) {
              setLevelRef(instance, ApiLevel.Call);
              return wrapAsync(()=>impl.apply(instance, args).then(async (ret)=>{
                      await wait(instance.config);
                      return ret;
                  }));
          }
          Object.defineProperty(method, 'name', {
              get: ()=>impl.name
          });
          return method;
      }
      function createInstance(config, system = new System()) {
          const instance = {};
          Object.assign(instance, {
              config,
              dispatchEvent: dispatchEvent.bind(instance),
              dispatchUIEvent: dispatchUIEvent.bind(instance),
              system,
              levelRefs: {},
              ...userEventApi
          });
          return {
              instance,
              api: {
                  ...Object.fromEntries(Object.entries(userEventApi).map(([name, api])=>[
                          name,
                          wrapAndBindImpl(instance, api)
                      ])),
                  setup: setupSub.bind(instance)
              }
          };
      }
      function getDocument(options, node, defaults) {
          var _options_document, _ref;
          return (_ref = (_options_document = options.document) !== null && _options_document !== undefined ? _options_document : node && getDocumentFromNode(node)) !== null && _ref !== undefined ? _ref : defaults.document;
      }

      function clear(element) {
          return setupDirect().api.clear(element);
      }
      function click(element, options = {}) {
          return setupDirect(options, element).api.click(element);
      }
      function copy(options = {}) {
          return setupDirect(options).api.copy();
      }
      function cut(options = {}) {
          return setupDirect(options).api.cut();
      }
      function dblClick(element, options = {}) {
          return setupDirect(options).api.dblClick(element);
      }
      function deselectOptions(select, values, options = {}) {
          return setupDirect(options).api.deselectOptions(select, values);
      }
      function hover(element, options = {}) {
          return setupDirect(options).api.hover(element);
      }
      async function keyboard(text, options = {}) {
          const { api, system } = setupDirect(options);
          return api.keyboard(text).then(()=>system);
      }
      async function pointer(input, options = {}) {
          const { api, system } = setupDirect(options);
          return api.pointer(input).then(()=>system);
      }
      function paste(clipboardData, options) {
          return setupDirect(options).api.paste(clipboardData);
      }
      function selectOptions(select, values, options = {}) {
          return setupDirect(options).api.selectOptions(select, values);
      }
      function tripleClick(element, options = {}) {
          return setupDirect(options).api.tripleClick(element);
      }
      function type(element, text, options = {}) {
          return setupDirect(options, element).api.type(element, text, options);
      }
      function unhover(element, options = {}) {
          const { api, system } = setupDirect(options);
          system.pointer.setMousePosition({
              target: element
          });
          return api.unhover(element);
      }
      function upload(element, fileOrFiles, options = {}) {
          return setupDirect(options).api.upload(element, fileOrFiles);
      }
      function tab(options = {}) {
          return setupDirect().api.tab(options);
      }

      const directApi = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
          __proto__: null,
          clear,
          click,
          copy,
          cut,
          dblClick,
          deselectOptions,
          hover,
          keyboard,
          paste,
          pointer,
          selectOptions,
          tab,
          tripleClick,
          type,
          unhover,
          upload
      }, Symbol.toStringTag, { value: 'Module' }));

      const userEvent = {
          ...directApi,
          setup: setupMain
      };

      /**
       * 主观题回答工具类
       * 使用 OpenAI 兼容的 API 进行流式回答
       */


      const DEFAULT_BASE_URL = 'https://api.siliconflow.cn/v1';
      const DEFAULT_MODEL_NAME = 'THUDM/GLM-4.1V-9B-Thinking';
      const DEFAULT_SYSTEM_PROMPT = '你是一个专业全能的助手。请清晰、准确地回答问题，提供简明而准确的信息。使用正式、专业的语气。在适当情况下解释你的推理或提供背景信息，但避免不必要的冗长。始终确保答案可靠、易于理解。';

      /**
       * 获取主观题回答配置
       * @returns {Promise<object>} 配置对象
       */
      async function getSubjectiveAnswerConfig() {
        const apiKey = await getStorageValue$1('beelineHelper_aiToken', '') || '';
        const baseUrl = await getStorageValue$1('beelineHelper_baseUrl', '') || DEFAULT_BASE_URL;
        const modelName = await getStorageValue$1('beelineHelper_modelName', '') || DEFAULT_MODEL_NAME;
        const systemPrompt = await getStorageValue$1('beelineHelper_systemPrompt', '') || DEFAULT_SYSTEM_PROMPT;

        return {
          apiKey,
          baseUrl,
          modelName,
          systemPrompt
        };
      }

      /**
       * 流式回答主观题
       * @param {string} question 题目内容
       * @param {function} onChunk 流式输出回调函数
       * @param {function} onComplete 完成回调函数
       * @returns {Promise<object>} 回答结果
       */
      async function streamAnswerSubjectiveQuestion(question, onChunk = null, onComplete = null) {
        const config = await getSubjectiveAnswerConfig();

        if (!config.apiKey) {
          throw new Error('请先在答题设置中设置 AI Token');
        }

        if (!question.trim()) {
          throw new Error('题目内容为空');
        }

        // 验证 BASE_URL
        if (!config.baseUrl || typeof config.baseUrl !== 'string') {
          throw new Error('BASE_URL 配置无效，请在答题设置中检查 BASE_URL 设置');
        }

        // 清理 BASE_URL，移除末尾的斜杠
        const cleanBaseUrl = config.baseUrl.replace(/\/$/, '');

        // 提前查找并检查输入框
        const textarea = await findTextarea();
        if (textarea) {
          // 检查输入框是否已有内容，如果有内容则跳过自动答题
          if (hasExistingContent(textarea)) {
            console.log('输入框已有内容，跳过自动答题');
            return {
              success: false,
              message: '输入框已有内容，跳过自动答题',
              question: question,
              aiAssisted: true
            };
          }
        }

        try {
          const requestUrl = `${cleanBaseUrl}/chat/completions`;
          console.log('主观题 API 请求 URL:', requestUrl);
          console.log('API Key 存在:', !!config.apiKey);
          console.log('模型名称:', config.modelName);

          const response = await fetch(requestUrl, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${config.apiKey}`
            },
            body: JSON.stringify({
              model: config.modelName,
              messages: [
                {
                  role: 'system',
                  content: config.systemPrompt
                },
                {
                  role: 'user',
                  content: question
                }
              ],
              stream: true,
              temperature: 0.7,
              max_tokens: 2000
            })
          });

          if (!response.ok) {
            console.error('API 响应状态:', response.status, response.statusText);
            const errorData = await response.json().catch(() => ({}));
            console.error('API 错误数据:', errorData);
            throw new Error(`API 请求失败: ${response.status} - ${errorData.error?.message || response.statusText}`);
          }

          const reader = response.body.getReader();
          const decoder = new TextDecoder();
          let fullAnswer = '';

          // 清空输入框并聚焦
          if (textarea) {
            await clearAndFocusTextarea(textarea);
          }

          while (true) {
            const { done, value } = await reader.read();

            if (done) {
              break;
            }

            const chunk = decoder.decode(value, { stream: true });
            const lines = chunk.split('\n').filter(line => line.trim());

            for (const line of lines) {
              if (line.startsWith('data: ')) {
                const data = line.slice(6);

                if (data === '[DONE]') {
                  break;
                }

                try {
                  const parsed = JSON.parse(data);
                  const content = parsed.choices?.[0]?.delta?.content;

                  if (content) {
                    fullAnswer += content;

                    // 实时将内容输入到输入框
                    if (textarea) {
                      await appendToTextarea(textarea, content);
                    }

                    // 调用流式输出回调
                    if (onChunk && typeof onChunk === 'function') {
                      onChunk(content, fullAnswer);
                    }
                  }
                } catch (e) {
                  console.warn('解析流式数据失败:', e);
                }
              }
            }
          }

          // 调用完成回调
          if (onComplete && typeof onComplete === 'function') {
            onComplete(fullAnswer);
          }

          return {
            success: true,
            answer: fullAnswer,
            question: question,
            aiAssisted: true
          };

        } catch (error) {
          console.error('主观题回答失败:', error);
          return {
            success: false,
            message: `回答失败: ${error.message}`,
            question: question,
            aiAssisted: true
          };
        }
      }

      /**
       * 查找输入框
       * @returns {Promise<HTMLElement|null>} 输入框元素
       */
      async function findTextarea() {
        // 查找主观题输入框 - 尝试多种选择器
        let textarea = document.querySelector("[id^='w-e-textarea-']");

        if (!textarea) {
          // 尝试其他可能的选择器
          textarea = document.querySelector('.w-e-textarea');
        }

        if (!textarea) {
          // 尝试查找富文本编辑器的内容区域
          textarea = document.querySelector('.w-e-text');
        }

        if (!textarea) {
          // 尝试查找任何包含contenteditable属性的元素
          textarea = document.querySelector('[contenteditable="true"]');
        }

        if (textarea) {
          console.log('找到输入框:', textarea);
          console.log('输入框类型:', textarea.tagName);
          console.log('输入框属性:', {
            id: textarea.id,
            className: textarea.className,
            contenteditable: textarea.getAttribute('contenteditable')
          });
        }

        return textarea;
      }

      /**
       * 检查输入框是否已有内容
       * @param {HTMLElement} textarea 输入框元素
       * @returns {boolean} 是否已有内容
       */
      function hasExistingContent(textarea) {
        if (textarea.tagName === 'TEXTAREA') {
          return textarea.value.trim().length > 0;
        } else {
          return textarea.textContent.trim().length > 0;
        }
      }

      /**
       * 清空输入框并聚焦
       * @param {HTMLElement} textarea 输入框元素
       */
      async function clearAndFocusTextarea(textarea) {
        try {
          const user = userEvent.setup();

          // 聚焦到输入框
          await user.click(textarea);

          // 清空现有内容
          await user.clear(textarea);

          console.log('输入框已清空并聚焦');
        } catch (error) {
          console.warn('user-event清空输入框失败，使用备用方法:', error);

          // 备用方法
          textarea.focus();
          if (textarea.tagName === 'TEXTAREA') {
            textarea.value = '';
          } else {
            textarea.textContent = '';
          }
        }
      }

      /**
       * 向输入框追加内容
       * @param {HTMLElement} textarea 输入框元素
       * @param {string} content 要追加的内容
       */
      async function appendToTextarea(textarea, content) {
        try {
          const user = userEvent.setup();

          // 使用user-event输入内容
          await user.type(textarea, content, { delay: 0 });

          console.log('实时输入内容:', content);
        } catch (error) {
          console.warn('user-event实时输入失败，使用备用方法:', error);

          // 备用方法
          if (textarea.tagName === 'TEXTAREA') {
            textarea.value += content;

            // 触发输入事件
            const inputEvent = new Event('input', { bubbles: true });
            textarea.dispatchEvent(inputEvent);
          } else {
            // 对于contenteditable元素，使用execCommand
            try {
              document.execCommand('insertText', false, content);
            } catch (e) {
              // 如果execCommand失败，直接追加
              textarea.textContent += content;
            }
          }
        }
      }

      /**
       * 检查主观题回答配置是否完整
       * @returns {Promise<object>} 检查结果
       */
      async function checkSubjectiveAnswerConfig() {
        const config = await getSubjectiveAnswerConfig();

        if (!config.apiKey) {
          return {
            valid: false,
            message: '请先在答题设置中设置 AI Token'
          };
        }

        // 验证 BASE_URL
        if (!config.baseUrl || typeof config.baseUrl !== 'string') {
          return {
            valid: false,
            message: 'BASE_URL 配置无效，请在答题设置中检查 BASE_URL 设置'
          };
        }

        return {
          valid: true,
          message: '配置完整'
        };
      }

    })
  };
}));

System.import("./__entry.js", "./");